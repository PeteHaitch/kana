{"version":3,"file":"static/js/318.4598345c.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/regenerator/index.js","../node_modules/bakana/module/abstract/worker_child.js","../node_modules/bakana/module/utils/general.js","../node_modules/bakana/module/utils/viz_child.js","../node_modules/scran.js/module/findNearestNeighbors.js","../node_modules/scran.js/module/utils.js","../node_modules/scran.js/module/wasm.js","../node_modules/wasmarrays.js/src/derived.js","../node_modules/wasmarrays.js/src/create.js"],"sourcesContent":["module.exports = require(\"regenerator-runtime\");\n","export function registerCallback(callback) {\n    self.onmessage = callback;\n    return;\n}\n\nexport function sendMessage(message, transfer) {\n    self.postMessage(message, transfer);\n    return;\n}\n","import * as scran from \"scran.js\";\n\nexport function mimicGetter(value, copy) {\n    // Inheritance seems to be namespaced by module,\n    // so we can't use instanceof.\n    if (\"className\" in value.constructor && value.constructor.className.endsWith(\"WasmArray\")) { \n        if (copy == \"view\" || copy == \"hdf5\") {\n            return value.view();\n        } else if (copy) {\n            return value.slice();\n        } else {\n            return value.array();\n        }\n    } else {\n        if (copy === true) {\n            return value.slice();\n        } else if (copy == \"view\") {\n            // If the caller actually wanted a WasmArray, they would\n            // have generated a WasmArray during the unserialization.\n            throw new Error(\"'copy: \\\"view\\\"' not supported for mimics\");\n        } else {\n            // Includes copy = \"hdf5\", where a TypedArray or WasmArray can be used.\n            return value;\n        }\n    }\n}\n\nexport function freeCache(object) {\n    if (object !== undefined && object !== null) {\n        object.free();\n    }\n    return;\n}\n\nexport function changedParameters(x, y) {\n    return JSON.stringify(x) != JSON.stringify(y);\n}\n\nexport function allocateCachedArray(size, type, cache, name = \"buffer\") {\n    var reallocate = true;\n    if (name in cache) {\n        var candidate = cache[name];\n\n        // Views also trigger reallocation, because it is assumed that the\n        // caller of this function does not own the view, but downstream\n        // uses of the array will involve writing to it.\n        if (candidate.size != size || candidate.constructor.className != type || candidate.owner !== null) { \n            candidate.free();\n        } else {\n            reallocate = false;\n        }\n    }\n  \n    if (reallocate) {\n        switch (type) {\n            case \"Uint8Array\":\n                cache[name] = scran.createUint8WasmArray(size);\n                break;\n            case \"Int32Array\":\n                cache[name] = scran.createInt32WasmArray(size);\n                break;\n            case \"Float64Array\":\n                cache[name] = scran.createFloat64WasmArray(size);\n                break;\n            default:\n                // We only ever use one of the three above types in our \n                // internal data stores, so no need to go all-out here.\n                throw \"allocating '\" + type + \"' not yet supported\";\n        }\n    }\n\n    return cache[name];\n}\n\nexport function isObject(object) {\n    return typeof object === 'object' && Array.isArray(object) === false && ArrayBuffer.isView(object) === false;\n}\n\nexport function findValidUpstreamStates(states, msg) {\n    let to_use = [];\n    for (const [k, v] of Object.entries(states)) {\n        if (v.valid()) {\n            to_use.push(k);\n        }\n    }\n    if (to_use.length == 0) {\n        throw new Error(\"expected at least one valid upstream \" + msg + \" state\");\n    }\n    return to_use;\n}\n","import * as scran from \"scran.js\";\n\nexport function chooseDelay(animate) {\n    if (animate) {\n        // TODO: using 75 for now\n        // in the future the user can choose a bar for speed on the UI\n        // options would be 1x, 2x, 3x\n        return 75;\n    } else {\n        return 1000000; // effectively no delay.\n    }\n};\n\nexport function recreateNeighbors(neighbors) {\n    var output = null;\n    var rbuf = null;\n    var ibuf = null;\n    var dbuf = null;\n  \n    try {\n        var num_obs = neighbors.num_obs;\n        var size = neighbors.size;\n\n        rbuf = scran.createInt32WasmArray(num_obs);\n        rbuf.set(neighbors.runs);\n        ibuf = scran.createInt32WasmArray(size);\n        ibuf.set(neighbors.indices);\n        dbuf = scran.createFloat64WasmArray(size);\n        dbuf.set(neighbors.distances);\n\n        output = scran.NeighborSearchResults.unserialize(rbuf, ibuf, dbuf);\n\n    } finally {\n        if (rbuf !== null) {\n            rbuf.free();\n        }\n        if (ibuf !== null) {\n            ibuf.free();\n        }\n        if (dbuf !== null) {\n            dbuf.free();\n        }\n    }\n\n    return output;\n};\n","import * as utils from \"./utils.js\";\nimport * as wasm from \"./wasm.js\";\nimport { PCAResults } from \"./runPCA.js\";\n\n/** \n * Wrapper for the neighbor search index on the Wasm heap.\n */\nexport class NeighborSearchIndex {\n    /**\n     * @param {Object} raw Search index on the Wasm heap.\n     *\n     * Not to be called directly by developers;\n     * use `buildNeighborSearchIndex()` instead.\n     */\n    constructor(raw) {\n        this.index = raw;\n        return;\n    }\n\n    /**\n     * @return Number of cells in the index.\n     */\n    numberOfCells() {\n        return this.index.num_obs();\n    }\n\n    /**\n     * @return Number of dimensions in the index.\n     */\n    numberOfDims() {\n        return this.index.num_dim();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.index !== null) {\n            this.index.delete();\n            this.index = null;\n        }\n        return;\n    }\n}\n\n/**\n * Build the nearest neighbor search index.\n *\n * @param {(PCAResults|Float64WasmArray|Array|TypedArray)} x - Numeric coordinates of each cell in the dataset.\n * For array inputs, this is expected to be in column-major format where the rows are the variables and the columns are the cells.\n * For a `PCAResults` input, we extract the principal components.\n * @param {Object} [options] - Optional parameters.\n * @param {number} [options.numberOfDims] - Number of variables/dimensions per cell.\n * Only used (and required) for array-like `x`.\n * @param {number} [options.numberOfCells] - Number of cells.\n * Only used (and required) for array-like `x`.\n * @param {boolean} [options.approximate] - Whether to build an index for an approximate neighbor search.\n *\n * @return A `NeighborSearchIndex` object to use for neighbor searches.\n */\nexport function buildNeighborSearchIndex(x, { numberOfDims = null, numberOfCells = null, approximate = true } = {}) {\n    var buffer;\n    var raw;\n    var output;\n\n    try {\n        let pptr;\n\n        if (x instanceof PCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            let pcs = x.principalComponents({ copy: false });\n            pptr = pcs.byteOffset;\n\n        } else {\n            if (numberOfDims === null || numberOfCells === null) {\n                throw new Error(\"'numberOfDims' and 'numberOfCells' must be specified when 'x' is an Array\");\n            }\n\n            buffer = utils.wasmifyArray(x, \"Float64WasmArray\");\n            if (buffer.length != numberOfDims * numberOfCells) {\n                throw new Error(\"length of 'x' must be the product of 'numberOfDims' and 'numberOfCells'\");\n            }\n\n            pptr = buffer.offset;\n        }\n\n        raw = wasm.call(module => module.build_neighbor_index(pptr, numberOfDims, numberOfCells, approximate)); \n        output = new NeighborSearchIndex(raw);\n\n    } catch (e) {\n        utils.free(raw);\n        throw e;\n\n    } finally {\n        utils.free(buffer);\n    }\n\n    return output;\n}\n\n/** \n * Wrapper for the neighbor search results on the Wasm heap.\n */\nexport class NeighborSearchResults {\n    /**\n     * @param {Object} raw Search results on the Wasm heap.\n     *\n     * Not to be called directly by developers;\n     * use `findNearestNeighbors()` or `unserialize()` instead.\n     */\n    constructor(raw) {\n        this.results = raw;\n        return;\n    }\n\n    /**\n     * @return The total number of neighbors across all cells.\n     * This is usually the product of the number of neighbors and the number of cells.\n     */\n    size() {\n        return this.results.size();\n    }\n\n    /**\n     * @return The number of cells used in the search.\n     */\n    numberOfCells() {\n        return this.results.num_obs();\n    }\n\n    /**\n     * @param {Object} [options] - Optional parameters.\n     * @param {?Int32WasmArray} [options.runs] - A Wasm-allocated array of length equal to `numberOfCells()`,\n     * to be used to store the number of neighbors per cell.\n     * @param {?Int32WasmArray} [options.indices] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the indices of the neighbors of each cell.\n     * @param {?Float64WasmArray} [options.distances] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the distances to the neighbors of each cell.\n     *\n     * @return \n     * If all of the arguments are non-`null`, the buffers in `runs`, `indices` and `distances` are filled with their respective contents, and nothing is returned.\n     * If all of the arguments are `null`, a object is returned with `TypedArray` entries for each component.\n     * Otherwise, an error is raised.\n     */\n    serialize({ runs = null, indices = null, distances = null } = {}) {\n        var copy = (runs === null) + (indices === null) + (distances === null);\n        if (copy != 3 && copy != 0) {\n            throw new Error(\"either all or none of 'runs', 'indices' and 'distances' can be 'null'\");\n        }\n\n        if (copy === 3) {\n            var run_data;\n            var ind_data;\n            var dist_data;\n            var output;\n            \n            try {\n                run_data = utils.createInt32WasmArray(this.numberOfCells());\n                let s = this.size();\n                ind_data = utils.createInt32WasmArray(s);\n                dist_data = utils.createFloat64WasmArray(s);\n                this.results.serialize(run_data.offset, ind_data.offset, dist_data.offset);\n\n                output = { \n                    \"runs\": run_data.slice(), \n                    \"indices\": ind_data.slice(), \n                    \"distances\": dist_data.slice() \n                };\n            } finally {\n                utils.free(run_data);\n                utils.free(ind_data);\n                utils.free(dist_data);\n            }\n\n            return output;\n        } else {\n            this.results.serialize(runs.offset, indices.offset, distances.offset);\n        }\n    }\n\n    /**\n     * @param {Int32WasmArray|Array|TypedArray} runs An array of length equal to `numberOfCells()`,\n     * containing the number of neighbors per cell.\n     * @param {Int32WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the indices of the neighbors of each cell.\n     * @param {Float64WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the distances to the neighbors of each cell.\n     *\n     * @return A new `NeighborSearchResults` object containing the unserialized search results.\n     */\n    static unserialize(runs, indices, distances) {\n        var raw;\n        var output;\n        var run_data;\n        var ind_data;\n        var dist_data;\n\n        try {\n            run_data = utils.wasmifyArray(runs, \"Int32WasmArray\");\n            ind_data = utils.wasmifyArray(indices, \"Int32WasmArray\");\n            dist_data = utils.wasmifyArray(distances, \"Float64WasmArray\");\n            raw = wasm.call(module => new module.NeighborResults(runs.length, run_data.offset, ind_data.offset, dist_data.offset));\n            output = new NeighborSearchResults(raw);\n        } catch (e) {\n            utils.free(raw);\n            throw e;\n        } finally { \n            utils.free(run_data);\n            utils.free(ind_data);\n            utils.free(dist_data);\n        }\n\n        return output;\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.results !== null) {\n            this.results.delete();\n            this.results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Find the nearest neighbors for each cell.\n *\n * @param {NeighborSearchIndex} x The pre-build neighbor search index from `buildNeighborSearchIndex()`.\n * @param {number} k Number of neighbors to find.\n *\n * @return A `NeighborSearchResults` object containing the search results.\n */\nexport function findNearestNeighbors(x, k) {\n    var raw;\n    var output;\n\n    try {\n        raw = wasm.call(module => module.find_nearest_neighbors(x.index, k));\n        output = new NeighborSearchResults(raw);\n    } catch (e) {\n        utils.free(raw);\n        throw e;\n    }\n\n    return output;\n}\n","import { buffer, wasmArraySpace } from \"./wasm.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Helper function to create a `Uint8WasmArray` from the **WasmArray** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return A `Uint8WasmArray` on the **scran.js** Wasm heap.\n */\nexport function createUint8WasmArray(length) {\n    return wa.createUint8WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a `Int32WasmArray` from the **WasmArray** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return A `Int32WasmArray` on the **scran.js** Wasm heap.\n */\nexport function createInt32WasmArray(length) {\n    return wa.createInt32WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a `BigUint64WasmArray` from the **WasmArray** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return A `BigUint64WasmArray` on the **scran.js** Wasm heap.\n */\nexport function createBigUint64WasmArray (length) {\n    return wa.createBigUint64WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a `Float64WasmArray` from the **WasmArray** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return A `Float64WasmArray` on the **scran.js** Wasm heap.\n */\nexport function createFloat64WasmArray(length) {\n    return wa.createFloat64WasmArray(wasmArraySpace(), length);\n}\n\nexport function wasmifyArray(x, expected) {\n    if (x instanceof wa.WasmArray) {\n        if (expected !== null && expected != x.constructor.className) {\n            throw new Error(\"expected '\" + expected + \"', got '\" + x.constructor.className + \"'\");\n        }\n\n        if (x.space === wasmArraySpace()) {\n            // Creating a view. This ensures that callers can always call\n            // free() on the output of this function without worrying about\n            // whether they are breaking something else that was using 'x'.\n            if (x.owner === null) {\n                return x.view();\n            } else {\n                return x; // it's already a view, so we just pass it along.\n            }\n        } else {\n            // If it's a different space, then we have to make a copy.\n            return x.clone(wasmArraySpace());\n        }\n    }\n\n    let y = null;\n    if (expected !== null) {\n        y = wa.convertToWasmArray(wasmArraySpace(), x, wa.stringToClass(expected));\n    } else {\n        y = wa.convertToWasmArray(wasmArraySpace(), x);\n    }\n\n    return y;\n}\n\nexport function free(x) {\n    if (x !== null && x !== undefined) {\n        if (\"free\" in x) {\n            x.free();\n        } else if (\"delete\" in x) {\n            x.delete(); // i.e., one of the raw C++ classes.\n        }\n    }\n}\n\nexport function extractXY(ncells, coordinates) {\n    let x = new Float64Array(ncells);\n    let y = new Float64Array(ncells);\n\n    for (var i = 0; i < ncells; i++) {\n        x[i] = coordinates[2 * i];\n        y[i] = coordinates[2 * i + 1];\n    }\n\n    return { \"x\": x, \"y\": y };\n}\n\nexport function possibleCopy(x, copy) {\n    if (copy === \"view\") {\n        if (x.buffer !== buffer()) {\n            throw new Error(\"cannot use copy = \\\"view\\\" for non-Wasm TypedArrays\");\n        }\n\n        let view_class = x.constructor.name.replace(\"Array\", \"WasmArray\");\n\n        // This function should only be used for objects generated in the\n        // buffer owned by scran.js, so we can assume that x's space is the\n        // same as that of the wasmArraySpace().\n        return wa.createWasmArrayView(wasmArraySpace(), x.length, x.byteOffset, wa.stringToClass(view_class));\n\n    } else if (copy) {\n        return x.slice();\n\n    } else {\n        return x;\n    }\n}\n\nexport function matchOptions(name, value, choices) {\n    if (choices.indexOf(value) == -1) {\n        throw new Error(\"'\" + name + \"=' should be one of '\" + choices.join(\"', '\") + \"'\");\n    }\n}\n","import loadScran from \"./wasm/scran.js\";\nimport { register } from \"wasmarrays.js\";\n\nconst cache = {};\n\n/**\n * @param {Object} [options] - Optional parameters.\n * @param {number} [options.numberOfThreads] - Number of threads to use for calculations.\n * This will spin up the requested number of Web Workers during module initialization.\n * @param {boolean} [options.localFile] - Whether or not to look for the Wasm and worker scripts locally.\n * Should only be `true` when using old versions of Node where file URLs are not supported.\n *\n * @return \n * The Wasm bindings are initialized and `true` is returned.\n * If the bindings were already initialized (e.g., by a previous call), nothing is done and `false` is returned.\n */\nexport async function initialize({ numberOfThreads = 4, localFile = false } = {}) {\n    if (\"module\" in cache) {\n        return false;\n    }\n\n    let options = {\n        scran_custom_nthreads: numberOfThreads\n    }\n\n    if (localFile) {\n        options.locateFile = (x) => import.meta.url.substring(7) + \"/../wasm/\" + x;\n    }\n\n    cache.module = await loadScran(options);\n    cache.space = register(cache.module);\n\n    return true;\n}\n\nexport function call(func) {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n\n    var output;\n    try {\n        output = func(cache.module);    \n    } catch (e) {\n        if (typeof e == \"number\") {\n            throw new Error(cache.module.get_error_message(e));\n        } else {\n            throw e;\n        }\n    }\n    return output;\n}\n\nexport function buffer() {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n    return cache.module.wasmMemory.buffer;\n}\n\n/**\n * @return Integer containing the **WasmArray** identifier for **scran.js**'s memory space.\n * This can be used with `WasmArray.createWasmArray()` and related functions.\n */\nexport function wasmArraySpace() {\n    return cache.space;\n}\n\n/**\n * @return All worker threads are terminated and the module is deleted from the cache.\n * This is useful for cleaning up at the end of the analysis,\n * otherwise the workers will be shut done ungracefully on program exit.\n */\nexport function terminate() {\n    cache.module.PThread.terminateAllThreads();\n    delete cache.module;\n    return;\n}\n\n/**\n * @return The current size of the Wasm heap, typically used for diagnostic reporting.\n */\nexport function heapSize() {\n    return buffer().byteLength;\n}\n\n/**\n * @param {string} path - Path to the output file on the virtual file system.\n * @param {Uint8Array} buffer - Buffer to write to file.\n *\n * @return `buffer` is written to the binary file `path`.\n *\n * This is intended for use in web browsers to allow `initializeSparseMatrixFromHDF5` to work properly.\n * Node applications should not call this function (and it probably won't work anyway); \n * rather, they can just read directly from the real file system.\n */\nexport function writeFile(path, buffer) {\n    cache.module.FS.writeFile(path, buffer);\n    return;\n}\n\n/**\n * @param {string} path - Path to a file on the virtual file system.\n *\n * @return A `Uint8Array` containing the binary contents of the file.\n *\n * This is intended for use in web browsers to load files written by the various HDF5 utilities.\n * Node applications should not call this function (and it probably won't work anyway); \n * rather, they can just read directly from the real file system.\n */\nexport function readFile(path) {\n    return cache.module.FS.readFile(path, { encoding: 'binary' });\n}\n\n/**\n * @param {string} path - Path to the file on the virtual file system.\n *\n * @return Deletes the specified file from the virtual file system.\n *\n * This is intended for use in web browsers to clean up after `writeFile()`.\n * Node applications should not call this function.\n */\nexport function removeFile(path) {\n    cache.module.FS.unlink(path);\n    return;\n}\n\n/**\n * @param {string} path - Path to the file on the virtual file system.\n * @return Boolean indicating whether the file exists.\n *\n * This is intended for use in web browsers. \n * Node applications should not call this function.\n */\nexport function fileExists(path) {\n    return cache.module.FS.analyzePath(path).exists;\n}\n","import { buffer } from \"./globals.js\";\nimport { WasmArray } from \"./base.js\";\n\n/** \n * Wrapper around an unsigned 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint8WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Uint8WasmArray extends WasmArray {\n    /**\n     * @return A Uint8Array view of the allocated memory.\n     */\n    array() {\n        return new Uint8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Uint8WasmArray\";\n    // We're returning the name explicitly here instead of relying\n    // on the constructor.name trick, as the name of the class can\n    // change during minification.\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around a signed 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt8WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Int8WasmArray extends WasmArray {\n    /**\n     * @return An Int8Array view of the allocated memory.\n     */\n    array() {\n        return new Int8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Int8WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around an unsigned 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint16WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Uint16WasmArray extends WasmArray {\n    /**\n     * @return A Uint16Array view of the allocated memory.\n     */\n    array() {\n        return new Uint16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Uint16WasmArray\";\n\n    /**\n     * Size of the each data value, in bytes.\n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage a signed 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt16WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Int16WasmArray extends WasmArray {\n    /**\n     * @return An `Int16Array` view of the allocated memory.\n     */\n    array() {\n        return new Int16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Int16WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage an unsigned 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint32WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Uint32WasmArray extends WasmArray {\n    /**\n     * @return A Uint32Array view of the allocated memory.\n     */\n    array() {\n        return new Uint32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Uint32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a signed 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt32WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Int32WasmArray extends WasmArray {\n    /**\n     * @return An Int32Array view of the allocated memory.\n     */\n    array() {\n        return new Int32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     */\n    static className = \"Int32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage an unsigned 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigUint64WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class BigUint64WasmArray extends WasmArray {\n    /**\n     * @return A BigUint64Array view of the allocated memory.\n     */\n    array() {\n        return new BigUint64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"BigUint64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a signed 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigInt64WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class BigInt64WasmArray extends WasmArray {\n    /**\n     * @return An BigInt64Array view of the allocated memory.\n     */\n    array() {\n        return new BigInt64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     */\n    static className = \"BigInt64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a 32-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat32WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Float32WasmArray extends WasmArray {\n    /**\n     * @return A Float32Array view of the allocated memory.\n     */\n    array() {\n        return new Float32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     */\n    static className = \"Float32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a 64-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat64WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Float64WasmArray extends WasmArray {\n    /**\n     * @return A Float64Array view of the allocated memory.\n     */\n    array() {\n        return new Float64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     */\n    static className = \"Float64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 8;\n}\n\nconst choices = {\n    \"Uint8WasmArray\": Uint8WasmArray,\n    \"Int8WasmArray\": Int8WasmArray,\n    \"Uint16WasmArray\": Uint16WasmArray,\n    \"Int16WasmArray\": Int16WasmArray,\n    \"Uint32WasmArray\": Uint32WasmArray,\n    \"Int32WasmArray\": Int32WasmArray,\n    \"BigUint64WasmArray\": BigUint64WasmArray,\n    \"BigInt64WasmArray\": BigInt64WasmArray,\n    \"Float32WasmArray\": Float32WasmArray,\n    \"Float64WasmArray\": Float64WasmArray\n};\n\n/**\n * Retrieve class from its name.\n *\n * @param {string} name - Name of the {@linkplain WasmArray} class.\n *\n * @return Class object corresponding to `name`.\n */\nexport function stringToClass(name) {\n    if (!(name in choices)){ \n        throw new Error(\"unknown WasmArray class '\" + name + \"'\");\n    }\n    return choices[name];\n}\n","import { allocate } from \"./globals.js\";\nimport { \n    Int8WasmArray, Uint8WasmArray,\n    Int16WasmArray, Uint16WasmArray,\n    Int32WasmArray, Uint32WasmArray,\n    BigInt64WasmArray, BigUint64WasmArray,\n    Float32WasmArray, Float64WasmArray\n} from \"./derived.js\";\n\n/**\n * Create a {@linkplain WasmArray} of the specified subclass.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * @param {class} arrayClass - Desired subclass of the {@linkplain WasmArray}.\n * \n * @return Instance of a {@linkplain WasmArray} subclass.\n */\nexport function createWasmArray(space, length, arrayClass) {\n    return allocate(space, length, arrayClass);\n}\n\n/**\n * Create a {@linkplain Uint8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Uint8WasmArray}.\n */\nexport function createUint8WasmArray(space, length) { \n    return createWasmArray(space, length, Uint8WasmArray); \n}\n\n/**\n * Create a {@linkplain Int8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Int8WasmArray}.\n */\nexport function createInt8WasmArray(space, length) { \n    return createWasmArray(space, length, Int8WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Uint16WasmArray}.\n */\nexport function createUint16WasmArray(space, length) { \n    return createWasmArray(space, length, Uint16WasmArray); \n}\n\n/**\n * Create a {@linkplain Int16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Int16WasmArray}.\n */\nexport function createInt16WasmArray(space, length) { \n    return createWasmArray(space, length, Int16WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Uint32WasmArray}.\n */\nexport function createUint32WasmArray(space, length) { \n    return createWasmArray(space, length, Uint32WasmArray); \n}\n\n/**\n * Create a {@linkplain Int32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Int32WasmArray}.\n */\nexport function createInt32WasmArray(space, length) { \n    return createWasmArray(space, length, Int32WasmArray); \n}\n\n/**\n * Create a {@linkplain BigUint64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain BigUint64WasmArray}.\n */\nexport function createBigUint64WasmArray(space, length) { \n    return createWasmArray(space, length, BigUint64WasmArray); \n}\n\n/**\n * Create a {@linkplain BigInt64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain BigInt64WasmArray}.\n */\nexport function createBigInt64WasmArray(space, length) { \n    return createWasmArray(space, length, BigInt64WasmArray); \n}\n\n/**\n * Create a {@linkplain Float32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Float32WasmArray}.\n */\nexport function createFloat32WasmArray(space, length) { \n    return createWasmArray(space, length, Float32WasmArray); \n}\n\n/**\n * Create a {@linkplain Float64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Float64WasmArray}.\n */\nexport function createFloat64WasmArray(space, length) { \n    return createWasmArray(space, length, Float64WasmArray); \n}\n"],"names":["module","exports","registerCallback","callback","self","onmessage","sendMessage","message","transfer","postMessage","freeCache","object","undefined","free","changedParameters","x","y","JSON","stringify","chooseDelay","animate","recreateNeighbors","neighbors","output","rbuf","ibuf","dbuf","num_obs","size","scran","set","runs","indices","distances","NeighborSearchIndex","raw","this","index","num_dim","delete","NeighborSearchResults","results","copy","Error","run_data","ind_data","dist_data","utils","numberOfCells","s","serialize","offset","slice","wasm","NeighborResults","length","e","findNearestNeighbors","k","find_nearest_neighbors","createInt32WasmArray","wa","wasmArraySpace","createFloat64WasmArray","wasmifyArray","expected","constructor","className","space","owner","view","clone","extractXY","ncells","coordinates","Float64Array","i","cache","initialize","numberOfThreads","localFile","options","scran_custom_nthreads","locateFile","import","substring","loadScran","register","call","func","get_error_message","Uint8WasmArray","Uint8Array","buffer","WasmArray","Int8WasmArray","Int8Array","Uint16WasmArray","Uint16Array","Int16WasmArray","Int16Array","Uint32WasmArray","Uint32Array","Int32WasmArray","Int32Array","BigUint64WasmArray","BigUint64Array","BigInt64WasmArray","BigInt64Array","Float32WasmArray","Float32Array","Float64WasmArray","choices","stringToClass","name","createWasmArray","arrayClass","allocate"],"sourceRoot":""}