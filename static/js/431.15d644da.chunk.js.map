{"version":3,"file":"static/js/431.15d644da.chunk.js","mappings":"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","sources":["../node_modules/bakana/browser/abstract/worker_child.js","../node_modules/bakana/browser/steps/utils/general.js","../node_modules/bakana/browser/steps/utils/viz_child.js","../node_modules/scran.js/browser/findNearestNeighbors.js","../node_modules/scran.js/browser/gc.js","../node_modules/scran.js/browser/utils.js","../node_modules/scran.js/browser/wasm.js","../node_modules/wasmarrays.js/src/base.js","../node_modules/wasmarrays.js/src/derived.js","../node_modules/wasmarrays.js/src/create.js"],"sourcesContent":["export function registerCallback(callback) {\n    self.onmessage = callback;\n    return;\n}\n\nexport function sendMessage(message, transfer) {\n    self.postMessage(message, transfer);\n    return;\n}\n","import * as scran from \"scran.js\";\n\nexport function mimicGetter(value, copy) {\n    // Inheritance seems to be namespaced by module,\n    // so we can't use instanceof.\n    if (\"className\" in value.constructor && value.constructor.className.endsWith(\"WasmArray\")) { \n        if (copy == \"view\" || copy == \"hdf5\") {\n            return value.view();\n        } else if (copy) {\n            return value.slice();\n        } else {\n            return value.array();\n        }\n    } else {\n        if (copy === true) {\n            return value.slice();\n        } else if (copy == \"view\") {\n            // If the caller actually wanted a WasmArray, they would\n            // have generated a WasmArray during the unserialization.\n            throw new Error(\"'copy: \\\"view\\\"' not supported for mimics\");\n        } else {\n            // Includes copy = \"hdf5\", where a TypedArray or WasmArray can be used.\n            return value;\n        }\n    }\n}\n\nexport function freeCache(object) {\n    // Just an alias for simplicity.\n    scran.safeFree(object);\n    return;\n}\n\nfunction changedParametersIllegal(x, y, xskip, yskip) {\n    // Failing if this is a TypedArray or ArrayBuffer;\n    // we shouldn't be seeing these things here anyway.\n    if (!xskip) {\n        if (x instanceof ArrayBuffer || ArrayBuffer.isView(x)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n    if (!yskip) {\n        if (y instanceof ArrayBuffer || ArrayBuffer.isView(y)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n}\n\nexport function changedParameters(x, y) {\n    if (typeof x != typeof y) {\n        changedParametersIllegal(x, y, false, false);\n        return true;\n    } else if (typeof x != \"object\") {\n        return x != y;\n    }\n\n    //Handling nulls (which are objects).\n    let xnull = x === null;\n    let ynull = y === null;\n    if (xnull !== ynull) {\n        changedParametersIllegal(x, y, xnull, ynull);\n        return true;\n    } else if (xnull) {\n        return false;\n    }\n\n    // Handling arrays (which are also objects).\n    let xarr = x instanceof Array;\n    let yarr = y instanceof Array;\n    if (xarr != yarr) {\n        changedParametersIllegal(x, y, xarr, yarr);\n        return true;\n    } else if (xarr) {\n        if (x.length != y.length) {\n            return true;\n        }\n\n        for (var i = 0; i < x.length; i++) {\n            if (changedParameters(x[i], y[i])) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    changedParametersIllegal(x, y, false, false);\n    \n    // Now actually handling objects. We don't \n    // worry about the order of the keys here.\n    let xkeys = Object.keys(x);\n    let ykeys = Object.keys(y);\n    if (xkeys.length != ykeys.length) {\n        return true;\n    }\n\n    xkeys.sort();\n    ykeys.sort();\n    for (var i = 0; i < xkeys.length; i++) {\n        if (xkeys[i] != ykeys[i]) {\n            return true;\n        }\n    }\n\n    for (const k of xkeys) {\n        if (changedParameters(x[k], y[k])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function allocateCachedArray(size, type, cache, name = \"buffer\") {\n    var reallocate = true;\n    if (name in cache) {\n        var candidate = cache[name];\n\n        // Views also trigger reallocation, because it is assumed that the\n        // caller of this function does not own the view, but downstream\n        // uses of the array will involve writing to it.\n        if (candidate.size != size || candidate.constructor.className != type || candidate.owner !== null) { \n            candidate.free();\n        } else {\n            reallocate = false;\n        }\n    }\n  \n    if (reallocate) {\n        switch (type) {\n            case \"Uint8Array\":\n                cache[name] = scran.createUint8WasmArray(size);\n                break;\n            case \"Int32Array\":\n                cache[name] = scran.createInt32WasmArray(size);\n                break;\n            case \"Float64Array\":\n                cache[name] = scran.createFloat64WasmArray(size);\n                break;\n            default:\n                // We only ever use one of the three above types in our \n                // internal data stores, so no need to go all-out here.\n                throw \"allocating '\" + type + \"' not yet supported\";\n        }\n    }\n\n    return cache[name];\n}\n\nexport function isObject(object) {\n    return typeof object === 'object' && Array.isArray(object) === false && ArrayBuffer.isView(object) === false;\n}\n\nexport function findValidUpstreamStates(states, msg) {\n    let to_use = [];\n    for (const [k, v] of Object.entries(states)) {\n        if (v.valid()) {\n            to_use.push(k);\n        }\n    }\n    if (to_use.length == 0) {\n        throw new Error(\"expected at least one valid upstream \" + msg + \" state\");\n    }\n    return to_use;\n}\n\nexport function checkIndices(indices, max) {\n    if (max !== null) {\n        for (const i of indices) {\n            if (i < 0 || i >= max) {\n                throw new Error(\"subset indices are out of range\");\n            }\n        }\n    }\n\n    for (var i = 1; i < indices.length; i++) {\n        if (indices[i] <= indices[i-1]) {\n            throw new Error(\"subset indices must be sorted and unique\");\n        }\n    }\n}\n","import * as scran from \"scran.js\";\n\nexport function chooseDelay(animate) {\n    if (animate) {\n        // TODO: using 75 for now\n        // in the future the user can choose a bar for speed on the UI\n        // options would be 1x, 2x, 3x\n        return 75;\n    } else {\n        return 1000000; // effectively no delay.\n    }\n};\n\nexport function recreateNeighbors(neighbors) {\n    var output = null;\n    var rbuf = null;\n    var ibuf = null;\n    var dbuf = null;\n  \n    try {\n        var num_obs = neighbors.num_obs;\n        var size = neighbors.size;\n\n        rbuf = scran.createInt32WasmArray(num_obs);\n        rbuf.set(neighbors.runs);\n        ibuf = scran.createInt32WasmArray(size);\n        ibuf.set(neighbors.indices);\n        dbuf = scran.createFloat64WasmArray(size);\n        dbuf.set(neighbors.distances);\n\n        output = scran.FindNearestNeighborsResults.unserialize(rbuf, ibuf, dbuf);\n\n    } finally {\n        if (rbuf !== null) {\n            rbuf.free();\n        }\n        if (ibuf !== null) {\n            ibuf.free();\n        }\n        if (dbuf !== null) {\n            dbuf.free();\n        }\n    }\n\n    return output;\n};\n","import * as utils from \"./utils.js\";\nimport * as gc from \"./gc.js\";\nimport { RunPCAResults } from \"./runPCA.js\";\n\n/** \n * Wrapper for the neighbor search index on the Wasm heap, typically produced by {@linkcode buildNeighborSearchIndex}.\n * @hideconstructor\n */\nexport class BuildNeighborSearchIndexResults {\n    #id;\n    #index; \n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#index = raw;\n        return;\n    }\n\n    /**\n     * @return {number} Number of cells in the index.\n     */\n    numberOfCells() {\n        return this.#index.num_obs();\n    }\n\n    /**\n     * @return {number} Number of dimensions in the index.\n     */\n    numberOfDims() {\n        return this.#index.num_dim();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#index !== null) {\n            gc.release(this.#id);\n            this.#index = null;\n        }\n        return;\n    }\n\n    // Internal only, not documented.\n    get index() {\n        return this.#index;\n    }\n}\n\n/**\n * Build the nearest neighbor search index.\n *\n * @param {(RunPCAResults|Float64WasmArray|Array|TypedArray)} x - Numeric coordinates of each cell in the dataset.\n * For array inputs, this is expected to be in column-major format where the rows are the variables and the columns are the cells.\n * For a {@linkplain RunPCAResults} input, we extract the principal components.\n * @param {object} [options] - Optional parameters.\n * @param {?number} [options.numberOfDims=null] - Number of variables/dimensions per cell.\n * Only used (and required) for array-like `x`.\n * @param {?number} [options.numberOfCells=null] - Number of cells.\n * Only used (and required) for array-like `x`.\n * @param {boolean} [options.approximate=true] - Whether to build an index for an approximate neighbor search.\n *\n * @return {BuildNeighborSearchIndexResults} Index object to use for neighbor searches.\n */\nexport function buildNeighborSearchIndex(x, { numberOfDims = null, numberOfCells = null, approximate = true } = {}) {\n    var buffer;\n    var output;\n\n    try {\n        let pptr;\n\n        if (x instanceof RunPCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            let pcs = x.principalComponents({ copy: false });\n            pptr = pcs.byteOffset;\n\n        } else {\n            if (numberOfDims === null || numberOfCells === null) {\n                throw new Error(\"'numberOfDims' and 'numberOfCells' must be specified when 'x' is an Array\");\n            }\n\n            buffer = utils.wasmifyArray(x, \"Float64WasmArray\");\n            if (buffer.length != numberOfDims * numberOfCells) {\n                throw new Error(\"length of 'x' must be the product of 'numberOfDims' and 'numberOfCells'\");\n            }\n\n            pptr = buffer.offset;\n        }\n\n        output = gc.call(\n            module => module.build_neighbor_index(pptr, numberOfDims, numberOfCells, approximate),\n            BuildNeighborSearchIndexResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(buffer);\n    }\n\n    return output;\n}\n\n/** \n * Wrapper for the neighbor search results on the Wasm heap, typically produced by {@linkcode findNearestNeighbors}.\n * @hideconstructor\n */\nexport class FindNearestNeighborsResults {\n    #id;\n    #results;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#results = raw;\n        return;\n    }\n\n    /**\n     * @return {number} The total number of neighbors across all cells.\n     * This is usually the product of the number of neighbors and the number of cells.\n     */\n    size() {\n        return this.#results.size();\n    }\n\n    /**\n     * @return {number} The number of cells used in the search.\n     */\n    numberOfCells() {\n        return this.#results.num_obs();\n    }\n\n    // Internal use only, not documented.\n    get results() {\n        return this.#results;\n    }\n\n    /**\n     * @param {object} [options] - Optional parameters.\n     * @param {?Int32WasmArray} [options.runs=null] - A Wasm-allocated array of length equal to `numberOfCells()`,\n     * to be used to store the number of neighbors per cell.\n     * @param {?Int32WasmArray} [options.indices=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the indices of the neighbors of each cell.\n     * @param {?Float64WasmArray} [options.distances=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the distances to the neighbors of each cell.\n     *\n     * @return {object} \n     * An object is returned with the `runs`, `indices` and `distances` keys, each with an appropriate TypedArray as the value.\n     *\n     * If all of the arguments are non-`null`, the TypedArrays in the returned object are views on the corresponding input WasmArrays.\n     * Note that these views may be invalidated on the next allocation on the Wasm heap.\n     *\n     * If only some of the arguments are non-`null`, an error is raised.\n     */\n    serialize({ runs = null, indices = null, distances = null } = {}) {\n        var copy = (runs === null) + (indices === null) + (distances === null);\n        if (copy != 3 && copy != 0) {\n            throw new Error(\"either all or none of 'runs', 'indices' and 'distances' can be 'null'\");\n        }\n\n        var output;\n\n        if (copy === 3) {\n            var run_data;\n            var ind_data;\n            var dist_data;\n            \n            try {\n                run_data = utils.createInt32WasmArray(this.numberOfCells());\n                let s = this.size();\n                ind_data = utils.createInt32WasmArray(s);\n                dist_data = utils.createFloat64WasmArray(s);\n                this.#results.serialize(run_data.offset, ind_data.offset, dist_data.offset);\n\n                output = { \n                    \"runs\": run_data.slice(), \n                    \"indices\": ind_data.slice(), \n                    \"distances\": dist_data.slice() \n                };\n            } finally {\n                utils.free(run_data);\n                utils.free(ind_data);\n                utils.free(dist_data);\n            }\n\n        } else {\n            this.#results.serialize(runs.offset, indices.offset, distances.offset);\n            output = {\n                \"runs\": runs.array(),\n                \"indices\": indices.array(),\n                \"distances\": distances.array()\n            };\n        }\n\n        return output;\n    }\n\n    /**\n     * @param {Int32WasmArray|Array|TypedArray} runs An array of length equal to `numberOfCells()`,\n     * containing the number of neighbors per cell.\n     * @param {Int32WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the indices of the neighbors of each cell.\n     * @param {Float64WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the distances to the neighbors of each cell.\n     *\n     * @return {FindNearestNeighborsResults} Object containing the unserialized search results.\n     */\n    static unserialize(runs, indices, distances) {\n        var output;\n        var run_data;\n        var ind_data;\n        var dist_data;\n\n        try {\n            run_data = utils.wasmifyArray(runs, \"Int32WasmArray\");\n            ind_data = utils.wasmifyArray(indices, \"Int32WasmArray\");\n            dist_data = utils.wasmifyArray(distances, \"Float64WasmArray\");\n            output = gc.call(\n                module => new module.NeighborResults(runs.length, run_data.offset, ind_data.offset, dist_data.offset),\n                FindNearestNeighborsResults\n            );\n\n        } catch (e) {\n            utils.free(output);\n            throw e;\n\n        } finally { \n            utils.free(run_data);\n            utils.free(ind_data);\n            utils.free(dist_data);\n        }\n\n        return output;\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Find the nearest neighbors for each cell.\n *\n * @param {NeighborSearchIndex} x The neighbor search index built by {@linkcode buildNeighborSearchIndex}.\n * @param {number} k Number of neighbors to find.\n * @param {object} [options] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {FindNearestNeighborsResults} Object containing the search results.\n */\nexport function findNearestNeighbors(x, k, { numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n    return gc.call(\n        module => module.find_nearest_neighbors(x.index, k, nthreads),\n        FindNearestNeighborsResults\n    );\n}\n","import * as wasm from \"./wasm.js\";\n\nconst memories = {};\nlet counter = 0;\n\nexport function release(id) {\n    if (id in memories) {\n        memories[id].delete();\n        delete memories[id];\n    }\n    return;\n}\n\nconst finalizer = new FinalizationRegistry(release);\n\nexport function call(fun, constructor, ...other) {\n    let raw = wasm.call(fun);\n\n    let id = counter;\n    memories[id] = raw; \n    counter++;\n    \n    let output;\n    try {\n        output = new constructor(id, raw, ...other);\n    } catch (e) {\n        release(id);\n        throw e;\n    }\n\n    finalizer.register(output, id);\n    return output;\n}\n\n\n","import { buffer, wasmArraySpace, maximumThreads } from \"./wasm.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Helper function to create a Uint8WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Uint8WasmArray} Uint8WasmArray on the **scran.js** Wasm heap.\n */\nexport function createUint8WasmArray(length) {\n    return wa.createUint8WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Int32WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Int32WasmArray} Int32WasmArray on the **scran.js** Wasm heap.\n */\nexport function createInt32WasmArray(length) {\n    return wa.createInt32WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a BigUint64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {BigUint64WasmArray} BigUint64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createBigUint64WasmArray (length) {\n    return wa.createBigUint64WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Float64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Float64WasmArray} Float64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createFloat64WasmArray(length) {\n    return wa.createFloat64WasmArray(wasmArraySpace(), length);\n}\n\nexport function wasmifyArray(x, expected) {\n    if (x instanceof wa.WasmArray) {\n        if (expected !== null && expected != x.constructor.className) {\n            throw new Error(\"expected '\" + expected + \"', got '\" + x.constructor.className + \"'\");\n        }\n\n        if (x.space === wasmArraySpace()) {\n            // Creating a view. This ensures that callers can always call\n            // free() on the output of this function without worrying about\n            // whether they are breaking something else that was using 'x'.\n            if (x.owner === null) {\n                return x.view();\n            } else {\n                return x; // it's already a view, so we just pass it along.\n            }\n        } else {\n            // If it's a different space, then we have to make a copy.\n            return x.clone(wasmArraySpace());\n        }\n    }\n\n    let y = null;\n    if (expected !== null) {\n        y = wa.convertToWasmArray(wasmArraySpace(), x, wa.stringToClass(expected));\n    } else {\n        y = wa.convertToWasmArray(wasmArraySpace(), x);\n    }\n\n    return y;\n}\n\nexport function chooseNumberOfThreads(threads) {\n    if (threads == null) {\n        return maximumThreads();\n    } else {\n        return threads;\n    }\n}\n\n/**\n * Try to free a **scran.js** object's memory (typically involving some memory allocated on the Wasm heap) by calling its `free` method.\n *\n * @param {?object} x - Instance of a **scran.js** or **wasmarrays.js** class to be freed.\n * May also be `null` or undefined.\n * \n * @return The output of `x.free()` - unless `x` is undefined or `null`, in which case nothing is performed.\n */\nexport function free(x) {\n    if (typeof x == \"undefined\" || x == null) {\n        return;\n    }\n    return x.free();\n}\n\n// Exported for back-compatibility, deprecated as of 0.3.0.\nexport function safeFree(x) {\n    return free(x);\n}\n\nexport function extractXY(ncells, coordinates) {\n    let x = new Float64Array(ncells);\n    let y = new Float64Array(ncells);\n\n    for (var i = 0; i < ncells; i++) {\n        x[i] = coordinates[2 * i];\n        y[i] = coordinates[2 * i + 1];\n    }\n\n    return { \"x\": x, \"y\": y };\n}\n\n/**\n * Possibly copy an array out of the Wasm heap, avoiding potential invalidation at the cost of some efficiency.\n *\n * @param {TypedArray} x - Array of data, possibly on the **scran.js** Wasm heap.\n * @param {(string|boolean)} copy - Copying mode to use.\n *\n * @return {TypedArray|WasmArray} The return value depends on the value of `copy`:\n * - If `copy = true`, a TypedArray copy of `x` is created with `x.slice()` and returned.\n *   This is a good default to avoid invalidation of TypedArray views on the heap upon reallocation, by creating a Javascript-owned copy for downstream use.\n * - If `copy = false`, `x` is returned directly.\n *   This avoids making any copy but runs the risk of invalidation when the Wasm heap is resized;\n *   it should only be used when no further Wasm allocations are performed within the lifetime of `x`.\n * - If `copy = \"view\"`, a WasmArray view is created from `x` and returned.\n *   This avoids any copy and is robust to invalidation but requires an extra `WasmArray.array()` call to create a TypedArray.\n */\nexport function possibleCopy(x, copy) {\n    if (copy === \"view\") {\n        if (x.buffer !== buffer()) {\n            throw new Error(\"cannot use copy = \\\"view\\\" for non-Wasm TypedArrays\");\n        }\n\n        let view_class = x.constructor.name.replace(\"Array\", \"WasmArray\");\n\n        // This function should only be used for objects generated in the\n        // buffer owned by scran.js, so we can assume that x's space is the\n        // same as that of the wasmArraySpace().\n        return wa.createWasmArrayView(wasmArraySpace(), x.length, x.byteOffset, wa.stringToClass(view_class));\n\n    } else if (copy) {\n        return x.slice();\n\n    } else {\n        return x;\n    }\n}\n\nexport function matchOptions(name, value, choices) {\n    if (choices.indexOf(value) == -1) {\n        throw new Error(\"'\" + name + \"=' should be one of '\" + choices.join(\"', '\") + \"'\");\n    }\n}\n","import loadScran from \"./wasm/scran.js\";\nimport { register } from \"wasmarrays.js\";\nimport * as afile from \"./abstract/file.js\";\n\nconst cache = {};\n\n/**\n * @param {object} [options] - Optional parameters.\n * @param {number} [options.numberOfThreads=4] - Number of threads to use for calculations.\n * This will spin up the requested number of Web Workers during module initialization.\n * @param {boolean} [options.localFile=false] - Whether or not to look for the Wasm and worker scripts locally.\n * This should only be `true` when using old versions of Node.js where file URLs are not supported, \n * and is ignored completely outside of Node.js contexts.\n *\n * @return {boolean}\n * The Wasm bindings are initialized and `true` is returned.\n * If the bindings were already initialized (e.g., by a previous call), nothing is done and `false` is returned.\n */\nexport async function initialize({ numberOfThreads = 4, localFile = false } = {}) {\n    if (\"module\" in cache) {\n        return false;\n    }\n\n    let options = {\n        scran_custom_nthreads: numberOfThreads\n    };\n\n    if (localFile) {                                                                /** NODE ONLY **/  \n        options.locateFile = (x) => import.meta.url.substring(7) + \"/../wasm/\" + x; /** NODE ONLY **/\n    }                                                                               /** NODE ONLY **/\n\n    cache.module = await loadScran(options);\n    cache.space = register(cache.module);\n\n    return true;\n}\n\n/**\n * Maximum number of threads available for computation.\n * This depends on the value specified during module initialization in {@linkcode initialize}. \n *\n * @return {number} Maximum number of available threads.\n */\nexport function maximumThreads() {\n    return cache.module.scran_custom_nthreads;\n}\n\nexport function call(func) {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n\n    var output;\n    try {\n        output = func(cache.module);    \n    } catch (e) {\n        if (typeof e == \"number\") {\n            throw new Error(cache.module.get_error_message(e));\n        } else {\n            throw e;\n        }\n    }\n    return output;\n}\n\nexport function buffer() {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n    return cache.module.wasmMemory.buffer;\n}\n\n/**\n * @return {number} Integer containing the **wasmarrays.js** identifier for **scran.js**'s memory space.\n * This can be used with `createWasmArray()` and related functions from **wasmarrays.js**.\n */\nexport function wasmArraySpace() {\n    return cache.space;\n}\n\n/**\n * @return All worker threads are terminated and the module is deleted from the cache.\n * This is useful for cleaning up at the end of the analysis,\n * otherwise the workers will be shut done ungracefully on program exit.\n */\nexport function terminate() {\n    cache.module.PThread.terminateAllThreads();\n    delete cache.module;\n    return;\n}\n\n/**\n * @return {number} The current size of the Wasm heap, typically used for diagnostic reporting.\n */\nexport function heapSize() {\n    return buffer().byteLength;\n}\n","import { allocate, release, buffer } from \"./globals.js\";\n\n/** \n * Wrapper around an array allocated on the Wasm heap.\n * This handles the memory management so that users don't have to manually free allocations \n * (unless they want to, e.g., because they don't trust the timeliness of the Javascript engine's garbage collector).\n */\nexport class WasmArray {\n    #space;\n    #id;\n    #length;\n    #offset;\n    #owner;\n\n    /**\n     * @param {number} space - Identifier for the Wasm memory space, as returned by {@linkcode register}.\n     * @param {number} id - Identifier for this array in the specified space.\n     * @param {number} length - Length of the array, in terms of the number of elements.\n     * @param {number} offset - Offset on the Wasm heap.\n     * @param {(WasmArray|object)} owner - Owner of the memory, see the {@linkcode WasmArray#owner owner} property for more details about acceptable values.\n     *\n     * @desc Users should not call this constructor directly; use the {@linkcode createWasmArray} function instead.\n     */\n    constructor(space, id, length, offset, owner) {\n        this.#space = space;\n        this.#id = id;\n        this.#length = length;\n        this.#offset = offset;\n        this.#owner = owner;\n    }\n\n    /**\n     * @member {number}\n     * @desc Identifier for the Wasm memory space.\n     */\n    get space() {\n        return this.#space;\n    }\n\n    /**\n     * @member {number}\n     * @desc Identifier for this array in the specified space.\n     * This may not have any meaningful value if this WasmArray instance is a view, see the {@linkcode WasmArray#owner owner} property for details.\n     */\n    get id() {\n        return this.#id;\n    }\n\n    /**\n     * @member {number}\n     * @desc Offset on the Wasm heap, in terms of the number of bytes.\n     */\n    get offset() {\n        return this.#offset;\n    }\n\n    /**\n     * @member {number}\n     * @desc Same as {@linkcode WasmArray#offset offset}, provided for consistency with the TypedArray interface.\n     */\n    get byteOffset() {\n        return this.#offset;\n    }\n\n    /**\n     * @member {ArrayBuffer}\n     * @desc The ArrayBuffer used to implement the Wasm heap, on which the current array is allocated.\n     */\n    get buffer() {\n        return buffer(this.#space);\n    }\n\n    /**\n     * @member {number}\n     * @desc Length of the heap allocation, in terms of the number of bytes.\n     */\n    get byteLength() {\n        return this.length * this.constructor.valueSize;\n    }\n\n    /**\n     * @member {number}\n     * @desc Length of the array, in terms of the number of elements.\n     */\n    get length() {\n        return this.#length;\n    }\n\n    /**\n     * @member {(object|WasmArray)}\n     *\n     * @desc\n     * This property contains information about the owner of the allocation on the Wasm heap.\n     * The most common value of this property will be `null`, indicating that the current WasmArray instance is the owner of the allocation on the Wasm heap.\n     * This is the only setting where {@linkcode WasmArray#free free} has any effect.\n     *\n     * Any non-`null` value indicates that the current instance is just a view into an allocation owned by another entity.\n     * If the value is a reference to another WasmArray, then the returned object is the actual owner of the allocation.\n     *\n     * In some cases, `owner` may be an empty (non-`null`) object.\n     * This indicates that the allocation is owned by some unknown entity, e.g., a view directly returned by Emscripten's bindings without involving a WasmArray instance.\n     */\n    get owner() {\n        return this.#owner;\n    }\n\n    /**\n     * Fill the array with a constant number.\n     *\n     * @param {number} x - Number to use to fill the array.\n     * @param {number} [start] Position on the array to start filling.\n     * Defaults to the start of the array.\n     * @param {number} [end] Position on the array to stop filling.\n     * Defaults to the end of the array.\n     * Only used if `start` is specified.\n     *\n     * @return The array (or its specified subinterval) is filled with values from `x`.\n     */\n    fill(x, start, end) {\n        let y = this.array();\n        y.fill(...arguments);\n        return y;\n    }\n\n    /**\n     * Set the array elements to the contents of an existing array.\n     *\n     * @param {(Array|TypedArray)} x - Source array containing the values to fill the current array.\n     * @param {number} [offset] - Position on this array to start setting to `x`.\n     * Defaults to the start of the array.\n     *\n     * @return Entries of this array (starting from `offset`, if specified) are set to `x`.\n     */\n    set(x, offset) {\n        this.array().set(...arguments);\n        return;\n    }\n\n    /**\n     * Create a TypedArray slice of the data in the allocated array.\n     *\n     * @param {number} [start] - Position on this array to start slicing.\n     * Defaults to the start of the array.\n     * @param {number} [end] - Position on the array to end slicing.\n     * Defaults to the end of the array.\n     * Only used if `start` is specified.\n     *\n     * @return A TypedArray containing the specified subarray.\n     * This is not a view on the Wasm heap and thus can be safely used after any further Wasm allocations.\n     */\n    slice(start, end) {\n        return this.array().slice(...arguments);\n    }\n\n    /**\n     * Create a WasmArray clone of this object.\n     *\n     * @param {number} space - Identifier for the Wasm memory space.\n     * If not specified, we use the memory space of this object.\n     *\n     * @return A new WasmArray of the same type and filled with the same contents.\n     * This refers to a separate allocation on the requested space.\n     */\n    clone(space) {\n        if (typeof space === \"undefined\") {\n            space = this.#space;\n        }\n        let output = allocate(space, this.#length, this.constructor);\n        output.set(this.array());\n        return output;\n    }\n\n    /**\n     * Create a WasmArray \"view\" of the data in this object.\n     *\n     * @param {number} [start] - Position on this array to start the view.\n     * Defaults to the start of the array.\n     * @param {number} [end] - Position on the array to end the view.\n     * Defaults to the end of the array.\n     * Only used if `start` is specified.\n     *\n     * @return A WasmArray containing a view on the specified subarray.\n     *\n     * The returned object does not own the memory on the Wasm heap, so {@linkcode WasmArray#free free} will not have any effect.\n     * It does, however, hold a reference to its parent object, i.e., the current WasmArray instance on which `view` was called.\n     * This reference ensures that the parent is not prematurely garbage collected (thus invalidating the view when the Wasm allocation is freed).\n     * Of course, all views will be invalidated if the parent's {@linkcode WasmArray#free free} method is invoked manually.\n     */\n    view(start, end) {\n        if (typeof start === \"undefined\") {\n            start = 0;\n        }\n        if (typeof end === \"undefined\") {\n            end = this.#length;\n        }\n\n        let new_length = end - start;\n        let original_parent = this.#owner;\n        if (original_parent === null) {\n            original_parent = this;\n        }\n\n        let adjust = start * this.constructor.valueSize;\n        return new this.constructor(this.#space, -1, new_length, this.#offset + adjust, original_parent);\n    }\n\n    /**\n     * Free the allocated Wasm memory if this object owns that memory.\n     *\n     * @return If this object is the owner, memory is freed and this allocation is invalidated.\n     *\n     * If this object is a view, this function is a no-op.\n     * If this function was previously called, further calls will have no effect.\n     */\n    free() {\n        if (this.#owner === null && this.#offset !== null) {\n            release(this.#space, this.#id);\n            this.#offset = null;\n        }\n    }\n\n    /**\n     * Iterate across the values of the WasmArray.\n     * Note that this relies on a TypedArray view and may not be valid if any Wasm heap allocations occur during iteration.\n     *\n     * @return An array iterator function.\n     */\n    [Symbol.iterator]() {\n        return this.values();\n    }\n\n    /**\n     * Iterate across the values of the WasmArray.\n     * Note that this relies on a TypedArray view and may not be valid if any Wasm heap allocations occur during iteration.\n     *\n     * @return An array iterator function.\n     */\n    values() {\n        return this.array().values();\n    }\n\n    /**\n     * Iterate across the keys (i.e., indices) of the WasmArray.\n     * Note that this relies on a TypedArray view and may not be valid if any Wasm heap allocations occur during iteration.\n     *\n     * @return An array iterator function.\n     */\n    keys() {\n        return this.array().keys();\n    }\n\n    /**\n     * Obtain the value at the specified index.\n     *\n     * @param {number} index - Position of the array.\n     * This may be negative to indicate indexing from the end of the array.\n     *\n     * @return The value of the array at the requested index.\n     */\n    at(index) {\n        return this.array().at(index);\n    }\n\n    /**\n     * Apply a callback function to each element in the array, equivalent to the counterpart for Arrays.\n     * Note that this relies on a TypedArray view and may not be valid if any Wasm heap allocations occur in the callback.\n     *\n     * @param {function} callbackFn - Callback function, see the documentation for [`TypedArray.prototype.forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/forEach).\n     * @param {object} [thisArg] - Value to use as `this` when executing `callbackFn`.\n     *\n     * @return `undefined`.\n     */\n    forEach(callbackFn, thisArg) {\n        this.array().forEach(...arguments);\n        return;\n    }\n\n    /**\n     * Create a new TypedArray containing all elements in the WasmArray that pass the filter.\n     * Note that this relies on a TypedArray view and may not be valid if any Wasm heap allocations occur in the filter.\n     *\n     * @param {function} callbackFn - Callback function, see the documentation for [`TypedArray.prototype.filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/filter).\n     * @param {object} [thisArg] - Value to use as `this` when executing `callbackFn`.\n     *\n     * @return A TypedArray that contains only the elements passing the filter.\n     */\n    filter(callbackFn, thisArg) {\n        return this.array().filter(...arguments);\n    }\n\n    /**\n     * Create a new TypedArray from evaluating the callback function on each element of the WasmArray.\n     * Note that this relies on a TypedArray view and may not be valid if any Wasm heap allocations occur in the callback.\n     *\n     * @param {function} callbackFn - Callback function, see the documentation for [`TypedArray.prototype.map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/map).\n     * @param {object} [thisArg] - Value to use as `this` when executing `callbackFn`.\n     *\n     * @return A TypedArray containing the result of `callbackFn` on each element.\n     */\n    map(callbackFn, thisArg) { \n        return this.array().map(...arguments);\n    }\n\n    /**\n     * Create a TypedArray view for a range of the current WasmArray from `[begin, end)`.\n     *\n     * @param {number} [begin] - Index of the starting element, defaults to 0.\n     * @param {number} [end] - Index of the final element plus 1, defaults to the length of the current array.\n     *\n     * @return A TypedArray view of the requested subarray.\n     */\n    subarray(begin, end) {\n        return this.array().subarray(begin, end);\n    }\n\n    /**\n     * Test whether every element in the WasmArray passes the test implemented by the callback function.\n     * Note that this relies on a TypedArray view and may not be valid if any Wasm heap allocations occur in the callback.\n     *\n     * @param {function} callbackFn - Callback function, see the documentation for [`TypedArray.prototype.every`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/every).\n     * @param {object} [thisArg] - Value to use as `this` when executing `callbackFn`.\n     *\n     * @return Boolean indicating whether the callback is truthy for each element in the WasmArray.\n     */\n    every(callbackFn, thisArg) {\n        return this.array().every(...arguments);\n    }\n\n    /**\n     * Test whether any element in the WasmArray passes the test implemented by the callback function.\n     * Note that this relies on a TypedArray view and may not be valid if any Wasm heap allocations occur in the callback.\n     *\n     * @param {function} callbackFn - Callback function, see the documentation for [`TypedArray.prototype.some`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/some).\n     * @param {object} [thisArg] - Value to use as `this` when executing `callbackFn`.\n     *\n     * @return Boolean indicating whether the callback is truthy for any element in the WasmArray.\n     */\n    some(callbackFn, thisArg) {\n        return this.array().some(...arguments);\n    }\n\n    /**\n     * Reduce the WasmArray into a single value by repeatedly applying a callback function from left to right.\n     * Note that this relies on a TypedArray view and may not be valid if any Wasm heap allocations occur in the callback.\n     *\n     * @param {function} callbackFn - Callback function, see the documentation for [`TypedArray.prototype.reduce`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/reduce).\n     * @param {object} [initialValue] - Initial value of the accumulator.\n     *\n     * @return Result of the callback function.\n     */\n    reduce(callbackFn, initialValue) {\n        return this.array().reduce(...arguments);\n    }\n\n    /**\n     * Reduce the WasmArray into a single value by repeatedly applying a callback function from right to left.\n     * Note that this relies on a TypedArray view and may not be valid if any Wasm heap allocations occur in the callback.\n     *\n     * @param {function} callbackFn - Callback function, see the documentation for [`TypedArray.prototype.reduceRight`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/reduceRight).\n     * @param {object} [initialValue] - Initial value of the accumulator.\n     *\n     * @return Result of the callback function.\n     */\n    reduceRight(callbackFn, initialValue) {\n        return this.array().reduceRight(...arguments);\n    }\n\n    /**\n     * Sort the contents of the WasmArray.\n     * Note that this relies on a TypedArray view and may not be valid if any Wasm heap allocations occur in the comparison function.\n     *\n     * @param {function} compareFn - Function to define the sort order, see the documentation for [`TypedArray.prototype.sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/sort).\n     *\n     * @return The contents of the WasmArray are sorted and a TypedArray view is returned.\n     */\n    sort(compareFn) {\n        return this.array().sort(compareFn);\n    }\n    \n    /**\n     * Reverse the contents of the WasmArray.\n     *\n     * @return The contents of the WasmArray are reversed and a TypedArray view is returned.\n     */\n    reverse() {\n        return this.array().reverse();\n    }\n}\n","import { buffer } from \"./globals.js\";\nimport { WasmArray } from \"./base.js\";\n\n/** \n * Wrapper around an unsigned 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint8WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Uint8WasmArray extends WasmArray {\n    /**\n     * @return A Uint8Array view of the allocated memory.\n     */\n    array() {\n        return new Uint8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Uint8WasmArray\";\n    // We're returning the name explicitly here instead of relying\n    // on the constructor.name trick, as the name of the class can\n    // change during minification.\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around a signed 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt8WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Int8WasmArray extends WasmArray {\n    /**\n     * @return An Int8Array view of the allocated memory.\n     */\n    array() {\n        return new Int8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Int8WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around an unsigned 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint16WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Uint16WasmArray extends WasmArray {\n    /**\n     * @return A Uint16Array view of the allocated memory.\n     */\n    array() {\n        return new Uint16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Uint16WasmArray\";\n\n    /**\n     * Size of the each data value, in bytes.\n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage a signed 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt16WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Int16WasmArray extends WasmArray {\n    /**\n     * @return An `Int16Array` view of the allocated memory.\n     */\n    array() {\n        return new Int16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Int16WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage an unsigned 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint32WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Uint32WasmArray extends WasmArray {\n    /**\n     * @return A Uint32Array view of the allocated memory.\n     */\n    array() {\n        return new Uint32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Uint32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a signed 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt32WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Int32WasmArray extends WasmArray {\n    /**\n     * @return An Int32Array view of the allocated memory.\n     */\n    array() {\n        return new Int32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     */\n    static className = \"Int32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage an unsigned 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigUint64WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class BigUint64WasmArray extends WasmArray {\n    /**\n     * @return A BigUint64Array view of the allocated memory.\n     */\n    array() {\n        return new BigUint64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"BigUint64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a signed 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigInt64WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class BigInt64WasmArray extends WasmArray {\n    /**\n     * @return An BigInt64Array view of the allocated memory.\n     */\n    array() {\n        return new BigInt64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     */\n    static className = \"BigInt64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a 32-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat32WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Float32WasmArray extends WasmArray {\n    /**\n     * @return A Float32Array view of the allocated memory.\n     */\n    array() {\n        return new Float32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     */\n    static className = \"Float32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a 64-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat64WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Float64WasmArray extends WasmArray {\n    /**\n     * @return A Float64Array view of the allocated memory.\n     */\n    array() {\n        return new Float64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     */\n    static className = \"Float64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 8;\n}\n\nconst choices = {\n    \"Uint8WasmArray\": Uint8WasmArray,\n    \"Int8WasmArray\": Int8WasmArray,\n    \"Uint16WasmArray\": Uint16WasmArray,\n    \"Int16WasmArray\": Int16WasmArray,\n    \"Uint32WasmArray\": Uint32WasmArray,\n    \"Int32WasmArray\": Int32WasmArray,\n    \"BigUint64WasmArray\": BigUint64WasmArray,\n    \"BigInt64WasmArray\": BigInt64WasmArray,\n    \"Float32WasmArray\": Float32WasmArray,\n    \"Float64WasmArray\": Float64WasmArray\n};\n\n/**\n * Retrieve class from its name.\n *\n * @param {string} name - Name of the {@linkplain WasmArray} class.\n *\n * @return Class object corresponding to `name`.\n */\nexport function stringToClass(name) {\n    if (!(name in choices)){ \n        throw new Error(\"unknown WasmArray class '\" + name + \"'\");\n    }\n    return choices[name];\n}\n","import { allocate } from \"./globals.js\";\nimport { \n    Int8WasmArray, Uint8WasmArray,\n    Int16WasmArray, Uint16WasmArray,\n    Int32WasmArray, Uint32WasmArray,\n    BigInt64WasmArray, BigUint64WasmArray,\n    Float32WasmArray, Float64WasmArray\n} from \"./derived.js\";\n\n/**\n * Create a {@linkplain WasmArray} of the specified subclass.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * @param {class} arrayClass - Desired subclass of the {@linkplain WasmArray}.\n * \n * @return Instance of a {@linkplain WasmArray} subclass.\n */\nexport function createWasmArray(space, length, arrayClass) {\n    return allocate(space, length, arrayClass);\n}\n\n/**\n * Create a {@linkplain Uint8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Uint8WasmArray}.\n */\nexport function createUint8WasmArray(space, length) { \n    return createWasmArray(space, length, Uint8WasmArray); \n}\n\n/**\n * Create a {@linkplain Int8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Int8WasmArray}.\n */\nexport function createInt8WasmArray(space, length) { \n    return createWasmArray(space, length, Int8WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Uint16WasmArray}.\n */\nexport function createUint16WasmArray(space, length) { \n    return createWasmArray(space, length, Uint16WasmArray); \n}\n\n/**\n * Create a {@linkplain Int16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Int16WasmArray}.\n */\nexport function createInt16WasmArray(space, length) { \n    return createWasmArray(space, length, Int16WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Uint32WasmArray}.\n */\nexport function createUint32WasmArray(space, length) { \n    return createWasmArray(space, length, Uint32WasmArray); \n}\n\n/**\n * Create a {@linkplain Int32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Int32WasmArray}.\n */\nexport function createInt32WasmArray(space, length) { \n    return createWasmArray(space, length, Int32WasmArray); \n}\n\n/**\n * Create a {@linkplain BigUint64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain BigUint64WasmArray}.\n */\nexport function createBigUint64WasmArray(space, length) { \n    return createWasmArray(space, length, BigUint64WasmArray); \n}\n\n/**\n * Create a {@linkplain BigInt64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain BigInt64WasmArray}.\n */\nexport function createBigInt64WasmArray(space, length) { \n    return createWasmArray(space, length, BigInt64WasmArray); \n}\n\n/**\n * Create a {@linkplain Float32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Float32WasmArray}.\n */\nexport function createFloat32WasmArray(space, length) { \n    return createWasmArray(space, length, Float32WasmArray); \n}\n\n/**\n * Create a {@linkplain Float64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Float64WasmArray}.\n */\nexport function createFloat64WasmArray(space, length) { \n    return createWasmArray(space, length, Float64WasmArray); \n}\n"],"names":["registerCallback","callback","self","onmessage","sendMessage","message","transfer","postMessage","freeCache","object","scran","changedParametersIllegal","x","y","xskip","yskip","ArrayBuffer","isView","Error","changedParameters","xnull","ynull","xarr","Array","yarr","length","i","xkeys","Object","keys","ykeys","sort","k","chooseDelay","animate","recreateNeighbors","neighbors","output","rbuf","ibuf","dbuf","num_obs","size","set","runs","indices","distances","free","BuildNeighborSearchIndexResults","id","raw","this","num_dim","gc","FindNearestNeighborsResults","run_data","ind_data","dist_data","copy","utils","numberOfCells","s","serialize","offset","slice","array","module","NeighborResults","e","findNearestNeighbors","numberOfThreads","nthreads","find_nearest_neighbors","index","memories","counter","release","delete","finalizer","FinalizationRegistry","call","fun","constructor","wasm","other","register","createInt32WasmArray","wa","wasmArraySpace","createFloat64WasmArray","wasmifyArray","expected","className","space","owner","view","clone","chooseNumberOfThreads","threads","maximumThreads","safeFree","extractXY","ncells","coordinates","Float64Array","cache","initialize","localFile","options","scran_custom_nthreads","locateFile","import","substring","loadScran","func","get_error_message","Symbol","iterator","WasmArray","buffer","valueSize","start","end","fill","arguments","allocate","new_length","original_parent","adjust","values","at","callbackFn","thisArg","forEach","filter","map","begin","subarray","every","some","initialValue","reduce","reduceRight","compareFn","reverse","Uint8WasmArray","Uint8Array","Int8WasmArray","Int8Array","Uint16WasmArray","Uint16Array","Int16WasmArray","Int16Array","Uint32WasmArray","Uint32Array","Int32WasmArray","Int32Array","BigUint64WasmArray","BigUint64Array","BigInt64WasmArray","BigInt64Array","Float32WasmArray","Float32Array","Float64WasmArray","choices","stringToClass","name","createWasmArray","arrayClass"],"sourceRoot":""}