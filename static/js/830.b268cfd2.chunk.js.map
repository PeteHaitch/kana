{"version":3,"file":"static/js/830.b268cfd2.chunk.js","mappings":"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","sources":["../node_modules/papaparse/papaparse.min.js","../node_modules/randomcolor/randomColor.js","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/classCheckPrivateStaticAccess.js","../node_modules/@babel/runtime/helpers/esm/classCheckPrivateStaticFieldDescriptor.js","../node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js","../node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js","../node_modules/@babel/runtime/helpers/esm/classStaticPrivateFieldSpecGet.js","../node_modules/@babel/runtime/helpers/esm/classStaticPrivateFieldSpecSet.js","../node_modules/@babel/runtime/helpers/esm/classStaticPrivateMethodGet.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/get.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/superPropBase.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/bakana-remotes/src/utils.js","../node_modules/bakana-remotes/src/ExperimentHub.js","../node_modules/artifactdb/src/packId.js","../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","../node_modules/artifactdb/src/HttpError.js","../node_modules/artifactdb/src/globalRequestHeaders.js","../node_modules/artifactdb/src/getFile.js","../node_modules/artifactdb/src/getFileMetadata.js","../node_modules/bakana-remotes/src/CollaboratorDB.js","../node_modules/bakana/browser/readers/10x.js","../node_modules/bakana/browser/readers/ArtifactDB-abstract.js","../node_modules/bakana/browser/readers/abstract/file.js","../node_modules/bakana/browser/readers/mtx.js","../node_modules/bakana/browser/readers/utils/abstract/stream.js","../node_modules/bakana/browser/readers/utils/extract.js","../node_modules/bakana/browser/readers/utils/features.js","../node_modules/bakana/browser/steps/abstract/worker_parent.js","../node_modules/bakana/browser/steps/adt_normalization.js","../node_modules/bakana/browser/steps/adt_pca.js","../node_modules/bakana/browser/steps/adt_quality_control.js","../node_modules/bakana/browser/steps/batch_correction.js","../node_modules/bakana/browser/steps/cell_filtering.js","../node_modules/bakana/browser/steps/cell_labelling.js","../node_modules/bakana/browser/steps/choose_clustering.js","../node_modules/bakana/browser/steps/combine_embeddings.js","../node_modules/bakana/browser/steps/crispr_normalization.js","../node_modules/bakana/browser/steps/crispr_pca.js","../node_modules/bakana/browser/steps/crispr_quality_control.js","../node_modules/bakana/browser/steps/feature_selection.js","../node_modules/bakana/browser/steps/kmeans_cluster.js","../node_modules/bakana/browser/steps/marker_detection.js","../node_modules/bakana/browser/steps/neighbor_index.js","../node_modules/bakana/browser/steps/rna_normalization.js","../node_modules/bakana/browser/steps/rna_pca.js","../node_modules/bakana/browser/steps/rna_quality_control.js","../node_modules/bakana/browser/steps/snn_graph_cluster.js","../node_modules/bakana/browser/steps/tsne.js","../node_modules/bakana/browser/steps/umap.js","../node_modules/bakana/browser/steps/utils/abstract/workers_parent.js","../node_modules/bakana/browser/steps/utils/general.js","../node_modules/bakana/browser/steps/utils/markers.js","../node_modules/bakana/browser/steps/utils/normalization.js","../node_modules/bioconductor/src/AllGenerics.js","../node_modules/bioconductor/src/Annotated.js","../node_modules/bioconductor/src/DataFrame.js","../node_modules/bioconductor/src/DenseMatrix.js","../node_modules/bioconductor/src/GRanges.js","../node_modules/bioconductor/src/GroupedGRanges.js","../node_modules/bioconductor/src/IRanges.js","../node_modules/bioconductor/src/InternalList.js","../node_modules/bioconductor/src/RangedSummarizedExperiment.js","../node_modules/bioconductor/src/SingleCellExperiment.js","../node_modules/bioconductor/src/SummarizedExperiment.js","../node_modules/bioconductor/src/Vector.js","../node_modules/bioconductor/src/clone-utils.js","../node_modules/bioconductor/src/miscellaneous.js","../node_modules/bioconductor/src/overlap-utils.js","../node_modules/bioconductor/src/utils.js","../node_modules/gesel/src/fetchAllCollections.js","../node_modules/gesel/src/fetchAllGenes.js","../node_modules/gesel/src/fetchAllSets.js","../node_modules/gesel/src/fetchGenesForAllSets.js","../node_modules/gesel/src/fetchGenesForSet.js","../node_modules/gesel/src/fetchSetsForAllGenes.js","../node_modules/gesel/src/fetchSetsForGene.js","../node_modules/gesel/src/fetchSingleCollection.js","../node_modules/gesel/src/fetchSingleSet.js","../node_modules/gesel/src/mapGenesByIdentifier.js","../node_modules/gesel/src/reindexGenesForAllSets.js","../node_modules/gesel/src/reindexSetsForAllGenes.js","../node_modules/gesel/src/searchSetText.js","../node_modules/scran.js/browser/MultiMatrix.js","../node_modules/scran.js/browser/ScranMatrix.js","../node_modules/scran.js/browser/abstract/realize.js","../node_modules/scran.js/browser/aggregateAcrossCells.js","../node_modules/scran.js/browser/block.js","../node_modules/scran.js/browser/cbind.js","../node_modules/scran.js/browser/chooseHVGs.js","../node_modules/scran.js/browser/clusterKmeans.js","../node_modules/scran.js/browser/clusterSNNGraph.js","../node_modules/scran.js/browser/factorize.js","../node_modules/scran.js/browser/filterCells.js","../node_modules/scran.js/browser/findNearestNeighbors.js","../node_modules/scran.js/browser/groupedSizeFactors.js","../node_modules/scran.js/browser/guessFeatures.js","../node_modules/scran.js/browser/hypergeometricTest.js","../node_modules/scran.js/browser/initializeSparseMatrix.js","../node_modules/scran.js/browser/internal/computePerCellQcFilters.js","../node_modules/scran.js/browser/internal/computePerCellQcMetrics.js","../node_modules/scran.js/browser/internal/pack_strings.js","../node_modules/scran.js/browser/labelCells.js","../node_modules/scran.js/browser/logNormCounts.js","../node_modules/scran.js/browser/mnnCorrect.js","../node_modules/scran.js/browser/modelGeneVar.js","../node_modules/scran.js/browser/perCellAdtQcMetrics.js","../node_modules/scran.js/browser/perCellCrisprQcMetrics.js","../node_modules/scran.js/browser/perCellRnaQcMetrics.js","../node_modules/scran.js/browser/quickAdtSizeFactors.js","../node_modules/scran.js/browser/rds.js","../node_modules/scran.js/browser/runPCA.js","../node_modules/scran.js/browser/runTSNE.js","../node_modules/scran.js/browser/scaleByNeighbors.js","../node_modules/scran.js/browser/scoreFeatureSet.js","../node_modules/scran.js/browser/scoreMarkers.js","../node_modules/scran.js/browser/subset.js","../node_modules/scran.js/browser/suggestAdtQcFilters.js","../node_modules/scran.js/browser/suggestCrisprQcFilters.js","../node_modules/scran.js/browser/suggestRnaQcFilters.js","../node_modules/scran.js/browser/utils.js","../node_modules/scran.js/browser/wasm.js","../node_modules/wasmarrays.js/src/create.js","../node_modules/wasmarrays.js/src/derived.js","../node_modules/wasmarrays.js/src/subset.js","../node_modules/wasmarrays.js/src/view.js"],"sourcesContent":["/* @license\nPapa Parse\nv5.4.1\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/\n!function(e,t){\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof module&&\"undefined\"!=typeof exports?module.exports=t():e.Papa=t()}(this,function s(){\"use strict\";var f=\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:void 0!==f?f:{};var n=!f.document&&!!f.postMessage,o=f.IS_PAPA_WORKER||!1,a={},u=0,b={parse:function(e,t){var r=(t=t||{}).dynamicTyping||!1;J(r)&&(t.dynamicTypingFunction=r,r={});if(t.dynamicTyping=r,t.transform=!!J(t.transform)&&t.transform,t.worker&&b.WORKERS_SUPPORTED){var i=function(){if(!b.WORKERS_SUPPORTED)return!1;var e=(r=f.URL||f.webkitURL||null,i=s.toString(),b.BLOB_URL||(b.BLOB_URL=r.createObjectURL(new Blob([\"var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; \",\"(\",i,\")();\"],{type:\"text/javascript\"})))),t=new f.Worker(e);var r,i;return t.onmessage=_,t.id=u++,a[t.id]=t}();return i.userStep=t.step,i.userChunk=t.chunk,i.userComplete=t.complete,i.userError=t.error,t.step=J(t.step),t.chunk=J(t.chunk),t.complete=J(t.complete),t.error=J(t.error),delete t.worker,void i.postMessage({input:e,config:t,workerId:i.id})}var n=null;b.NODE_STREAM_INPUT,\"string\"==typeof e?(e=function(e){if(65279===e.charCodeAt(0))return e.slice(1);return e}(e),n=t.download?new l(t):new p(t)):!0===e.readable&&J(e.read)&&J(e.on)?n=new g(t):(f.File&&e instanceof File||e instanceof Object)&&(n=new c(t));return n.stream(e)},unparse:function(e,t){var n=!1,_=!0,m=\",\",y=\"\\r\\n\",s='\"',a=s+s,r=!1,i=null,o=!1;!function(){if(\"object\"!=typeof t)return;\"string\"!=typeof t.delimiter||b.BAD_DELIMITERS.filter(function(e){return-1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter);(\"boolean\"==typeof t.quotes||\"function\"==typeof t.quotes||Array.isArray(t.quotes))&&(n=t.quotes);\"boolean\"!=typeof t.skipEmptyLines&&\"string\"!=typeof t.skipEmptyLines||(r=t.skipEmptyLines);\"string\"==typeof t.newline&&(y=t.newline);\"string\"==typeof t.quoteChar&&(s=t.quoteChar);\"boolean\"==typeof t.header&&(_=t.header);if(Array.isArray(t.columns)){if(0===t.columns.length)throw new Error(\"Option columns is empty\");i=t.columns}void 0!==t.escapeChar&&(a=t.escapeChar+s);(\"boolean\"==typeof t.escapeFormulae||t.escapeFormulae instanceof RegExp)&&(o=t.escapeFormulae instanceof RegExp?t.escapeFormulae:/^[=+\\-@\\t\\r].*$/)}();var u=new RegExp(Q(s),\"g\");\"string\"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return h(null,e,r);if(\"object\"==typeof e[0])return h(i||Object.keys(e[0]),e,r)}else if(\"object\"==typeof e)return\"string\"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields||i),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:\"object\"==typeof e.data[0]?Object.keys(e.data[0]):[]),Array.isArray(e.data[0])||\"object\"==typeof e.data[0]||(e.data=[e.data])),h(e.fields||[],e.data||[],r);throw new Error(\"Unable to serialize unrecognized input\");function h(e,t,r){var i=\"\";\"string\"==typeof e&&(e=JSON.parse(e)),\"string\"==typeof t&&(t=JSON.parse(t));var n=Array.isArray(e)&&0<e.length,s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(i+=m),i+=v(e[a],a);0<t.length&&(i+=y)}for(var o=0;o<t.length;o++){var u=n?e.length:t[o].length,h=!1,f=n?0===Object.keys(t[o]).length:0===t[o].length;if(r&&!n&&(h=\"greedy\"===r?\"\"===t[o].join(\"\").trim():1===t[o].length&&0===t[o][0].length),\"greedy\"===r&&n){for(var d=[],l=0;l<u;l++){var c=s?e[l]:l;d.push(t[o][c])}h=\"\"===d.join(\"\").trim()}if(!h){for(var p=0;p<u;p++){0<p&&!f&&(i+=m);var g=n&&s?e[p]:p;i+=v(t[o][g],p)}o<t.length-1&&(!r||0<u&&!f)&&(i+=y)}}return i}function v(e,t){if(null==e)return\"\";if(e.constructor===Date)return JSON.stringify(e).slice(1,25);var r=!1;o&&\"string\"==typeof e&&o.test(e)&&(e=\"'\"+e,r=!0);var i=e.toString().replace(u,a);return(r=r||!0===n||\"function\"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||function(e,t){for(var r=0;r<t.length;r++)if(-1<e.indexOf(t[r]))return!0;return!1}(i,b.BAD_DELIMITERS)||-1<i.indexOf(m)||\" \"===i.charAt(0)||\" \"===i.charAt(i.length-1))?s+i+s:i}}};if(b.RECORD_SEP=String.fromCharCode(30),b.UNIT_SEP=String.fromCharCode(31),b.BYTE_ORDER_MARK=\"\\ufeff\",b.BAD_DELIMITERS=[\"\\r\",\"\\n\",'\"',b.BYTE_ORDER_MARK],b.WORKERS_SUPPORTED=!n&&!!f.Worker,b.NODE_STREAM_INPUT=1,b.LocalChunkSize=10485760,b.RemoteChunkSize=5242880,b.DefaultDelimiter=\",\",b.Parser=E,b.ParserHandle=r,b.NetworkStreamer=l,b.FileStreamer=c,b.StringStreamer=p,b.ReadableStreamStreamer=g,f.jQuery){var d=f.jQuery;d.fn.parse=function(o){var r=o.config||{},u=[];return this.each(function(e){if(!(\"INPUT\"===d(this).prop(\"tagName\").toUpperCase()&&\"file\"===d(this).attr(\"type\").toLowerCase()&&f.FileReader)||!this.files||0===this.files.length)return!0;for(var t=0;t<this.files.length;t++)u.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},r)})}),e(),this;function e(){if(0!==u.length){var e,t,r,i,n=u[0];if(J(o.before)){var s=o.before(n.file,n.inputElem);if(\"object\"==typeof s){if(\"abort\"===s.action)return e=\"AbortError\",t=n.file,r=n.inputElem,i=s.reason,void(J(o.error)&&o.error({name:e},t,r,i));if(\"skip\"===s.action)return void h();\"object\"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config))}else if(\"skip\"===s)return void h()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){J(a)&&a(e,n.file,n.inputElem),h()},b.parse(n.file,n.instanceConfig)}else J(o.complete)&&o.complete()}function h(){u.splice(0,1),e()}}}function h(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine=\"\",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=w(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new r(t),(this._handle.streamer=this)._config=t}.call(this,e),this.parseChunk=function(e,t){if(this.isFirstChunk&&J(this._config.beforeFirstChunk)){var r=this._config.beforeFirstChunk(e);void 0!==r&&(e=r)}this.isFirstChunk=!1,this._halted=!1;var i=this._partialLine+e;this._partialLine=\"\";var n=this._handle.parse(i,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var s=n.meta.cursor;this._finished||(this._partialLine=i.substring(s-this._baseIndex),this._baseIndex=s),n&&n.data&&(this._rowCount+=n.data.length);var a=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(o)f.postMessage({results:n,workerId:b.WORKER_ID,finished:a});else if(J(this._config.chunk)&&!t){if(this._config.chunk(n,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);n=void 0,this._completeResults=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(n.data),this._completeResults.errors=this._completeResults.errors.concat(n.errors),this._completeResults.meta=n.meta),this._completed||!a||!J(this._config.complete)||n&&n.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),a||n&&n.meta.paused||this._nextChunk(),n}this._halted=!0},this._sendError=function(e){J(this._config.error)?this._config.error(e):o&&this._config.error&&f.postMessage({workerId:b.WORKER_ID,error:e,finished:!1})}}function l(e){var i;(e=e||{}).chunkSize||(e.chunkSize=b.RemoteChunkSize),h.call(this,e),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(e){this._input=e,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(i=new XMLHttpRequest,this._config.withCredentials&&(i.withCredentials=this._config.withCredentials),n||(i.onload=v(this._chunkLoaded,this),i.onerror=v(this._chunkError,this)),i.open(this._config.downloadRequestBody?\"POST\":\"GET\",this._input,!n),this._config.downloadRequestHeaders){var e=this._config.downloadRequestHeaders;for(var t in e)i.setRequestHeader(t,e[t])}if(this._config.chunkSize){var r=this._start+this._config.chunkSize-1;i.setRequestHeader(\"Range\",\"bytes=\"+this._start+\"-\"+r)}try{i.send(this._config.downloadRequestBody)}catch(e){this._chunkError(e.message)}n&&0===i.status&&this._chunkError()}},this._chunkLoaded=function(){4===i.readyState&&(i.status<200||400<=i.status?this._chunkError():(this._start+=this._config.chunkSize?this._config.chunkSize:i.responseText.length,this._finished=!this._config.chunkSize||this._start>=function(e){var t=e.getResponseHeader(\"Content-Range\");if(null===t)return-1;return parseInt(t.substring(t.lastIndexOf(\"/\")+1))}(i),this.parseChunk(i.responseText)))},this._chunkError=function(e){var t=i.statusText||e;this._sendError(new Error(t))}}function c(e){var i,n;(e=e||{}).chunkSize||(e.chunkSize=b.LocalChunkSize),h.call(this,e);var s=\"undefined\"!=typeof FileReader;this.stream=function(e){this._input=e,n=e.slice||e.webkitSlice||e.mozSlice,s?((i=new FileReader).onload=v(this._chunkLoaded,this),i.onerror=v(this._chunkError,this)):i=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var e=this._input;if(this._config.chunkSize){var t=Math.min(this._start+this._config.chunkSize,this._input.size);e=n.call(e,this._start,t)}var r=i.readAsText(e,this._config.encoding);s||this._chunkLoaded({target:{result:r}})},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result)},this._chunkError=function(){this._sendError(i.error)}}function p(e){var r;h.call(this,e=e||{}),this.stream=function(e){return r=e,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var e,t=this._config.chunkSize;return t?(e=r.substring(0,t),r=r.substring(t)):(e=r,r=\"\"),this._finished=!r,this.parseChunk(e)}}}function g(e){h.call(this,e=e||{});var t=[],r=!0,i=!1;this.pause=function(){h.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){h.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(e){this._input=e,this._input.on(\"data\",this._streamData),this._input.on(\"end\",this._streamEnd),this._input.on(\"error\",this._streamError)},this._checkIsFinished=function(){i&&1===t.length&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):r=!0},this._streamData=v(function(e){try{t.push(\"string\"==typeof e?e:e.toString(this._config.encoding)),r&&(r=!1,this._checkIsFinished(),this.parseChunk(t.shift()))}catch(e){this._streamError(e)}},this),this._streamError=v(function(e){this._streamCleanUp(),this._sendError(e)},this),this._streamEnd=v(function(){this._streamCleanUp(),i=!0,this._streamData(\"\")},this),this._streamCleanUp=v(function(){this._input.removeListener(\"data\",this._streamData),this._input.removeListener(\"end\",this._streamEnd),this._input.removeListener(\"error\",this._streamError)},this)}function r(m){var a,o,u,i=Math.pow(2,53),n=-i,s=/^\\s*-?(\\d+\\.?|\\.\\d+|\\d+\\.\\d+)([eE][-+]?\\d+)?\\s*$/,h=/^((\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z)))$/,t=this,r=0,f=0,d=!1,e=!1,l=[],c={data:[],errors:[],meta:{}};if(J(m.step)){var p=m.step;m.step=function(e){if(c=e,_())g();else{if(g(),0===c.data.length)return;r+=e.data.length,m.preview&&r>m.preview?o.abort():(c.data=c.data[0],p(c,t))}}}function y(e){return\"greedy\"===m.skipEmptyLines?\"\"===e.join(\"\").trim():1===e.length&&0===e[0].length}function g(){return c&&u&&(k(\"Delimiter\",\"UndetectableDelimiter\",\"Unable to auto-detect delimiting character; defaulted to '\"+b.DefaultDelimiter+\"'\"),u=!1),m.skipEmptyLines&&(c.data=c.data.filter(function(e){return!y(e)})),_()&&function(){if(!c)return;function e(e,t){J(m.transformHeader)&&(e=m.transformHeader(e,t)),l.push(e)}if(Array.isArray(c.data[0])){for(var t=0;_()&&t<c.data.length;t++)c.data[t].forEach(e);c.data.splice(0,1)}else c.data.forEach(e)}(),function(){if(!c||!m.header&&!m.dynamicTyping&&!m.transform)return c;function e(e,t){var r,i=m.header?{}:[];for(r=0;r<e.length;r++){var n=r,s=e[r];m.header&&(n=r>=l.length?\"__parsed_extra\":l[r]),m.transform&&(s=m.transform(s,n)),s=v(n,s),\"__parsed_extra\"===n?(i[n]=i[n]||[],i[n].push(s)):i[n]=s}return m.header&&(r>l.length?k(\"FieldMismatch\",\"TooManyFields\",\"Too many fields: expected \"+l.length+\" fields but parsed \"+r,f+t):r<l.length&&k(\"FieldMismatch\",\"TooFewFields\",\"Too few fields: expected \"+l.length+\" fields but parsed \"+r,f+t)),i}var t=1;!c.data.length||Array.isArray(c.data[0])?(c.data=c.data.map(e),t=c.data.length):c.data=e(c.data,0);m.header&&c.meta&&(c.meta.fields=l);return f+=t,c}()}function _(){return m.header&&0===l.length}function v(e,t){return r=e,m.dynamicTypingFunction&&void 0===m.dynamicTyping[r]&&(m.dynamicTyping[r]=m.dynamicTypingFunction(r)),!0===(m.dynamicTyping[r]||m.dynamicTyping)?\"true\"===t||\"TRUE\"===t||\"false\"!==t&&\"FALSE\"!==t&&(function(e){if(s.test(e)){var t=parseFloat(e);if(n<t&&t<i)return!0}return!1}(t)?parseFloat(t):h.test(t)?new Date(t):\"\"===t?null:t):t;var r}function k(e,t,r,i){var n={type:e,code:t,message:r};void 0!==i&&(n.row=i),c.errors.push(n)}this.parse=function(e,t,r){var i=m.quoteChar||'\"';if(m.newline||(m.newline=function(e,t){e=e.substring(0,1048576);var r=new RegExp(Q(t)+\"([^]*?)\"+Q(t),\"gm\"),i=(e=e.replace(r,\"\")).split(\"\\r\"),n=e.split(\"\\n\"),s=1<n.length&&n[0].length<i[0].length;if(1===i.length||s)return\"\\n\";for(var a=0,o=0;o<i.length;o++)\"\\n\"===i[o][0]&&a++;return a>=i.length/2?\"\\r\\n\":\"\\r\"}(e,i)),u=!1,m.delimiter)J(m.delimiter)&&(m.delimiter=m.delimiter(e),c.meta.delimiter=m.delimiter);else{var n=function(e,t,r,i,n){var s,a,o,u;n=n||[\",\",\"\\t\",\"|\",\";\",b.RECORD_SEP,b.UNIT_SEP];for(var h=0;h<n.length;h++){var f=n[h],d=0,l=0,c=0;o=void 0;for(var p=new E({comments:i,delimiter:f,newline:t,preview:10}).parse(e),g=0;g<p.data.length;g++)if(r&&y(p.data[g]))c++;else{var _=p.data[g].length;l+=_,void 0!==o?0<_&&(d+=Math.abs(_-o),o=_):o=_}0<p.data.length&&(l/=p.data.length-c),(void 0===a||d<=a)&&(void 0===u||u<l)&&1.99<l&&(a=d,s=f,u=l)}return{successful:!!(m.delimiter=s),bestDelimiter:s}}(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess);n.successful?m.delimiter=n.bestDelimiter:(u=!0,m.delimiter=b.DefaultDelimiter),c.meta.delimiter=m.delimiter}var s=w(m);return m.preview&&m.header&&s.preview++,a=e,o=new E(s),c=o.parse(a,t,r),g(),d?{meta:{paused:!0}}:c||{meta:{paused:!1}}},this.paused=function(){return d},this.pause=function(){d=!0,o.abort(),a=J(m.chunk)?\"\":a.substring(o.getCharIndex())},this.resume=function(){t.streamer._halted?(d=!1,t.streamer.parseChunk(a,!0)):setTimeout(t.resume,3)},this.aborted=function(){return e},this.abort=function(){e=!0,o.abort(),c.meta.aborted=!0,J(m.complete)&&m.complete(c),a=\"\"}}function Q(e){return e.replace(/[.*+?^${}()|[\\]\\\\]/g,\"\\\\$&\")}function E(j){var z,M=(j=j||{}).delimiter,P=j.newline,U=j.comments,q=j.step,N=j.preview,B=j.fastMode,K=z=void 0===j.quoteChar||null===j.quoteChar?'\"':j.quoteChar;if(void 0!==j.escapeChar&&(K=j.escapeChar),(\"string\"!=typeof M||-1<b.BAD_DELIMITERS.indexOf(M))&&(M=\",\"),U===M)throw new Error(\"Comment character same as delimiter\");!0===U?U=\"#\":(\"string\"!=typeof U||-1<b.BAD_DELIMITERS.indexOf(U))&&(U=!1),\"\\n\"!==P&&\"\\r\"!==P&&\"\\r\\n\"!==P&&(P=\"\\n\");var W=0,H=!1;this.parse=function(i,t,r){if(\"string\"!=typeof i)throw new Error(\"Input must be a string\");var n=i.length,e=M.length,s=P.length,a=U.length,o=J(q),u=[],h=[],f=[],d=W=0;if(!i)return L();if(j.header&&!t){var l=i.split(P)[0].split(M),c=[],p={},g=!1;for(var _ in l){var m=l[_];J(j.transformHeader)&&(m=j.transformHeader(m,_));var y=m,v=p[m]||0;for(0<v&&(g=!0,y=m+\"_\"+v),p[m]=v+1;c.includes(y);)y=y+\"_\"+v;c.push(y)}if(g){var k=i.split(P);k[0]=c.join(M),i=k.join(P)}}if(B||!1!==B&&-1===i.indexOf(z)){for(var b=i.split(P),E=0;E<b.length;E++){if(f=b[E],W+=f.length,E!==b.length-1)W+=P.length;else if(r)return L();if(!U||f.substring(0,a)!==U){if(o){if(u=[],I(f.split(M)),F(),H)return L()}else I(f.split(M));if(N&&N<=E)return u=u.slice(0,N),L(!0)}}return L()}for(var w=i.indexOf(M,W),R=i.indexOf(P,W),C=new RegExp(Q(K)+Q(z),\"g\"),S=i.indexOf(z,W);;)if(i[W]!==z)if(U&&0===f.length&&i.substring(W,W+a)===U){if(-1===R)return L();W=R+s,R=i.indexOf(P,W),w=i.indexOf(M,W)}else if(-1!==w&&(w<R||-1===R))f.push(i.substring(W,w)),W=w+e,w=i.indexOf(M,W);else{if(-1===R)break;if(f.push(i.substring(W,R)),D(R+s),o&&(F(),H))return L();if(N&&u.length>=N)return L(!0)}else for(S=W,W++;;){if(-1===(S=i.indexOf(z,S+1)))return r||h.push({type:\"Quotes\",code:\"MissingQuotes\",message:\"Quoted field unterminated\",row:u.length,index:W}),T();if(S===n-1)return T(i.substring(W,S).replace(C,z));if(z!==K||i[S+1]!==K){if(z===K||0===S||i[S-1]!==K){-1!==w&&w<S+1&&(w=i.indexOf(M,S+1)),-1!==R&&R<S+1&&(R=i.indexOf(P,S+1));var O=A(-1===R?w:Math.min(w,R));if(i.substr(S+1+O,e)===M){f.push(i.substring(W,S).replace(C,z)),i[W=S+1+O+e]!==z&&(S=i.indexOf(z,W)),w=i.indexOf(M,W),R=i.indexOf(P,W);break}var x=A(R);if(i.substring(S+1+x,S+1+x+s)===P){if(f.push(i.substring(W,S).replace(C,z)),D(S+1+x+s),w=i.indexOf(M,W),S=i.indexOf(z,W),o&&(F(),H))return L();if(N&&u.length>=N)return L(!0);break}h.push({type:\"Quotes\",code:\"InvalidQuotes\",message:\"Trailing quote on quoted field is malformed\",row:u.length,index:W}),S++}}else S++}return T();function I(e){u.push(e),d=W}function A(e){var t=0;if(-1!==e){var r=i.substring(S+1,e);r&&\"\"===r.trim()&&(t=r.length)}return t}function T(e){return r||(void 0===e&&(e=i.substring(W)),f.push(e),W=n,I(f),o&&F()),L()}function D(e){W=e,I(f),f=[],R=i.indexOf(P,W)}function L(e){return{data:u,errors:h,meta:{delimiter:M,linebreak:P,aborted:H,truncated:!!e,cursor:d+(t||0)}}}function F(){q(L()),u=[],h=[]}},this.abort=function(){H=!0},this.getCharIndex=function(){return W}}function _(e){var t=e.data,r=a[t.workerId],i=!1;if(t.error)r.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){i=!0,m(t.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:y,resume:y};if(J(r.userStep)){for(var s=0;s<t.results.data.length&&(r.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!i);s++);delete t.results}else J(r.userChunk)&&(r.userChunk(t.results,n,t.file),delete t.results)}t.finished&&!i&&m(t.workerId,t.results)}function m(e,t){var r=a[e];J(r.userComplete)&&r.userComplete(t),r.terminate(),delete a[e]}function y(){throw new Error(\"Not implemented.\")}function w(e){if(\"object\"!=typeof e||null===e)return e;var t=Array.isArray(e)?[]:{};for(var r in e)t[r]=w(e[r]);return t}function v(e,t){return function(){e.apply(t,arguments)}}function J(e){return\"function\"==typeof e}return o&&(f.onmessage=function(e){var t=e.data;void 0===b.WORKER_ID&&t&&(b.WORKER_ID=t.workerId);if(\"string\"==typeof t.input)f.postMessage({workerId:b.WORKER_ID,results:b.parse(t.input,t.config),finished:!0});else if(f.File&&t.input instanceof File||t.input instanceof Object){var r=b.parse(t.input,t.config);r&&f.postMessage({workerId:b.WORKER_ID,results:r,finished:!0})}}),(l.prototype=Object.create(h.prototype)).constructor=l,(c.prototype=Object.create(h.prototype)).constructor=c,(p.prototype=Object.create(p.prototype)).constructor=p,(g.prototype=Object.create(h.prototype)).constructor=g,b});","// randomColor by David Merfield under the CC0 license\n// https://github.com/davidmerfield/randomColor/\n\n;(function(root, factory) {\n\n  // Support CommonJS\n  if (typeof exports === 'object') {\n    var randomColor = factory();\n\n    // Support NodeJS & Component, which allow module.exports to be a function\n    if (typeof module === 'object' && module && module.exports) {\n      exports = module.exports = randomColor;\n    }\n\n    // Support CommonJS 1.1.1 spec\n    exports.randomColor = randomColor;\n\n  // Support AMD\n  } else if (typeof define === 'function' && define.amd) {\n    define([], factory);\n\n  // Support vanilla script loading\n  } else {\n    root.randomColor = factory();\n  }\n\n}(this, function() {\n\n  // Seed to get repeatable colors\n  var seed = null;\n\n  // Shared color dictionary\n  var colorDictionary = {};\n\n  // Populate the color dictionary\n  loadColorBounds();\n\n  // check if a range is taken\n  var colorRanges = [];\n\n  var randomColor = function (options) {\n\n    options = options || {};\n\n    // Check if there is a seed and ensure it's an\n    // integer. Otherwise, reset the seed value.\n    if (options.seed !== undefined && options.seed !== null && options.seed === parseInt(options.seed, 10)) {\n      seed = options.seed;\n\n    // A string was passed as a seed\n    } else if (typeof options.seed === 'string') {\n      seed = stringToInteger(options.seed);\n\n    // Something was passed as a seed but it wasn't an integer or string\n    } else if (options.seed !== undefined && options.seed !== null) {\n      throw new TypeError('The seed value must be an integer or string');\n\n    // No seed, reset the value outside.\n    } else {\n      seed = null;\n    }\n\n    var H,S,B;\n\n    // Check if we need to generate multiple colors\n    if (options.count !== null && options.count !== undefined) {\n\n      var totalColors = options.count,\n          colors = [];\n      // Value false at index i means the range i is not taken yet.\n      for (var i = 0; i < options.count; i++) {\n        colorRanges.push(false)\n        }\n      options.count = null;\n\n      while (totalColors > colors.length) {\n\n        var color = randomColor(options);\n\n        if (seed !== null) {\n          options.seed = seed;\n        }\n\n        colors.push(color);\n      }\n\n      options.count = totalColors;\n\n      return colors;\n    }\n\n    // First we pick a hue (H)\n    H = pickHue(options);\n\n    // Then use H to determine saturation (S)\n    S = pickSaturation(H, options);\n\n    // Then use S and H to determine brightness (B).\n    B = pickBrightness(H, S, options);\n\n    // Then we return the HSB color in the desired format\n    return setFormat([H,S,B], options);\n  };\n\n  function pickHue(options) {\n    if (colorRanges.length > 0) {\n      var hueRange = getRealHueRange(options.hue)\n\n      var hue = randomWithin(hueRange)\n\n      //Each of colorRanges.length ranges has a length equal approximatelly one step\n      var step = (hueRange[1] - hueRange[0]) / colorRanges.length\n\n      var j = parseInt((hue - hueRange[0]) / step)\n\n      //Check if the range j is taken\n      if (colorRanges[j] === true) {\n        j = (j + 2) % colorRanges.length\n      }\n      else {\n        colorRanges[j] = true\n           }\n\n      var min = (hueRange[0] + j * step) % 359,\n          max = (hueRange[0] + (j + 1) * step) % 359;\n\n      hueRange = [min, max]\n\n      hue = randomWithin(hueRange)\n\n      if (hue < 0) {hue = 360 + hue;}\n      return hue\n    }\n    else {\n      var hueRange = getHueRange(options.hue)\n\n      hue = randomWithin(hueRange);\n      // Instead of storing red as two seperate ranges,\n      // we group them, using negative numbers\n      if (hue < 0) {\n        hue = 360 + hue;\n      }\n\n      return hue;\n    }\n  }\n\n  function pickSaturation (hue, options) {\n\n    if (options.hue === 'monochrome') {\n      return 0;\n    }\n\n    if (options.luminosity === 'random') {\n      return randomWithin([0,100]);\n    }\n\n    var saturationRange = getSaturationRange(hue);\n\n    var sMin = saturationRange[0],\n        sMax = saturationRange[1];\n\n    switch (options.luminosity) {\n\n      case 'bright':\n        sMin = 55;\n        break;\n\n      case 'dark':\n        sMin = sMax - 10;\n        break;\n\n      case 'light':\n        sMax = 55;\n        break;\n   }\n\n    return randomWithin([sMin, sMax]);\n\n  }\n\n  function pickBrightness (H, S, options) {\n\n    var bMin = getMinimumBrightness(H, S),\n        bMax = 100;\n\n    switch (options.luminosity) {\n\n      case 'dark':\n        bMax = bMin + 20;\n        break;\n\n      case 'light':\n        bMin = (bMax + bMin)/2;\n        break;\n\n      case 'random':\n        bMin = 0;\n        bMax = 100;\n        break;\n    }\n\n    return randomWithin([bMin, bMax]);\n  }\n\n  function setFormat (hsv, options) {\n\n    switch (options.format) {\n\n      case 'hsvArray':\n        return hsv;\n\n      case 'hslArray':\n        return HSVtoHSL(hsv);\n\n      case 'hsl':\n        var hsl = HSVtoHSL(hsv);\n        return 'hsl('+hsl[0]+', '+hsl[1]+'%, '+hsl[2]+'%)';\n\n      case 'hsla':\n        var hslColor = HSVtoHSL(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'hsla('+hslColor[0]+', '+hslColor[1]+'%, '+hslColor[2]+'%, ' + alpha + ')';\n\n      case 'rgbArray':\n        return HSVtoRGB(hsv);\n\n      case 'rgb':\n        var rgb = HSVtoRGB(hsv);\n        return 'rgb(' + rgb.join(', ') + ')';\n\n      case 'rgba':\n        var rgbColor = HSVtoRGB(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'rgba(' + rgbColor.join(', ') + ', ' + alpha + ')';\n\n      default:\n        return HSVtoHex(hsv);\n    }\n\n  }\n\n  function getMinimumBrightness(H, S) {\n\n    var lowerBounds = getColorInfo(H).lowerBounds;\n\n    for (var i = 0; i < lowerBounds.length - 1; i++) {\n\n      var s1 = lowerBounds[i][0],\n          v1 = lowerBounds[i][1];\n\n      var s2 = lowerBounds[i+1][0],\n          v2 = lowerBounds[i+1][1];\n\n      if (S >= s1 && S <= s2) {\n\n         var m = (v2 - v1)/(s2 - s1),\n             b = v1 - m*s1;\n\n         return m*S + b;\n      }\n\n    }\n\n    return 0;\n  }\n\n  function getHueRange (colorInput) {\n\n    if (typeof parseInt(colorInput) === 'number') {\n\n      var number = parseInt(colorInput);\n\n      if (number < 360 && number > 0) {\n        return [number, number];\n      }\n\n    }\n\n    if (typeof colorInput === 'string') {\n\n      if (colorDictionary[colorInput]) {\n        var color = colorDictionary[colorInput];\n        if (color.hueRange) {return color.hueRange;}\n      } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {\n        var hue = HexToHSB(colorInput)[0];\n        return [ hue, hue ];\n      }\n    }\n\n    return [0,360];\n\n  }\n\n  function getSaturationRange (hue) {\n    return getColorInfo(hue).saturationRange;\n  }\n\n  function getColorInfo (hue) {\n\n    // Maps red colors to make picking hue easier\n    if (hue >= 334 && hue <= 360) {\n      hue-= 360;\n    }\n\n    for (var colorName in colorDictionary) {\n       var color = colorDictionary[colorName];\n       if (color.hueRange &&\n           hue >= color.hueRange[0] &&\n           hue <= color.hueRange[1]) {\n          return colorDictionary[colorName];\n       }\n    } return 'Color not found';\n  }\n\n  function randomWithin (range) {\n    if (seed === null) {\n      //generate random evenly destinct number from : https://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/\n      var golden_ratio = 0.618033988749895\n      var r=Math.random()\n      r += golden_ratio\n      r %= 1\n      return Math.floor(range[0] + r*(range[1] + 1 - range[0]));\n    } else {\n      //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/\n      var max = range[1] || 1;\n      var min = range[0] || 0;\n      seed = (seed * 9301 + 49297) % 233280;\n      var rnd = seed / 233280.0;\n      return Math.floor(min + rnd * (max - min));\n}\n  }\n\n  function HSVtoHex (hsv){\n\n    var rgb = HSVtoRGB(hsv);\n\n    function componentToHex(c) {\n        var hex = c.toString(16);\n        return hex.length == 1 ? '0' + hex : hex;\n    }\n\n    var hex = '#' + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);\n\n    return hex;\n\n  }\n\n  function defineColor (name, hueRange, lowerBounds) {\n\n    var sMin = lowerBounds[0][0],\n        sMax = lowerBounds[lowerBounds.length - 1][0],\n\n        bMin = lowerBounds[lowerBounds.length - 1][1],\n        bMax = lowerBounds[0][1];\n\n    colorDictionary[name] = {\n      hueRange: hueRange,\n      lowerBounds: lowerBounds,\n      saturationRange: [sMin, sMax],\n      brightnessRange: [bMin, bMax]\n    };\n\n  }\n\n  function loadColorBounds () {\n\n    defineColor(\n      'monochrome',\n      null,\n      [[0,0],[100,0]]\n    );\n\n    defineColor(\n      'red',\n      [-26,18],\n      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]\n    );\n\n    defineColor(\n      'orange',\n      [18,46],\n      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]\n    );\n\n    defineColor(\n      'yellow',\n      [46,62],\n      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]\n    );\n\n    defineColor(\n      'green',\n      [62,178],\n      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]\n    );\n\n    defineColor(\n      'blue',\n      [178, 257],\n      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]\n    );\n\n    defineColor(\n      'purple',\n      [257, 282],\n      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]\n    );\n\n    defineColor(\n      'pink',\n      [282, 334],\n      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]\n    );\n\n  }\n\n  function HSVtoRGB (hsv) {\n\n    // this doesn't work for the values of 0 and 360\n    // here's the hacky fix\n    var h = hsv[0];\n    if (h === 0) {h = 1;}\n    if (h === 360) {h = 359;}\n\n    // Rebase the h,s,v values\n    h = h/360;\n    var s = hsv[1]/100,\n        v = hsv[2]/100;\n\n    var h_i = Math.floor(h*6),\n      f = h * 6 - h_i,\n      p = v * (1 - s),\n      q = v * (1 - f*s),\n      t = v * (1 - (1 - f)*s),\n      r = 256,\n      g = 256,\n      b = 256;\n\n    switch(h_i) {\n      case 0: r = v; g = t; b = p;  break;\n      case 1: r = q; g = v; b = p;  break;\n      case 2: r = p; g = v; b = t;  break;\n      case 3: r = p; g = q; b = v;  break;\n      case 4: r = t; g = p; b = v;  break;\n      case 5: r = v; g = p; b = q;  break;\n    }\n\n    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];\n    return result;\n  }\n\n  function HexToHSB (hex) {\n    hex = hex.replace(/^#/, '');\n    hex = hex.length === 3 ? hex.replace(/(.)/g, '$1$1') : hex;\n\n    var red = parseInt(hex.substr(0, 2), 16) / 255,\n          green = parseInt(hex.substr(2, 2), 16) / 255,\n          blue = parseInt(hex.substr(4, 2), 16) / 255;\n\n    var cMax = Math.max(red, green, blue),\n          delta = cMax - Math.min(red, green, blue),\n          saturation = cMax ? (delta / cMax) : 0;\n\n    switch (cMax) {\n      case red: return [ 60 * (((green - blue) / delta) % 6) || 0, saturation, cMax ];\n      case green: return [ 60 * (((blue - red) / delta) + 2) || 0, saturation, cMax ];\n      case blue: return [ 60 * (((red - green) / delta) + 4) || 0, saturation, cMax ];\n    }\n  }\n\n  function HSVtoHSL (hsv) {\n    var h = hsv[0],\n      s = hsv[1]/100,\n      v = hsv[2]/100,\n      k = (2-s)*v;\n\n    return [\n      h,\n      Math.round(s*v / (k<1 ? k : 2-k) * 10000) / 100,\n      k/2 * 100\n    ];\n  }\n\n  function stringToInteger (string) {\n    var total = 0\n    for (var i = 0; i !== string.length; i++) {\n      if (total >= Number.MAX_SAFE_INTEGER) break;\n      total += string.charCodeAt(i)\n    }\n    return total\n  }\n\n  // get The range of given hue when options.count!=0\n  function getRealHueRange(colorHue)\n  { if (!isNaN(colorHue)) {\n    var number = parseInt(colorHue);\n\n    if (number < 360 && number > 0) {\n      return getColorInfo(colorHue).hueRange\n    }\n  }\n    else if (typeof colorHue === 'string') {\n\n      if (colorDictionary[colorHue]) {\n        var color = colorDictionary[colorHue];\n\n        if (color.hueRange) {\n          return color.hueRange\n       }\n    } else if (colorHue.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {\n        var hue = HexToHSB(colorHue)[0]\n        return getColorInfo(hue).hueRange\n    }\n  }\n\n    return [0,360]\n}\n  return randomColor;\n}));\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {\n  if (receiver !== classConstructor) {\n    throw new TypeError(\"Private static access of wrong provenance\");\n  }\n}","export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {\n  if (descriptor === undefined) {\n    throw new TypeError(\"attempted to \" + action + \" private static field before its declaration\");\n  }\n}","export default function _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}","import checkPrivateRedeclaration from \"./checkPrivateRedeclaration.js\";\nexport default function _classPrivateMethodInitSpec(obj, privateSet) {\n  checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}","import classApplyDescriptorGet from \"./classApplyDescriptorGet.js\";\nimport classCheckPrivateStaticAccess from \"./classCheckPrivateStaticAccess.js\";\nimport classCheckPrivateStaticFieldDescriptor from \"./classCheckPrivateStaticFieldDescriptor.js\";\nexport default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n  classCheckPrivateStaticAccess(receiver, classConstructor);\n  classCheckPrivateStaticFieldDescriptor(descriptor, \"get\");\n  return classApplyDescriptorGet(receiver, descriptor);\n}","import classApplyDescriptorSet from \"./classApplyDescriptorSet.js\";\nimport classCheckPrivateStaticAccess from \"./classCheckPrivateStaticAccess.js\";\nimport classCheckPrivateStaticFieldDescriptor from \"./classCheckPrivateStaticFieldDescriptor.js\";\nexport default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n  classCheckPrivateStaticAccess(receiver, classConstructor);\n  classCheckPrivateStaticFieldDescriptor(descriptor, \"set\");\n  classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}","import classCheckPrivateStaticAccess from \"./classCheckPrivateStaticAccess.js\";\nexport default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n  classCheckPrivateStaticAccess(receiver, classConstructor);\n  return method;\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import superPropBase from \"./superPropBase.js\";\nexport default function _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure \" + obj);\n}","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import * as bioc from \"bioconductor\";\n\nexport function cloneCached(x, cached) {\n    return (cached ? bioc.CLONE(x) : x);\n}\n\n/**\n * A representation of a matrix of expression values, where the values are hosted on the Wasm heap for easier compute via [**scran.js**](https://github.com/jkanche/scran.js).\n * See [here](https://jkanche.github.io/scran.js/ScranMatrix.html) for more details.\n *\n * @external ScranMatrix\n */ \n\n/**\n * A representation of multiple {@linkplain external:ScranMatrix ScranMatrix} objects, where each object contains data for the same cells but across a different feature space, e.g., for different data modalities.\n * See [here](https://jkanche.github.io/scran.js/MultiMatrix.html) for more details.\n *\n * @external MultiMatrix\n */ \n\n\n/**\n * A DataFrame from the [**bioconductor**](https://github.com/LTLA/bioconductor.js) package, where each column is represented by some arbitrary vector-like object.\n * See [here](https://ltla.github.io/bioconductor.js/DataFrame.html) for more details.\n *\n * @external DataFrame\n */ \n\n/**\n * Representation of a file that is agnostic to the environment (Node.js or browser) or the nature of the contents (buffer or file path).\n * See [here](https://ltla.github.io/bakana/SimpleFile.html) for more details.\n *\n * @external SimpleFile\n */ \n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as bakana from \"bakana\";\nimport * as utils from \"./utils.js\";\n\nconst baseUrl = \"https://experimenthub.bioconductor.org/fetch\";\n\nconst registry = {\n    \"zeisel-brain\": { \"counts\": \"2596\", \"coldata\": \"2598\", \"rowdata\": \"2597\" }, // corresponding to EH2580, 2582 and 2581, for whatever reason.\n    \"segerstolpe-pancreas\": { \"counts\": \"2591\", \"coldata\": \"2593\", \"rowdata\": \"2592\" }, // corresponding to EH2575, 2577 and 2576.\n    \"nestorowa-hsc\": { \"counts\": \"2710\", \"ncol\": 1920 }, // corresponding to EH2694; the coldata doesn't contain much that's useful here.\n    \"aztekin-tail\": { \"counts\": \"3124\", \"coldata\": \"3125\" }, // corresponding to EH3108 and 3109.\n    \"wu-kidney\": { \"counts\": \"3594\", \"coldata\": \"3595\" }, // corresponding to EH3558 and 3559.\n    \"zilionis-mouse-lung\": { \"counts\": \"3478\", \"coldata\": \"3479\" } // corresponding to EH3462 and 3463.\n};\n\nfunction check_class(handle, accepted, base) {\n    if (!(handle instanceof scran.RdsS4Object)) {\n        throw new Error(\"expected an S4 object\");\n    }\n\n    for (const [k, v] of Object.entries(accepted)) {\n        if (handle.className() == k && handle.packageName() == v) {\n            return;\n        }\n    }\n    throw new Error(\"object is not a \" + base + \" or one of its recognized subclasses\");\n}\n\nfunction load_listData_names(lhandle) {\n    let ndx = lhandle.findAttribute(\"names\");\n    if (ndx < 0) {\n        return null;\n    }\n\n    let nhandle;\n    let names;\n    try {\n        nhandle = lhandle.attribute(ndx);\n        names = nhandle.values();\n    } catch(e) {\n        throw new Error(\"failed to load listData names; \" + e.message);\n    } finally {\n        scran.free(nhandle);\n    }\n\n    if (names.length != lhandle.length()) {\n        throw new Error(\"expected names to have same length as listData\");\n    }\n    return names;\n}\n\nfunction populate_list_columns(lhandle, output) {\n    let colnames = load_listData_names(lhandle);\n    if (colnames == null) {\n        throw new Error(\"expected the listData list to be named\");\n    }\n    let columns = {};\n\n    for (var i = 0; i < lhandle.length(); i++) {\n        let curhandle;\n        try {\n            curhandle = lhandle.load(i);\n            if (curhandle instanceof scran.RdsVector && !(curhandle instanceof scran.RdsGenericVector)) {\n                let curcol = curhandle.values();\n                columns[colnames[i]] = curcol;\n                output.nrow = curcol.length;\n            }\n        } finally {\n            scran.free(curhandle);\n        }\n    }\n\n    output.columns = columns;\n    return;\n}\n\nfunction load_data_frame(handle) {\n    let output = {};\n\n    if (handle.type() == \"S4\") {\n        check_class(handle, { \"DFrame\": \"S4Vectors\", \"DataFrame\": \"S4Vectors\" }, \"DFrame\");\n\n        // Loading the atomic columns.\n        let lhandle;\n        try {\n            lhandle = handle.attribute(\"listData\");\n            if (!(lhandle instanceof scran.RdsGenericVector)) {\n                throw new Error(\"listData slot should be a generic list\");\n            }\n            populate_list_columns(lhandle, output);\n        } catch(e) {\n            throw new Error(\"failed to retrieve data from DataFrame's listData; \" + e.message);\n        } finally {\n            scran.free(lhandle);\n        }\n    } else {\n        if (handle.type() != \"vector\") {\n            throw new Error(\"expected a data.frame or DataFrame instance\");\n        }\n        populate_list_columns(handle, output);\n    }\n\n    // Loading the row names.\n    let rnhandle;\n    try {\n        let rndx = handle.findAttribute(\"rownames\");\n        if (rndx >= 0) {\n            rnhandle = handle.attribute(rndx);\n            if (rnhandle instanceof scran.RdsStringVector) {\n                output.row_names = rnhandle.values();\n                output.nrow = output.row_names.length;\n            }\n        }\n    } catch(e) {\n        throw new Error(\"failed to retrieve row names from DataFrame; \" + e.message);\n    } finally {\n        scran.free(rnhandle);\n    }\n\n    // Loading the number of rows.\n    if (!(\"nrow\" in output)) {\n        let nrhandle;\n        try {\n            nrhandle = handle.attribute(\"nrows\");\n            if (!(nrhandle instanceof scran.RdsIntegerVector)) {\n                throw new Error(\"expected an integer vector as the 'nrows' slot\");\n            }\n            let NR = nrhandle.values();\n            if (NR.length != 1) {\n                throw new Error(\"expected an integer vector of length 1 as the 'nrows' slot\");\n            }\n            output.nrow = NR[0];\n        } catch (e) {\n            throw new Error(\"failed to retrieve nrows from DataFrame; \" + e.message);\n        } finally {\n            scran.free(nrhandle);\n        }\n    }\n\n    return output;\n}\n\nfunction extract_matrix_rownames(handle) {\n    let idx;\n\n    if (handle.type() == \"S4\") {\n        check_class(handle, { \"dgCMatrix\": \"Matrix\", \"dgTMatrix\": \"Matrix\" }, \"Matrix\");\n        idx = handle.findAttribute(\"Dimnames\");\n    } else {\n        idx = handle.findAttribute(\"dimnames\");\n    }\n\n    if (idx < 0) {\n        throw new Error(\"count matrix does not have dimnames\");\n    }\n\n    let dimhandle;\n    let firsthandle;\n    let output;\n    \n    try {\n        dimhandle = handle.attribute(idx);\n        if (dimhandle.type() != \"vector\" && dimhandle.size() != 2) {\n            throw new Error(\"dimnames of the count matrix should be a list of length 2\");\n        }\n\n        firsthandle = dimhandle.load(0);\n        if (firsthandle.type() != \"string\") {\n            throw new Error(\"expected a character vector in the first dimnames\");\n        }\n\n        output = firsthandle.values();\n    } finally {\n        scran.free(dimhandle);\n        scran.free(firsthandle);\n    }\n\n    return output;\n}\n\n/**\n * Dataset derived from a SummarizedExperiment-like representation on Bioconductor's [ExperimentHub](https://bioconductor.org/packages/ExperimentHub).\n */\nexport class ExperimentHubDataset {\n    #id;\n\n    #rowdata;\n    #coldata;\n\n    #counts_handle;\n    #counts_loaded;\n\n    // We should _know_ which experiments correspond to which modality for each\n    // dataset in our registry, so there's no need to provide options for that.\n    // However, we might not know how to choose an appropriate primary\n    // identifier for combining datasets, hence these options.\n    #options;\n\n    /****************************************\n     ****************************************/\n\n    static #downloadFun = async url => {\n        let resp = await fetch(url);\n        if (!resp.ok) {\n            throw new Error(\"failed to fetch content at \" + url + \" (\" + resp.status + \")\");\n        }\n        return new Uint8Array(await resp.arrayBuffer());\n    }\n\n    /** \n     * @param {function} fun - Function that accepts a URL string and downloads the resource,\n     * returning a Uint8Array of its contents.\n     * Alternatively, on Node.js, the funciton may return a string containing the path to the downloaded resource.\n     * @return {function} Previous setting of the download function.\n     */\n    static setDownloadFun(fun) {\n        let previous = ExperimentHubDataset.#downloadFun;\n        ExperimentHubDataset.#downloadFun = fun;\n        return previous;\n    }\n\n    /****************************************\n     ****************************************/\n\n    /**\n     * @return {Array} Array of strings containing identifiers of available datasets.\n     * @static\n     */\n    static availableDatasets() {\n        return Object.keys(registry);\n    }\n\n    /**\n     * @param {string} id - Identifier of a dataset to load.\n     * This should be a string in {@linkcode ExperimentHubDataset.availableDatasets availableDatasets}.\n     */\n    constructor(id) {\n        this.#id = id;\n        if (!(this.#id in registry)) {\n            throw new Error(\"unrecognized identifier '\" + this.#id + \"' for ExperimentHub-based datasets\");\n        }\n\n        this.#options = ExperimentHubDataset.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode ExperimentHubDataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            primaryRnaFeatureIdColumn: 0\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode ExperimentHubDataset#load load} (but not {@linkcode ExperimentHubDataset#summary summary}).\n     * @param {string|number} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    /**\n     * @return {string} Format of this dataset class.\n     * @static\n     */\n    static format() {\n        return \"ExperimentHub\";\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode ExperimentHubDataset#load load} or {@linkcodeExperimentHubDataset#annotations annotations}. \n     */\n    clear() {\n        scran.free(this.#counts_handle);\n        scran.free(this.#counts_loaded);\n        this.#counts_handle = null;\n        this.#counts_loaded = null;\n        this.#rowdata = null;\n        this.#coldata = null;\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset.\n     */\n    abbreviate() {\n        return { \"id\": this.#id, \"options\": this.options() };\n    }\n\n    async #counts() {\n        if (this.#counts_handle !== null) {\n            return;\n        }\n\n        let details = registry[this.#id];\n        let counts_deets = await ExperimentHubDataset.#downloadFun(baseUrl + \"/\" + details.counts);\n        try {\n            this.#counts_loaded = scran.readRds(counts_deets);\n            this.#counts_handle = this.#counts_loaded.value();\n        } catch(e) {\n            scran.free(this.#counts_handle);\n            scran.free(this.#counts_loaded);\n            throw e;\n        }\n    }\n\n    async #features() {\n        if (this.#rowdata !== null) {\n            return;\n        }\n\n        let details = registry[this.#id];\n\n        if (\"rowdata\" in details) {\n            let rowdata_deets = await ExperimentHubDataset.#downloadFun(baseUrl + \"/\" + details.rowdata);\n\n            let rowdata_load;\n            let rowdata_handle;\n            try {\n                rowdata_load = scran.readRds(rowdata_deets);\n                rowdata_handle = rowdata_load.value();\n                let rowdata = load_data_frame(rowdata_handle);\n                let names = rowdata.row_names;\n\n                let output = {};\n                if (names) {\n                    output.id = names;\n                }\n\n                for (const [k, v] of Object.entries(rowdata.columns)) {\n                    if (k.match(/^sym/)) {\n                        output[k] = v;\n                    }\n                }\n\n                if (Object.keys(output).length == 0) {\n                    throw new Error(\"no acceptable feature identifiers found in the rowData DataFrame\");\n                }\n                this.#rowdata = new bioc.DataFrame(output);\n            } finally {\n                scran.free(rowdata_handle);\n                scran.free(rowdata_load);\n            }\n            return;\n        }\n\n        // Otherwise we pull the details from the counts.\n        await this.#counts();\n        let ids = extract_matrix_rownames(this.#counts_handle);\n        this.#rowdata = new bioc.DataFrame({ id: ids });\n    }\n\n    async #cells() {\n        if (this.#coldata !== null) {\n            return;\n        }\n\n        let details = registry[this.#id];\n        if (\"coldata\" in details) {\n            let coldata_deets = await ExperimentHubDataset.#downloadFun(baseUrl + \"/\" + details.coldata);\n\n            let coldata_load;\n            let coldata_handle; \n            let cd_df;\n            try {\n                coldata_load = scran.readRds(coldata_deets);\n                coldata_handle = coldata_load.value();\n                cd_df = load_data_frame(coldata_handle);\n            } finally {\n                scran.free(coldata_handle);\n                scran.free(coldata_load);\n            }\n\n            this.#coldata = new bioc.DataFrame(cd_df.columns, { numberOfRows: cd_df.nrow });\n        } else {\n            this.#coldata = new bioc.DataFrame({}, { numberOfRows: details.ncol });\n        }\n\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode ExperimentHubDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     *   Unlike {@linkcode ExperimentHubDataset#load load}, modality names are arbitrary.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     */\n    async summary({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n\n        let output = { cells: utils.cloneCached(this.#coldata, cache) };\n        let my_rd = utils.cloneCached(this.#rowdata, cache);\n        output.modality_features = { \"RNA\": my_rd };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #fetchPrimaryId(curfeat) {\n        let id = this.#options.primaryRnaFeatureIdColumn;\n        if ((typeof id == \"string\" && curfeat.hasColumn(id)) || (typeof id == \"number\" && id < curfeat.numberOfColumns())) {\n            return { RNA: curfeat.column(id) };\n        } else {\n            return { RNA: curfeat.rowNames() };\n        }\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode ExperimentHubDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode ExperimentHubDataset#load load} but the order of values may be different.\n     *\n     * @async\n     */\n    async previewPrimaryIds({ cache = false } = {}) {\n        await this.#features();\n        let preview = this.#fetchPrimaryId(this.#rowdata);\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode ExperimentHubDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an integer array containing the feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRISPR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode ExperimentHubDataset#defaults defaults} or with {@linkcode ExperimentHubDataset#setOptions setOptions}.\n     */\n    async load({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n        await this.#counts();\n\n        let output = {\n            cells: utils.cloneCached(this.#coldata, cache)\n        };\n\n        // Hard-coding the fact that we're dealing with RNA here, as all\n        // registry entries are currently RNA-only anyway.\n        let details = registry[this.#id];\n        try {\n            output.matrix = new scran.MultiMatrix;\n            let counts = scran.initializeSparseMatrixFromRds(this.#counts_handle, { consume: !cache });\n\n            output.matrix.add(\"RNA\", counts.matrix);\n            output.row_ids = { \"RNA\": counts.row_ids };\n\n            let perm_features = bioc.SLICE(this.#rowdata, counts.row_ids);\n            output.features = { \"RNA\": perm_features };\n        } catch (e) {\n            scran.free(output.matrix);\n            throw e;\n        }\n\n        output.primary_ids = this.#fetchPrimaryId(output.features.RNA);\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        const enc = new TextEncoder;\n        let buffer = enc.encode(this.#id);\n\n        // Storing it as a string in the buffer.\n        let output = {\n            type: \"id\",\n            file: new bakana.SimpleFile(buffer, { name: \"id\" })\n        };\n\n        return {\n            files: [ output ],\n            options: this.options()\n        }\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode ExperimentHubDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {ExperimentHubDataset} A new instance of this class.\n     * @static\n     */\n    static unserialize(files, options) {\n        let args = {};\n\n        // This should contain 'id'.\n        for (const x of files) {\n            const dec = new TextDecoder;\n            args[x.type] = dec.decode(x.file.buffer());\n        }\n\n        if (!(\"id\" in args)) {\n            throw new Error(\"expected a file of type 'id' when unserializing ExperimentHub dataset\"); \n        }\n        return new ExperimentHubDataset(args.id, options);\n    }\n}\n","/**\n * Create an ArtifactDB resource ID from its components.\n *\n * @param {string} project - Name of the project.\n * This should not contain `\":\"`.\n * @param {string} path - Path to the resource inside the project.\n * @param {string|number} version - Version of the project.\n * This should not contain `\"@\"`.\n *\n * @return {string} A full ArtifactDB identifier for the resource.\n */\nexport function packId(project, path, version) {\n    return project + \":\" + path + \"@\" + String(version);\n}\n\n/**\n * Split an AritfactDB resource ID into its components.\n *\n * @param {string} id - The full ArtifactDB identifier for a resource.\n * This should follow the format of `<PROJECT>:<PATH>@<VERSION>`,\n * where `<PROJECT>` should not contain `:` and `<VERSION>` should not contain `@`.\n *\n * @return {object} Object containing `project`, `path` and `version` strings - see {@linkcode packId} for details.\n */\nexport function unpackId(id) {\n    let i1 = id.indexOf(\":\");\n    if (i1 < 0) {\n        throw new Error(\"could not identify project from 'id'\");\n    } else if (i1 == 0) {\n        throw new Error(\"'id' should not have an empty project\");\n    }\n\n    let i2 = id.lastIndexOf(\"@\");\n    if (i2 < 0) {\n        throw new Error(\"could not identify version from 'id'\");\n    } else if (i2 == id.length - 1) {\n        throw new Error(\"'id' should not have an empty version\");\n    }\n\n    if (i2 < i1) {\n        throw new Error(\"could not identify version from 'id'\");\n    } else if (i1 +1 == i2){\n        throw new Error(\"'id' should not have an empty path\");\n    }\n\n    return {\n        project: id.slice(0, i1),\n        path: id.slice(i1+1, i2),\n        version: id.slice(i2+1)\n    };\n}\n","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","/**\n * Representation of a HTTP response error.\n * The error message is captured in `message` as usual, but the HTTP status code may also be retrieved via the `statusCode` property.\n */\nexport class HttpError extends Error {\n    constructor(message, code) {\n        super(message);\n        this.statusCode = code;\n    }\n}\n\nexport async function checkHttpResponse(res, msg) {\n    if (res.ok) {\n        return;\n    }\n\n    let info = await res.json();\n    if (info.status == \"error\") {\n        throw new HttpError(msg + \"; \" + info.reason, res.status);\n    } \n\n    throw new HttpError(msg, res.status);\n}\n","/**\n * Headers to be attached to all HTTP requests using the default functions (typically based on `fetch`).\n * Keys are the header names while values are the header contents.\n * This is mainly used to set the `Authorization` header for authentication.\n */\nexport var globalRequestHeaders = {};\n\nexport function quickGet(url) {\n    return fetch(url, { headers: globalRequestHeaders });\n}\n\nexport function quickPutJson(url, body) {\n    let opt = { \n        method: \"PUT\", \n        headers: { ...globalRequestHeaders }\n    };\n\n    if (body) {\n        opt.headers[\"Content-Type\"] = \"application/json\";\n        opt.body = JSON.stringify(body);\n    }\n\n    return fetch(url, opt);\n}\n","import * as err from \"./HttpError.js\";\nimport * as gh from \"./globalRequestHeaders.js\";\n\n/**\n * Download a file from an ArtifactDB REST API.\n *\n * @param {string} baseUrl - Base URL of the REST API.\n * @param {string} id - The full ArtifactDB identifier of the resource of interest.\n * @param {object} [options={}] - Optional parameters.\n * @param {?function} [options.downloadFun=null] - Function that accepts a single string containing a URL and returns either:\n *\n * - A string containing a path, for Node.js.\n * - An ArrayBuffer containing the contents of the file, for Node.js and browsers.\n *\n * Defaults to a call to `getFun`.\n * @param {?function} [options.getFun=null] - Function that accepts a single string containing a URL and returns a Response object.\n * Only used when `downloadFun` is not provided.\n * Defaults to the in-built `fetch` function with {@linkcode globalRequestHeaders}.\n *\n * @return {string|ArrayBuffer} Depending on `downloadFun`, either the contents of the file or a path to the file.\n * @async\n */\nexport async function getFile(baseUrl, id, { downloadFun = null, getFun = null } = {}) {\n    let out = baseUrl + \"/files/\" + encodeURIComponent(id);\n\n    if (downloadFun === null) {\n        if (getFun === null) {\n            getFun = gh.quickGet;\n        }\n        downloadFun = async x => {\n            let res = await getFun(x);\n            await err.checkHttpResponse(res, \"failed to retrieve file for '\" + id + \"'\");\n            return await res.arrayBuffer();\n        };\n    }\n\n    return await downloadFun(out);\n}\n","import * as err from \"./HttpError.js\";\nimport * as gh from \"./globalRequestHeaders.js\";\n\n/**\n * Get a file's metadata from an ArtifactDB REST API.\n *\n * @param {string} baseUrl - Base URL of the REST API.\n * @param {string} id - The full ArtifactDB identifier of the resource of interest.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.followLink=true] - Whether to follow links from redirection schemas.\n * @param {?function} [options.getFun=null] - Function that accepts a single string containing a URL and returns a Response object (or a promise resolving to a Response).\n * Defaults to the in-built `fetch` function with {@linkcode globalRequestHeaders}.\n *\n * @return {Object} Object containing the metadata for this file artifact.\n * This is guaranteed to contain at least the following properties:\n *\n * - `$schema`, a string specifying the schema for this metadata document.\n * - `path`, a string specifying the relative path of the file inside the project.\n * - `_extra`, an object containing extra metadata about this resource from the ArtifactDB instance.\n *\n * @async\n */\nexport async function getFileMetadata(baseUrl, id, { followLink = true, getFun = null } = {}) {\n    let out = baseUrl + \"/files/\" + encodeURIComponent(id) + \"/metadata\";\n    if (followLink) {\n        out += \"?follow_link=true\";\n    }\n\n    if (getFun === null) {\n        getFun = gh.quickGet;\n    }\n    let res = await getFun(out);\n    await err.checkHttpResponse(res, \"failed to retrieve metadata for '\" + id + \"'\");\n\n    return await res.json();\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as bakana from \"bakana\";\nimport * as adb from \"artifactdb\";\nimport * as utils from \"./utils.js\";\n\nconst baseUrl = \"https://collaboratordb.aaron-lun.workers.dev\";\n\nvar getFun = null;\nvar downloadFun = null;\n\nclass CollaboratordbNavigator {\n    #project;\n    #version;\n\n    constructor(project, version) {\n        this.#project = project;\n        this.#version = version;\n    }\n\n    async file(path) {\n        let id = adb.packId(this.#project, path, this.#version);\n        return await adb.getFile(baseUrl, id, { getFun: getFun, downloadFun: downloadFun });\n    }\n\n    async metadata(path) {\n        let id = adb.packId(this.#project, path, this.#version);\n        return await adb.getFileMetadata(baseUrl, id, { getFun: getFun });\n    }\n};\n\n/**\n * Dataset derived from a SummarizedExperiment in [CollaboratorDB](https://github.com/CollaboratorDB).\n * This extends the [AbstractArtifactdbDataset](https://kanaverse.github.io/bakana/AbstractArtifactdbDataset.html) class.\n */\nexport class CollaboratordbDataset extends bakana.AbstractArtifactdbDataset {\n    /** \n     * @param {?function} fun - Function that accepts a URL string and downloads the resource,\n     * returning a Uint8Array of the file contents.\n     * Alternatively, on Node.js, the function may return a string containing a file path to the downloaded resource.\n     * \n     * Alternatively `null`, to reset the function to its default value.\n     * See [`getFile`](https://artifactdb.github.io/artifactdb.js/global.html#getFile) for details.\n     * @return {?function} Previous setting of the download function.\n     */\n    static setDownloadFun(fun) {\n        let previous = downloadFun;\n        downloadFun = fun;\n        return previous;\n    }\n\n    /** \n     * @param {?function} fun - Function that accepts a URL string and performs a GET to return a Response object,\n     * see [`getFileMetadata`](https://artifactdb.github.io/artifactdb.js/global.html#getFileMetadata) for details.\n     * \n     * Alternatively `null`, to reset the function to its default value.\n     * @return {?function} Previous setting of the GET function.\n     */\n    static setGetFun(fun) {\n        let previous = getFun;\n        getFun = fun;\n        return previous;\n    }\n\n    /****************************************\n     ****************************************/\n\n    #id;\n    #unpacked;\n\n    /**\n     * @param {string} id - Identifier of a SummarizedExperiment in CollaboratorDB.\n     */\n    constructor(id) {\n        let unpacked = adb.unpackId(id);\n        super(unpacked.path, new CollaboratordbNavigator(unpacked.project, unpacked.version));\n        this.#id = id;\n        this.#unpacked = unpacked;\n        return;\n    }\n\n    /**\n     * @return {string} Format of this dataset class.\n     * @static\n     */\n    static format() {\n        return \"CollaboratorDB\";\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset.\n     */\n    abbreviate() {\n        return { \n            \"id\": this.#id, \n            \"options\": this.options()\n        };\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        const enc = new TextEncoder;\n        let buffer = enc.encode(this.#id);\n\n        // Storing it as a string in the buffer.\n        let output = {\n            type: \"id\",\n            file: new bakana.SimpleFile(buffer, { name: \"id\" })\n        };\n\n        return {\n            files: [ output ],\n            options: this.options()\n        }\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode CollaboratordbDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {CollaboratordbDataset} A new instance of this class.\n     * @static\n     */\n    static unserialize(files, options) {\n        let args = {};\n\n        // This should contain 'id'.\n        for (const x of files) {\n            const dec = new TextDecoder;\n            args[x.type] = dec.decode(x.file.buffer());\n        }\n\n        if (!(\"id\" in args)) {\n            throw new Error(\"expected a file of type 'id' when unserializing CollaboratorDB dataset\"); \n        }\n        return new CollaboratordbDataset(args.id, options);\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as afile from \"./abstract/file.js\";\nimport * as eutils from \"./utils/extract.js\";\nimport * as futils from \"./utils/features.js\";\n\n/**\n * Dataset in the 10X HDF5 feature-barcode matrix format, see [here](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/matrices) for details.\n */\nexport class TenxHdf5Dataset { \n    #h5_file;\n    #h5_path;\n    #h5_flush;\n\n    #raw_features;\n    #raw_cells;\n\n    #options;\n\n    #dump_summary(fun) {\n        let files = [{ type: \"h5\", file: fun(this.#h5_file) }];\n        let options = this.options();\n        return { files, options };\n    }\n\n    /**\n     * @param {SimpleFile|string|Uint8Array|File} h5File - Contents of a HDF5 file in the 10X feature-barcode format.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     */\n    constructor(h5File) {\n        if (h5File instanceof afile.SimpleFile) {\n            this.#h5_file = h5File;\n        } else {\n            this.#h5_file = new afile.SimpleFile(h5File);\n        }\n\n        this.#options = TenxHdf5Dataset.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode TenxHdf5Dataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            featureTypeRnaName: \"Gene Expression\", \n            featureTypeAdtName: \"Antibody Capture\", \n            featureTypeCrisprName: \"CRISPR Guide Capture\", \n            primaryRnaFeatureIdColumn: 0, \n            primaryAdtFeatureIdColumn: 0,\n            primaryCrisprFeatureIdColumn: 0\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode TenxHdf5Dataset#load load} (but not {@linkcode TenxHdf5Dataset#summary summary}).\n     * @param {?string} [options.featureTypeRnaName] - Name of the feature type for gene expression.\n     * If `null` or the string is not present among the feature types, no RNA features are to be loaded.\n     *\n     * If no feature type information is available in the dataset, all features are considered to be genes by default.\n     * This behavior can also be explicitly requested by setting this argument to the only non-`null` value among all `featureType*Name` parameters.\n     * @param {?string} [options.featureTypeAdtName] - Name of the feature type for ADTs.\n     * If `null` or the string is not present among the feature types, no ADT features are to be loaded.\n     *\n     * If no feature type information is available in the dataset and this argument is set to the only non-`null` value among all `featureType*Name` parameters, all features are considered to be ADTs.\n     * @param {?string} [options.featureTypeCrisprName] - Name of the feature type for CRISPR guides.\n     * If `null` or the string is not present among the feature types, no guides are to be loaded.\n     * \n     * If no feature type information is available in the dataset and this argument is set to the only non-`null` value among all `featureType*Name` parameters, all features are considered to be guides.\n     * @param {string|number} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     * @param {string|number} [options.primaryAdtFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the ADTs.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     * @param {string|number} [options.primaryCrisprFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the CRISPR guides.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    #instantiate() {\n        if (this.#h5_path !== null) {\n            return;\n        }\n\n        let info = scran.realizeFile(this.#h5_file.content());\n        this.#h5_path = info.path;\n        this.#h5_flush = info.flush;\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode TenxHdf5Dataset#load load} or {@linkcodeTenxHdf5Dataset#summary summary}. \n     */\n    clear() {\n        if (typeof this.#h5_flush == \"function\") {\n            this.#h5_flush();\n        }\n        this.#h5_flush = null;\n        this.#h5_path = null;\n\n        this.#raw_features = null;\n        this.#raw_cells = null;\n    }\n\n    /**\n     * @return {string} Format of this dataset class.\n     * @static\n     */\n    static format() {\n        return \"10X\";\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset,\n     * in a form that can be cheaply stringified.\n     */\n    abbreviate() {\n        return this.#dump_summary(f => { return { name: f.name(), size: f.size() }; });\n    }\n\n    #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n\n        this.#instantiate();\n        let handle = new scran.H5File(this.#h5_path);\n        if (!(\"matrix\" in handle.children) || handle.children[\"matrix\"] != \"Group\") {\n            throw new Error(\"expected a 'matrix' group at the top level of the file\");\n        }\n        let mhandle = handle.open(\"matrix\");\n\n        if (!(\"features\" in mhandle.children) || mhandle.children[\"features\"] != \"Group\") {\n            throw new Error(\"expected a 'matrix/features' group containing the feature annotation\");\n        }\n        let fhandle = mhandle.open(\"features\");\n\n        let ids = eutils.extractHDF5Strings(fhandle, \"id\");\n        if (ids == null) {\n            throw new Error(\"expected a 'matrix/features/id' string dataset containing the feature IDs\");\n        }\n        let feats = new bioc.DataFrame({ id: ids }); // build it piece-by-piece for a well-defined ordering.\n\n        let names = eutils.extractHDF5Strings(fhandle, \"name\");\n        if (names !== null) {\n            feats.$setColumn(\"name\", names);\n        }\n\n        let ftype = eutils.extractHDF5Strings(fhandle, \"feature_type\");\n        if (ftype !== null) {\n            feats.$setColumn(\"type\", ftype);\n        }\n\n        this.#raw_features = feats;\n        return;\n    }\n\n    #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n\n        this.#instantiate();\n        let details = scran.extractHDF5MatrixDetails(this.#h5_path, \"matrix\");\n        this.#raw_cells = new bioc.DataFrame({}, { numberOfRows: details.columns });\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode TenxHdf5Dataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     *   Unlike {@linkcode TenxMatrixMarketDataset#load load}, modality names are arbitrary.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     */\n    summary({ cache = false } = {}) {\n        this.#features();\n        this.#cells();\n\n        let output = {\n            \"modality_features\": futils.reportFeatures(this.#raw_features, \"type\"),\n            \"cells\": this.#raw_cells\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #feature_type_mapping() {\n        return {\n            RNA: this.#options.featureTypeRnaName, \n            ADT: this.#options.featureTypeAdtName,\n            CRISPR: this.#options.featureTypeCrisprName\n        };\n    }\n\n    #primary_mapping() {\n        return {\n            RNA: this.#options.primaryRnaFeatureIdColumn, \n            ADT: this.#options.primaryAdtFeatureIdColumn,\n            CRISPR: this.#options.primaryCrisprFeatureIdColumn\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode TenxHdf5Dataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode TenxHdf5Dataset#load load} but the order of values may be different.\n     */\n    previewPrimaryIds({ cache = false } = {}) {\n        this.#features();\n        let preview = futils.extractSplitPrimaryIds(this.#raw_features, \"type\", this.#feature_type_mapping(), \"RNA\", this.#primary_mapping());\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode TenxHdf5Dataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRISPR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode TenxHdf5Dataset#defaults defaults} or with {@linkcode TenxHdf5Dataset#setOptions setOptions}.\n     *\n     * If the feature annotation lacks information about the feature types, it is assumed that all features are genes, i.e., only the RNA modality is present.\n     */\n    load({ cache = false } = {}) {\n        this.#features();\n        this.#cells();\n\n        let loaded = scran.initializeSparseMatrixFromHDF5(this.#h5_path, \"matrix\"); // collection gets handled inside splitScranMatrixAndFeatures.\n\n        let output = futils.splitScranMatrixAndFeatures(loaded, this.#raw_features, \"type\", this.#feature_type_mapping(), \"RNA\");\n        output.cells = this.#raw_cells;\n\n        output.primary_ids = futils.extractPrimaryIds(output.features, this.#primary_mapping());\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        return this.#dump_summary(f => f);\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode TenxHdf5Dataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {TenxHdf5Dataset} A new instance of this class.\n     * @static\n     */\n    static async unserialize(files, options) {\n        if (files.length != 1 || files[0].type != \"h5\") {\n            throw new Error(\"expected exactly one file of type 'h5' for 10X HDF5 unserialization\");\n        }\n        let output = new TenxHdf5Dataset(files[0].file);\n        output.setOptions(output);\n        return output;\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as eutils from \"./utils/extract.js\";\nimport * as futils from \"./utils/features.js\";\nimport * as afile from \"./abstract/file.js\";\n\n/**\n * Any class that satisfies the ArtifactdbProjectNavigator contract, so called as it is intended to \"navigate\" an ArtifactDB project directory.\n * This should provide the following methods:\n * \n * - `metadata(p)`, a (possibly async) method that accepts a string `p` containing a relative path to a resource inside an ArtifactDB project directory,\n *   and returns an object containing the metadata for that object.\n *   Any redirections should be resolved by this method.\n *\n *   Note that {@linkplain AbstractArtifactdbDataset} will automatically cache the outputs of all `metadata()` calls between any invocations of {@linkcode AbstractArtifactdbDataset#clear clear},\n *   to improve efficiency when repeatedly accessing the same metadata.\n *   The same applies to {@linkplain AbstractArtifactdbResult}.\n * - `file(p)`, a (possibly async) method that accepts a string `p` containing a relative path inside a project directory and returns the contents of the file at that path.\n *   The return value should typically be a Uint8Array; on Node.js, methods may alternatively return a string containing a path to the file on the local file system.\n *   The method does not need to handle redirections from `p`.\n *\n * Optionally, the ArtifactdbProjectNavigator class may implement a `clear()` method to remove any cached content.\n * This will be called by {@linkcode AbstractArtifactdbDataset#clear AbstractArtifactdbDataset.clear} and  {@linkcode AbstractArtifactdbResult#clear AbstractArtifactdbResult.clear}.\n *\n * @typedef ArtifactdbProjectNavigator\n */\n\n/**************************\n ******* Internals ********\n **************************/\n\nasync function load_data_frame(info, navigator) {\n    if (typeof info == \"string\") {\n        info = await navigator.metadata(info);\n    }\n    let contents = await navigator.file(info.path);\n\n    let colnames;\n    let columns;\n    let rownames = null;\n\n    if (info[\"$schema\"].startsWith(\"csv_data_frame/\")) {\n        // TODO: replace with comservatory parser.\n        let parsed = await eutils.readTable2(contents, { delim: \",\" });\n        colnames = parsed.shift();\n\n        columns = new Array(colnames.length);\n        for (var i = 0; i < columns.length; i++) {\n            let current = [];\n            for (const x of parsed) {\n                current.push(x[i]);\n            }\n            columns[i] = current;\n        }\n\n        if (info.data_frame.row_names) {\n            rownames = columns.shift();\n            colnames.shift();\n        }\n\n        // Mutating the type... this doesn't quite handle NAs and NaNs properly, but whatever.\n        for (var i = 0; i < columns.length; i++) {\n            let type = info.data_frame.columns[i].type;\n            if (type == \"integer\") {\n                columns[i] = new Int32Array(columns[i]);\n            } else if (type == \"number\") {\n                columns[i] = new Float64Array(columns[i]);\n            } else if (type == \"boolean\") {\n                columns[i] = columns[i].map(x => x == \"true\");\n            }\n        }\n\n    } else if (info[\"$schema\"].startsWith(\"hdf5_data_frame/\")) {\n        let out = scran.realizeFile(contents);\n        try {\n            let handle = new scran.H5File(out.path);\n            let ghandle = handle.open(info.hdf5_data_frame.group);\n\n            colnames = ghandle.open(\"column_names\", { load: true }).values;\n            if (info.data_frame.row_names) {\n                rownames = ghandle.open(\"row_names\", { load: true }).values;\n            }\n\n            columns = [];\n            let chandle = ghandle.open(\"data\");\n            for (var i = 0; i < colnames.length; i++) {\n                if (!(String(i) in chandle.children)) {\n                    columns.push(null);\n                    continue;\n                }\n\n                let dhandle = chandle.open(String(i), { load: true });\n                let current = dhandle.values;\n\n                let type = info.data_frame.columns[i];\n                if (type == \"integer\") {\n                    if (current instanceof Float64Array || current instanceof Float32Array) {\n                        current = new Int32Array(current);\n                    }\n\n                } else if (type == \"number\") {\n                    if (!(current instanceof Float64Array) && !(current instanceof Float32Array)) {\n                        current = new Float64Array(current);\n                    }\n\n                } else if (type == \"boolean\") {\n                    let replacement = new Array(current.length);\n                    for (var i = 0; i < current.length; i++) {\n                        if (current[i] == -2147483648) {\n                            replacement[i] = null;\n                        } else {\n                            replacement[i] = current[i] != 0\n                        }\n                    }\n                    current = replacement;\n\n                } else if (type == \"string\" || type == \"date\") {\n                    if (\"missing-value-placeholder\" in dhandle.attributes) {\n                        let placeholder = dhandle.readAttribute(\"missing-value-placeholder\").values[0];\n                        for (var i = 0; i < current.length; i++) {\n                            if (current[i] == placeholder) {\n                                current[i] = null;\n                            }\n                        }\n                    }\n                }\n\n                columns.push(current);\n            }\n        } finally {\n            out.flush();\n        }\n\n    } else {\n        throw new Error(\"unknown data_frame schema type '\" + info[\"$schema\"] + \"'\");\n    }\n\n    let new_columns = {};\n    let new_colnames = [];\n    for (var i = 0; i < columns.length; i++) {\n        if (info.data_frame.columns[i].type === \"other\") {\n            let nest_meta = await navigator.metadata(info.data_frame.columns[i].resource.path);\n            try {\n                new_columns[colnames[i]] = await load_data_frame(nest_meta, navigator);\n                new_colnames.push(colnames[i]);\n            } catch (e) {\n                console.warn(e);\n            }\n        } else {\n            new_columns[colnames[i]] = columns[i];\n            new_colnames.push(colnames[i]);\n        }\n    }\n\n    return new bioc.DataFrame(new_columns, { \n        columnOrder: new_colnames, \n        rowNames: rownames, \n        numberOfRows: info.data_frame.dimensions[0] \n    });\n}\n\nconst main_experiment_name = \"\";\n\nasync function extract_all_features(path, navigator) {\n    let extract_features = async se_meta => {\n        if (\"row_data\" in se_meta.summarized_experiment) {\n            let row_path = se_meta.summarized_experiment.row_data.resource.path;\n            return await load_data_frame(row_path, navigator);\n        } else {\n            return new bioc.DataFrame({}, { numberOfRows: se_meta.summarized_experiment.dimensions[0] });\n        }\n    };\n\n    let full_meta = await navigator.metadata(path);\n    let output = {};\n    output[main_experiment_name] = await extract_features(full_meta);\n\n    if (\"single_cell_experiment\" in full_meta) {\n        for (const alt of full_meta.single_cell_experiment.alternative_experiments) {\n            try {\n                let alt_meta = await navigator.metadata(alt.resource.path);\n                output[alt.name] = await extract_features(alt_meta);\n            } catch (e) {\n                console.warn(\"failed to extract features for alternative Experiment '\" + alt.name + \"'; \" + e.message);\n            }\n        }\n    }\n\n    return output;\n}\n\nasync function extract_all_assay_names(path, navigator) {\n    let extract_assay_names = se_meta => {\n        let output = [];\n        for (const ass of se_meta.summarized_experiment.assays) {\n            output.push(ass.name);\n        }\n        return output;\n    };\n\n    let full_meta = await navigator.metadata(path);\n    let assays = {};\n    assays[main_experiment_name] = extract_assay_names(full_meta);\n\n    if (\"single_cell_experiment\" in full_meta) {\n        for (const alt of full_meta.single_cell_experiment.alternative_experiments) {\n            try {\n                let alt_meta = await navigator.metadata(alt.resource.path);\n                assays[alt.name] = extract_assay_names(alt_meta);\n            } catch (e) {\n                console.warn(\"failed to extract features for alternative Experiment '\" + alt.name + \"'; \" + e.message);\n            }\n        }\n    }\n\n    return assays;\n}\n\n// This specifically loads the log-counts created by the dumper.\n// TODO: replace this with chihaya.js.\nasync function extract_logcounts(handle, navigator) {\n    if (handle.readAttribute(\"delayed_type\").values[0] !== \"operation\") {\n        return null;\n    }\n    if (handle.readAttribute(\"delayed_operation\").values[0] !== \"unary arithmetic\") {\n        return null;\n    }\n    if (Math.abs(handle.open(\"value\", { load: true }).values[0] - Math.log(2)) > 0.00000001) {\n        return null;\n    }\n    if (handle.open(\"method\", { load: true }).values[0] !== \"/\") {\n        return null;\n    }\n    if (handle.open(\"side\", { load: true }).values[0] !== \"right\") {\n        return null;\n    }\n\n    let ghandle2 = handle.open(\"seed\");\n    if (ghandle2.readAttribute(\"delayed_type\").values[0] !== \"operation\") {\n        return null;\n    }\n    if (ghandle2.readAttribute(\"delayed_operation\").values[0] !== \"unary math\") {\n        return null;\n    }\n    if (ghandle2.open(\"method\", { load: true }).values[0] !== \"log1p\") {\n        return null;\n    }\n\n    let ghandle3 = ghandle2.open(\"seed\");\n    if (ghandle3.readAttribute(\"delayed_type\").values[0] !== \"operation\") {\n        return null;\n    }\n    if (ghandle3.readAttribute(\"delayed_operation\").values[0] !== \"unary arithmetic\") {\n        return null;\n    }\n    if (ghandle3.open(\"method\", { load: true }).values[0] !== \"/\") {\n        return null;\n    }\n    if (ghandle3.open(\"side\", { load: true }).values[0] !== \"right\") {\n        return null;\n    }\n    if (ghandle3.open(\"along\", { load: true }).values[0] !== 1) {\n        return null;\n    }\n    let sf = ghandle3.open(\"value\", { load: true }).values;\n\n    let ahandle = ghandle3.open(\"seed\");\n    if (ahandle.readAttribute(\"delayed_type\").values[0] !== \"array\") {\n        return null;\n    }\n    if (ahandle.readAttribute(\"delayed_array\").values[0] !== \"custom alabaster local array\") {\n        return null;\n    }\n    let path = ahandle.open(\"path\", { load: true }).values[0];\n\n    let mat;\n    let output = {};\n    try {\n        mat = await extract_assay_raw(path, navigator, false); // don't force it to be integer, but we don't mind if it is.\n        output.matrix = scran.logNormCounts(mat.matrix, { sizeFactors: sf, center: false });\n        output.row_ids = mat.row_ids;\n    } finally {\n        scran.free(mat.matrix);\n    }\n                \n    return output;\n}\n\nasync function extract_assay(meta, assay, navigator, forceInteger) {\n    if (typeof assay == \"string\") {\n        var counter = 0;\n        for (const ass of meta.summarized_experiment.assays) {\n            if (ass.name == assay) {\n                assay = counter;\n                break;\n            }\n            counter++;\n        }\n        if (counter == meta.summarized_experiment.assays.length) {\n            throw new Error(\"assay '\" + assay + \"' not found\");\n        }\n    } else {\n        if (assay >= meta.summarized_experiment.assays.length) {\n            throw new Error(\"assay \" + String(assay) + \" out of range\");\n        }\n    }\n\n    let asspath = meta.summarized_experiment.assays[assay].resource.path;\n    return extract_assay_raw(asspath, navigator, forceInteger);\n}\n\nasync function extract_assay_raw(asspath, navigator, forceInteger) {\n    let assmeta = await navigator.metadata(asspath);\n    let contents = await navigator.file(assmeta.path);\n    let output;\n\n    let schema = assmeta[\"$schema\"];\n    let is_dense = schema.startsWith(\"hdf5_dense_array/\");\n    let is_sparse = schema.startsWith(\"hdf5_sparse_matrix/\");\n\n    if (is_dense || is_sparse) {\n        let name = (is_sparse ?  assmeta.hdf5_sparse_matrix.group : assmeta.hdf5_dense_array.dataset);\n        let stuff = scran.realizeFile(contents);\n        try {\n            output = scran.initializeSparseMatrixFromHDF5(stuff.path, name, { forceInteger });\n        } finally {\n            stuff.flush();\n        }\n\n    } else if (assmeta[\"$schema\"].startsWith(\"hdf5_delayed_array/\")) {\n        let stuff = scran.realizeFile(contents);\n        try {\n            let fhandle = new scran.H5File(stuff.path);\n            let ghandle = fhandle.open(assmeta.hdf5_delayed_array.group);\n\n            // TODO: replace with calls to chihaya.js.\n            output = await extract_logcounts(ghandle, navigator);\n            if (output == null) {\n                throw new Error(\"currently only supporting bakana-generated log-counts for delayed arrays\");\n            }\n        } finally {\n            stuff.flush();\n        }\n\n    } else {\n        throw new Error(\"array schema '\" + assmeta[\"$schema\"] + \"' is currently not supported\");\n    }\n\n    return output;\n}\n\nasync function extract_other_data(other_path, navigator) {\n    let othermeta = await navigator.metadata(other_path);\n    if (!othermeta[\"$schema\"].startsWith(\"json_simple_list/\")) {\n        throw new Error(\"currently only support JSON-formatted lists in the 'other_data'\");\n    }\n\n    let contents = await navigator.file(othermeta.path);\n    let ofile = new afile.SimpleFile(contents, { name: \"list.json\" });\n    let unpacked = eutils.unpackText(ofile.buffer(), { compression: (othermeta.json_simple_list.compression == \"gzip\" ? \"gz\" : \"none\") });\n    let parsed = JSON.parse(unpacked);\n    return extract_list_data_internal(parsed);\n}\n\nfunction extract_list_data_internal(obj) {\n    if (!(\"type\" in obj)) {\n        throw new Error(\"non-standard JSON object for 'json_simple_list' schema\");\n    }\n\n    if (obj.type == \"number\") {\n        if (obj.values instanceof Array) {\n            let output = new Float64Array(obj.values.length);\n            obj.values.forEach((x, i) => {\n                output[i] = (x === null ? Number.NaN : x) \n            });\n            return output;\n        } else {\n            return (obj.values == null ? Number.NaN : obj.values);\n        }\n\n    } else if (obj.type == \"integer\") {\n        if (obj.values instanceof Array) {\n            let output = new Int32Array(obj.values.length);\n            obj.values.forEach((x, i) => {\n                output[i] = (x === null ? -2147483648 : x) \n            });\n            return output;\n        } else {\n            return obj.values;\n        }\n\n    } else if (obj.type == \"boolean\" || obj.type == \"string\") {\n        return obj.values;\n\n    } else if (obj.type == \"list\") {\n        if (\"names\" in obj) {\n            let output = {};\n            for (var i = 0; i < obj.values.length; i++) {\n                output[obj.names[i]] = extract_list_data_internal(obj.values[i]);\n            }\n            return output;\n        } else {\n            let output = [];\n            for (var i = 0; i < obj.values.length; i++) {\n                output.push(extract_list_data_internal(obj.values[i]));\n            }\n            return output;\n        }\n\n    } else if (obj.type == \"nothing\") {\n        return null;\n\n    } else {\n        console.warn(\"JSON simple list containing type '\" + obj.type + \"' is not yet supported\");\n        return null;\n    }\n}\n\n/***********************\n ******* Cacher ********\n ***********************/\n\n// As we'll be using the metadata often, we cache it at this level. This\n// removes the burden of caching on the implementation of the navigator. \nclass MetadataCacheWrapper {\n    #navigator;\n    #metadata_cache;\n\n    constructor(nav) {\n        this.#navigator = nav;\n        this.#metadata_cache = {};\n    }\n\n    clear() {\n        this.#metadata_cache = {};\n        if (\"clear\" in this.#navigator) {\n            this.#navigator.clear();\n        }\n    }\n\n    async metadata(path) {\n        if (path in this.#metadata_cache) {\n            return this.#metadata_cache[path];\n        } else {\n            let content = await this.#navigator.metadata(path);\n            this.#metadata_cache[path] = content;\n            return content;\n        }\n    }\n\n    file(path) {\n        return this.#navigator.file(path);\n    }\n};\n\n/************************\n ******* Dataset ********\n ************************/\n\n/**\n * Dataset stored as a SummarizedExperiment in the **ArtifactDB** format.\n * This is intended as a virtual base class; applications should define subclasses that are tied to a specific {@linkplain ArtifactdbProjectNavigator} class.\n * Subclasses should define `abbreviate()` and `serialize()` methods, as well as the static `format()` and `unserialize()` methods - \n * see the [Dataset contract](https://github.com/LTLA/bakana/blob/master/docs/related/custom_readers.md) for more details.\n */\nexport class AbstractArtifactdbDataset {\n    #path;\n    #navigator;\n\n    #raw_features;\n    #raw_cells;\n\n    #options;\n\n    /**\n     * @param {string} path - Path to the SummarizedExperiment in the ArtifactDB project directory.\n     * @param {ArtifactdbProjectNavigator} navigator - A navigator object that describes how to obtain the various assets from the project directory containing `path`.\n     */\n    constructor(path, navigator) {\n        this.#path = path;\n        this.#navigator = new MetadataCacheWrapper(navigator);\n        this.#options = AbstractArtifactdbDataset.defaults();\n\n        // Don't call this.clear() here. We don't want to clear the navigator's\n        // cache at this point, as the navigator might contain some cached\n        // values when passed to the constructor. We should respect any caches\n        // until we're specifically told to discard it with clear() or cache =\n        // false in load() or summary().\n        this.#reset_local_caches();\n        return;\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode AbstractArtifactdbDataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            rnaCountAssay: 0, \n            adtCountAssay: 0, \n            crisprCountAssay: 0,\n            rnaExperiment: \"\", \n            adtExperiment: \"Antibody Capture\", \n            crisprExperiment: \"CRISPR Guide Capture\",\n            primaryRnaFeatureIdColumn: null, \n            primaryAdtFeatureIdColumn: null,\n            primaryCrisprFeatureIdColumn: null \n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode AbstractArtifactdbDataset#load load} (but not {@linkcode AbstractArtifactdbDataset#summary summary}).\n     * @param {string|number} [options.rnaCountAssay] - Name or index of the assay containing the RNA count matrix.\n     * @param {string|number} [options.adtCountAssay] - Name or index of the assay containing the ADT count matrix.\n     * @param {string|number} [options.crisprCountAssay] - Name or index of the assay containing the CRISPR count matrix.\n     * @param {?(string|number)} [options.rnaExperiment] - Name or index of the alternative experiment containing gene expression data.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and no RNA data is assumed to be present.\n     * If `i` is an empty string, the main experiment is assumed to contain the gene expression data.\n     * @param {?(string|number)} [options.adtExperiment] - Name or index of the alternative experiment containing ADT data.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and no ADTs are assumed to be present.\n     * If `i` is an empty string, the main experiment is assumed to contain the ADT data.\n     * @param {?(string|number)} [options.crisprExperiment] - Name or index of the alternative experiment containing CRISPR guide data.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and no CRISPR guides are assumed to be present.\n     * If `i` is an empty string, the main experiment is assumed to contain the guide data.\n     * @param {?(string|number)} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is defined as the existing row names.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryAdtFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the ADTs.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is defined as the existing row names.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryCrisprFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the CRISPR guides.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the existing row names (if they exist) are used as the primary identifier.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    #reset_local_caches() {\n        this.#raw_features = null;\n        this.#raw_cells = null;\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode AbstractArtifactdbDataset#load load} or {@linkcode AbstractArtifactdbDataset#summary summary}.\n     */\n    clear() {\n        this.#reset_local_caches();\n        this.#navigator.clear();\n    }\n\n    async #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n        this.#raw_features = await extract_all_features(this.#path, this.#navigator);\n        return;\n    }\n\n    async #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n        let full_meta = await this.#navigator.metadata(this.#path);\n        let col_path = full_meta.summarized_experiment.column_data.resource.path;\n        this.#raw_cells = await load_data_frame(col_path, this.#navigator);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode AbstractArtifactdbDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `modality_assay_names`: an object where each key is a modality name and each value is an Array containing the names of available assays for that modality.\n     *    Unnamed assays are represented as `null` names.\n     *\n     * @async\n     */\n    async summary({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n\n        let output = {\n            modality_features: this.#raw_features,\n            cells: this.#raw_cells,\n            modality_assay_names: await extract_all_assay_names(this.#path, this.#navigator)\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #primary_mapping() {\n        return {\n            RNA: this.#options.primaryRnaFeatureIdColumn, \n            ADT: this.#options.primaryAdtFeatureIdColumn,\n            CRISPR: this.#options.primaryCrisprFeatureIdColumn\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode AbstractArtifactdbDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode AbstractArtifactdbDataset#load load} but the order of values may be different.\n     *\n     * @async\n     */\n    async previewPrimaryIds({ cache = false } = {}) {\n        await this.#features();\n\n        let fmapping = {\n            RNA: this.#options.rnaExperiment, \n            ADT: this.#options.adtExperiment, \n            CRISPR: this.#options.crisprExperiment \n        };\n\n        let preview = futils.extractRemappedPrimaryIds(this.#raw_features, fmapping, this.#primary_mapping());\n\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode AbstractArtifactdbDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRISPR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode AbstractArtifactdbDataset#defaults defaults} or with {@linkcode AbstractArtifactdbDataset#setOptions setOptions}.\n     *\n     * @async\n     */\n    async load({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n\n        let output = { \n            matrix: new scran.MultiMatrix,\n            row_ids: {},\n            features: {},\n            cells: this.#raw_cells\n        };\n\n        let mapping = { \n            RNA: { exp: this.#options.rnaExperiment, assay: this.#options.rnaCountAssay },\n            ADT: { exp: this.#options.adtExperiment, assay: this.#options.adtCountAssay },\n            CRISPR: { exp: this.#options.crisprExperiment, assay: this.#options.crisprCountAssay }\n        };\n\n        let full_meta = await this.#navigator.metadata(this.#path);\n        let altmap = {};\n        let alts = [];\n        if (\"single_cell_experiment\" in full_meta) {\n            alts = full_meta.single_cell_experiment.alternative_experiments;\n            for (const alt of alts) {\n                altmap[alt.name] = alt.resource.path;\n            }\n        }\n\n        try {\n            for (const [k, v] of Object.entries(mapping)) {\n                if (v.exp === null) {\n                    continue;\n                }\n\n                let meta = null;\n                let name = v.exp;\n                if (typeof v.exp == \"string\") {\n                    if (v.exp === \"\") {\n                        meta = full_meta;\n                    } else {\n                        if (!(v.exp in altmap)) {\n                            continue;\n                        }\n                        meta = await this.#navigator.metadata(altmap[v.exp]);\n                    }\n                } else {\n                    if (v.exp >= alts.length) {\n                        continue;\n                    }\n                    name = alts[v.exp].name;\n                    meta = await this.#navigator.metadata(alts[v.exp].resource.path);\n                }\n\n                let loaded = await extract_assay(meta, v.assay, this.#navigator, true);\n                output.matrix.add(k, loaded.matrix);\n                let out_ids = loaded.row_ids;\n                output.row_ids[k] = out_ids;\n                output.features[k] = bioc.SLICE(this.#raw_features[name], out_ids);\n            }\n\n            output.primary_ids = futils.extractPrimaryIds(output.features, this.#primary_mapping());\n\n        } catch (e) {\n            scran.free(output.matrix);\n            throw e;\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n}\n\nexport const ArtifactDbSummarizedExperimentDatasetBase = AbstractArtifactdbDataset;\n\n/***********************\n ******* Result ********\n ***********************/\n\n/**\n * Pre-computed analysis results stored as a SummarizedExperiment object (or one of its subclasses) in the **ArtifactDB** format.\n * This is intended as a virtual base class; applications should define subclasses that are tied to a specific {@linkplain ArtifactdbProjectNavigator} class.\n */\nexport class AbstractArtifactdbResult {\n    #path;\n    #navigator;\n\n    #raw_features;\n    #raw_cells;\n    #raw_other;\n\n    #options;\n\n    /**\n     * @param {string} path - Path to the SummarizedExperiment in the ArtifactDB project directory.\n     * @param {ArtifactdbProjectNavigator} navigator - A navigator object that describes how to obtain the various assets from the project directory containing `path`.\n     */\n    constructor(path, navigator) {\n        this.#path = path;\n        this.#navigator = new MetadataCacheWrapper(navigator);\n        this.#options = AbstractArtifactdbResult.defaults();\n\n        // Don't call clear() here, see comments above in the Dataset constructor.\n        this.#reset_local_caches();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode AbstractArtifactdbResults#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return { \n            primaryAssay: 0,\n            isPrimaryNormalized: true,\n            reducedDimensionNames: null\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode AbstractArtifactdbResult#load load} (but not {@linkcode AbstractArtifactdbResult#summary summary}.\n     * @param {object|string|number} [options.primaryAssay] - Assay containing the relevant data for each modality.\n     *\n     * - If a string, this is used as the name of the assay across all modalities.\n     * - If a number, this is used as the index of the assay across all modalities.\n     * - If any object, the key should be the name of a modality and the value may be either a string or number specifying the assay to use for that modality.\n     *   Modalities absent from this object will not be loaded.\n     * @param {object|boolean} [options.isPrimaryNormalized] - Whether or not the assay for a particular modality has already been normalized.\n     *\n     * - If a boolean, this is used to indicate normalization status of assays across all modalities.\n     *   If `false`, that modality's assay is assumed to contain count data and is subjected to library size normalization. \n     * - If any object, the key should be the name of a modality and the value should be a boolean indicating whether that modality's assay has been normalized.\n     *   Modalities absent from this object are assumed to have been normalized.\n     * @param {?Array} [options.reducedDimensionNames] - Array of names of the reduced dimensions to load.\n     * If `null`, all reduced dimensions found in the file are loaded.\n     */\n    setOptions(options) {\n        // Cloning to avoid pass-by-reference links.\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = bioc.CLONE(v);\n        }\n    }\n\n    #reset_local_caches() {\n        this.#raw_features = null;\n        this.#raw_cells = null;\n        this.#raw_other = null;\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode AbstractArtifactdbResult#load load} or {@linkcode AbstractArtifactdbResult#summary summary}.\n     */\n    clear() {\n        this.#reset_local_caches();\n        this.#navigator.clear();\n    }\n\n    async #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n        this.#raw_features = await extract_all_features(this.#path, this.#navigator);\n        return;\n    }\n\n    async #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n        let full_meta = await this.#navigator.metadata(this.#path);\n        let col_path = full_meta.summarized_experiment.column_data.resource.path;\n        this.#raw_cells = await load_data_frame(col_path, this.#navigator);\n        return;\n    }\n\n    async #other() {\n        if (this.#raw_other !== null) {\n            return;\n        }\n\n        let full_meta = await this.#navigator.metadata(this.#path);\n        if (\"other_data\" in full_meta.summarized_experiment) {\n            let other_path = full_meta.summarized_experiment.other_data.resource.path;\n            this.#raw_other = await extract_other_data(other_path, this.#navigator);\n        } else {\n            this.#raw_other = {};\n        }\n        return;\n    }\n\n    async #get_all_reddim_names(rd_meta, store) {\n        for (const red of rd_meta) {\n            let redmeta = await this.#navigator.metadata(red.resource.path);\n            if (redmeta[\"$schema\"].startsWith(\"hdf5_dense_array/\") && redmeta.array.dimensions.length == 2) {\n                store.push(red.name);\n            }\n        }\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode AbstractArtifactdbResult#load load}.\n     * If `true`, users should consider calling {@linkcode AbstractArtifactdbResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `modality_assay_names`: an object where each key is a modality name and each value is an Array containing the names of available assays for that modality.\n     *    Unnamed assays are represented as `null` names.\n     * - `reduced_dimension_names`: an Array of strings containing names of dimensionality reduction results.\n     * - `other_metadata`: an object containing other metadata.\n     *\n     * @async \n     */\n    async summary({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n        await this.#other();\n\n        let output = {\n            modality_features: this.#raw_features,\n            cells: this.#raw_cells,\n            modality_assay_names: await extract_all_assay_names(this.#path, this.#navigator),\n            reduced_dimension_names: [],\n            other_metadata: this.#raw_other\n        };\n\n        let full_meta = await this.#navigator.metadata(this.#path);\n        if (\"single_cell_experiment\" in full_meta) {\n            let reddim_meta = full_meta.single_cell_experiment.reduced_dimensions;\n            await this.#get_all_reddim_names(reddim_meta, output.reduced_dimension_names);\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode AbstractArtifactdbResult#summary summary}.\n     * If `true`, users should consider calling {@linkcode AbstractArtifactdbResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `reduced_dimensions`: an object containing the dimensionality reduction results.\n     *   Each value is an array of arrays, where each inner array contains the coordinates for one dimension.\n     * - `other_metadata`: an object containing other metadata.\n     *\n     * @async\n     */\n    async load({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n        await this.#other();\n\n        let full_meta = await this.#navigator.metadata(this.#path);\n\n        let output = { \n            matrix: new scran.MultiMatrix,\n            features: {},\n            cells: this.#raw_cells,\n            reduced_dimensions: {},\n            other_metadata: this.#raw_other\n        };\n\n        // Fetch the reduced dimensions first.\n        {\n            let reddims = this.#options.reducedDimensionNames;\n            let reddim_meta = full_meta.single_cell_experiment.reduced_dimensions;\n\n            if (reddims == null) {\n                reddims = [];\n                await this.#get_all_reddim_names(reddim_meta, reddims);\n            }\n\n            if (reddims.length > 0) {\n                let redmap = {};\n                for (const red of reddim_meta) {\n                    redmap[red.name] = red.resource.path;\n                }\n\n                for (const k of reddims) {\n                    let redmeta = await this.#navigator.metadata(redmap[k]); // this should be only HDF5 dense matrices.\n                    let dims = redmeta.array.dimensions;\n                    let redcontents = await this.#navigator.file(redmeta.path); \n\n                    let realized = scran.realizeFile(redcontents);\n                    let acquired = [];\n                    try {\n                        let fhandle = new scran.H5File(realized.path);\n                        let dhandle = fhandle.open(redmeta.hdf5_dense_array.dataset, { load: true });\n                        let contents = dhandle.values;\n                        for (var d = 0; d < dims[1]; d++) {\n                            acquired.push(contents.slice(d * dims[0], (d + 1) * dims[0]));\n                        }\n                    } finally {\n                        realized.flush();\n                    }\n\n                    output.reduced_dimensions[k] = acquired;\n                }\n            }\n        }\n\n        // Now fetching the assay matrix.\n        {\n            let altmap = {};\n            if (\"single_cell_experiment\" in full_meta) {\n                for (const alt of full_meta.single_cell_experiment.alternative_experiments) {\n                    altmap[alt.name] = alt.resource.path;\n                }\n            }\n\n            try {\n                for (const [k, v] of Object.entries(this.#raw_features)) {\n                    let curassay = this.#options.primaryAssay;\n                    if (typeof curassay == \"object\") {\n                        if (k in curassay) {\n                            curassay = curassay[k];\n                        } else {\n                            continue;\n                        }\n                    }\n\n                    let curnormalized = this.#options.isPrimaryNormalized;\n                    if (typeof curnormalized == \"object\") {\n                        if (k in curnormalized) {\n                            curnormalized = curnormalized[k];\n                        } else {\n                            curnormalized = true;\n                        }\n                    }\n\n                    let meta;\n                    if (k === \"\") {\n                        meta = full_meta;\n                    } else {\n                        meta = await this.#navigator.metadata(altmap[k]);\n                    }\n\n                    let loaded = await extract_assay(meta, curassay, this.#navigator, !curnormalized);\n                    output.matrix.add(k, loaded.matrix);\n\n                    if (!curnormalized) {\n                        let normed = scran.logNormCounts(loaded.matrix, { allowZeros: true });\n                        output.matrix.add(k, normed);\n                    }\n\n                    if (loaded.row_ids !== null) {\n                        output.features[k] = bioc.SLICE(this.#raw_features[k], loaded.row_ids);\n                    } else {\n                        output.features[k] = this.#raw_features[k];\n                    }\n                }\n\n            } catch (e) {\n                scran.free(output.matrix);\n                throw e;\n            }\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n}\n\nexport const ArtifactDbSummarizedExperimentResultBase = AbstractArtifactdbResult;\n","export class SimpleFile {\n    #mode;\n    #buffer;\n    #file;\n    #name;\n\n    constructor(x, { name = null } = {}) {\n        if (x instanceof File) {\n            this.#mode = \"file\";\n            this.#file = x;\n            if (name === null) {\n                name = x.name;\n            }\n            this.#name = name;\n        } else if (x instanceof Uint8Array) {\n            this.#mode = \"buffer\";\n            this.#buffer = x; \n            if (name === null) {\n                throw new Error(\"'name' must be provided for Uint8Array inputs in SimpleFile constructor\");\n            }\n            this.#name = name;\n        } else {\n            throw new Error(\"unknown type '\" + typeof(x) + \"' for SimpleFile constructor\");\n        }\n    }\n\n    buffer({ copy = false } = {}) {\n        if (this.#mode == \"file\") {\n            let reader = new FileReaderSync();\n            let b = reader.readAsArrayBuffer(this.#file);\n            return new Uint8Array(b);\n        } else {\n            if (copy) {\n                return this.#buffer.slice();\n            } else {\n                return this.#buffer;\n            }\n        }\n    }\n\n    size() {\n        if (this.#mode == \"file\") {\n            return this.#file.size;\n        } else {\n            return this.#buffer.length;\n        }\n    }\n\n    name() {\n        return this.#name;\n    }\n\n    content({ copy = false } = {}) {\n        return this.buffer({ copy: copy });\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as afile from \"./abstract/file.js\";\nimport * as eutils from \"./utils/extract.js\";\nimport * as futils from \"./utils/features.js\";\n\n/**\n * Dataset in the 10X Matrix Market format, see [here](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/advanced/matrices) for details.\n */\nexport class TenxMatrixMarketDataset {\n    #matrix_file;\n    #feature_file;\n    #barcode_file;\n\n    #dimensions;\n    #raw_features;\n    #raw_cells;\n\n    #options;\n\n    #dump_summary(fun) {\n        let files = [{ type: \"mtx\", file: fun(this.#matrix_file) }];\n\n        if (this.#feature_file !== null) {\n            files.push({ type: \"genes\", file: fun(this.#feature_file) });\n        }\n\n        if (this.#barcode_file !== null) {\n            files.push({ type: \"annotations\", file: fun(this.#barcode_file) });\n        }\n\n        let options = this.options(); \n        return { files, options };\n    }\n\n    /**\n     * @param {SimpleFile|string|Uint8Array|File} matrixFile - A Matrix Market file.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     * @param {?(SimpleFile|string|Uint8Array|File)} featureFile - Contents of a feature annotation file.\n     * If `null`, it is assumed that no file was available.\n     * @param {?(SimpleFile|string|Uint8Array|File)} barcodeFile - Contents of a barcode annotation file.\n     * If `null`, it is assumed that no file was available.\n     */\n    constructor(matrixFile, featureFile, barcodeFile, { \n        featureTypeRnaName = \"Gene Expression\", \n        featureTypeAdtName = \"Antibody Capture\", \n        featureTypeCrisprName = \"CRISPR Guide Capture\", \n        primaryRnaFeatureIdColumn = 0, \n        primaryAdtFeatureIdColumn = 0,\n        primaryCrisprFeatureIdColumn = 0\n    } = {}) {\n        if (matrixFile instanceof afile.SimpleFile) {\n            this.#matrix_file = matrixFile;\n        } else {\n            this.#matrix_file = new afile.SimpleFile(matrixFile);\n        }\n\n        if (featureFile instanceof afile.SimpleFile || featureFile == null) {\n            this.#feature_file = featureFile;\n        } else {\n            this.#feature_file = new afile.SimpleFile(featureFile);\n        }\n\n        if (barcodeFile instanceof afile.SimpleFile || barcodeFile == null) {\n            this.#barcode_file = barcodeFile;\n        } else {\n            this.#barcode_file = new afile.SimpleFile(barcodeFile);\n        }\n\n        this.#options = TenxMatrixMarketDataset.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode TenxMatrixMarketDataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            featureTypeRnaName: \"Gene Expression\", \n            featureTypeAdtName: \"Antibody Capture\", \n            featureTypeCrisprName: \"CRISPR Guide Capture\", \n            primaryRnaFeatureIdColumn: 0, \n            primaryAdtFeatureIdColumn: 0,\n            primaryCrisprFeatureIdColumn: 0\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode TenxMatrixMarketDataset#load load} (but not {@linkcode TenxMatrixMarketDataset#summary summary}).\n     * @param {?string} [options.featureTypeRnaName] - Name of the feature type for gene expression.\n     * If `null` or the string is not present among the feature types, no RNA features are to be loaded.\n     *\n     * If no feature type information is available in the dataset, all features are considered to be genes by default.\n     * This behavior can be explicitly requested by setting this argument to the only non-`null` value among all `featureType*Name` parameters.\n     * @param {?string} [options.featureTypeAdtName] - Name of the feature type for ADTs.\n     * If `null` or the string is not present among the feature types, no ADT features are to be loaded.\n     *\n     * If no feature type information is available in the dataset and this argument is set to the only non-`null` value among all `featureType*Name` parameters, all features are considered to be ADTs.\n     * @param {?string} [options.featureTypeCrisprName] - Name of the feature type for CRISPR guides.\n     * If `null` or the string is not present among the feature types, no guides are to be loaded.\n     *\n     * If no feature type information is available in the dataset and this argument is set to the only non-`null` value among all `featureType*Name` parameters, all features are considered to be guides.\n     * @param {string|number} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     * @param {string|number} [options.primaryAdtFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the ADTs.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     * @param {string|number} [options.primaryCrisprFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the CRISPR guides.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode TenxMatrixMarketDataset#load load} or {@linkcodeTenxMatrixMarketDataset#summary summary}. \n     */\n    clear() {\n        this.#dimensions = null;\n        this.#raw_features = null;\n        this.#raw_cells = null;\n    }\n\n    /**\n     * @return {string} Format of this dataset class.\n     * @static\n     */\n    static format() {\n        return \"MatrixMarket\";\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset,\n     * in a form that can be cheaply stringified.\n     */\n    abbreviate(args) {\n        return this.#dump_summary(f => { return { name: f.name(), size: f.size() }; });\n    }\n\n    #fetch_dimensions() {\n        if (this.#dimensions !== null) {\n            return;\n        }\n        var is_gz = this.#matrix_file.name().endsWith(\".gz\");\n        let headers = scran.extractMatrixMarketDimensions(this.#matrix_file.content(), { \"compressed\": is_gz });\n        this.#dimensions = [headers.rows, headers.columns];\n    }\n\n    async #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n\n        this.#fetch_dimensions();\n        let NR = this.#dimensions[0];\n        if (this.#feature_file == null) {\n            this.#raw_features = new bioc.DataFrame({}, { numberOfRows: NR });\n            return;\n        }\n\n        let fname = this.#feature_file.name();\n        var is_gz = fname.endsWith(\".gz\");\n        let parsed = await eutils.readTable2(this.#feature_file.content(), { compression: (is_gz ? \"gz\" : \"none\") });\n\n        if (parsed.length == NR + 1) {\n            // If it seems to have a header, we just use that directly.\n            let output = {};\n            let headers = parsed.shift();\n            headers.forEach((x, i) => {\n                output[x] = parsed.map(y => y[i]);\n            });\n            this.#raw_features = output;\n            return;\n        }\n\n        // Otherwise, we assume it's standard 10X CellRanger output, without a header.\n        if (parsed.length !== NR) {\n            throw new Error(\"number of matrix rows is not equal to the number of rows in '\" + fname + \"'\");\n        } \n\n        var ids = [], symb = [];\n        parsed.forEach(x => {\n            ids.push(x[0]);\n            symb.push(x[1]);\n        });\n\n        let output = new bioc.DataFrame({}, { numberOfRows: NR }); // build it piece-by-piece for a well-defined order.\n        output.$setColumn(\"id\", ids);\n        output.$setColumn(\"name\", symb);\n\n        if (parsed[0].length > 2) {\n            let types = [];\n            parsed.forEach(x => { types.push(x[2]); });\n            output.$setColumn(\"type\", types);\n        }\n\n        this.#raw_features = output;\n        return;\n    }\n\n    async #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n\n        this.#fetch_dimensions();\n        if (this.#barcode_file == null) {\n            this.#raw_cells = new bioc.DataFrame({}, { numberOfRows: this.#dimensions[1] });\n            return;\n        }\n\n        let bname = this.#barcode_file.name();\n        var is_gz = bname.endsWith(\".gz\");\n        let parsed = await eutils.readTable2(this.#barcode_file.content(), { compression: (is_gz ? \"gz\" : \"none\") });\n\n        // Check if a header is present or not. Standard 10X output doesn't have a \n        // header but we'd like to support some kind of customization.\n        let diff = this.#dimensions[1] - parsed.length;\n        let headers;\n        if (diff == 0) {\n            headers = parsed[0]; // whatever, just using the first row. Hope it's unique enough!\n        } else if (diff == -1) {\n            headers = parsed.shift();\n        } else {\n            throw new Error(\"number of matrix columns is not equal to the number of rows in '\" + bname + \"'\");\n        }\n\n        let annotations = {}\n        headers.forEach((x, i) => {\n            annotations[x] = parsed.map(y => y[i]);\n        });\n\n        for (const [k, v] of Object.entries(annotations)) {\n            let conv = eutils.promoteToNumber(v);\n            if (conv !== null) {\n                annotations[k] = conv;\n            }\n        }\n\n        this.#raw_cells = new bioc.DataFrame(annotations);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode TenxMatrixMarketDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     *   Unlike {@linkcode TenxMatrixMarketDataset#load load}, modality names are arbitrary.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     *\n     * @async\n     */\n    async summary({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n\n        let output = {\n            \"modality_features\": futils.reportFeatures(this.#raw_features, \"type\"),\n            \"cells\": this.#raw_cells\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #feature_type_mapping() {\n        return {\n            RNA: this.#options.featureTypeRnaName, \n            ADT: this.#options.featureTypeAdtName,\n            CRISPR: this.#options.featureTypeCrisprName\n        };\n    }\n\n    #primary_mapping() {\n        return {\n            RNA: this.#options.primaryRnaFeatureIdColumn, \n            ADT: this.#options.primaryAdtFeatureIdColumn,\n            CRISPR: this.#options.primaryCrisprFeatureIdColumn\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode TenxMatrixMarketDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode TenxMatrixMarketDataset#load load} but the order of values may be different.\n     * @async\n     */\n    async previewPrimaryIds({ cache = false } = {}) {\n        await this.#features();\n        let preview = futils.extractSplitPrimaryIds(this.#raw_features, \"type\", this.#feature_type_mapping(), \"RNA\", this.#primary_mapping());\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode TenxMatrixMarketDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRIPSR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode TenxMatrixMarketDataset#defaults defaults} or with {@linkcode TenxMatrixMarketDataset#setOptions setOptions}.\n     *\n     * If the feature annotation file is absent or if it lacks a third column for the feature types,\n     * `load()` will assume that all features are genes (i.e., only the RNA modality is present).\n     *\n     * @async\n     */\n    async load({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n\n        var is_gz = this.#matrix_file.name().endsWith(\".gz\");\n        let loaded = scran.initializeSparseMatrixFromMatrixMarket(this.#matrix_file.content(), { \"compressed\": is_gz });\n\n        let output = futils.splitScranMatrixAndFeatures(loaded, this.#raw_features, \"type\", this.#feature_type_mapping(), \"RNA\"); \n        output.cells = this.#raw_cells;\n\n        output.primary_ids = futils.extractPrimaryIds(output.features, this.#primary_mapping());\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    async serialize() {\n        return this.#dump_summary(f => f);\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode TenxMatrixMarketDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {TenxMatrixMarketDataset} A new instance of this class.\n     * @static\n     */\n    static async unserialize(files, options) {\n        let args = {};\n        for (const x of files) {\n            if (x.type in args) {\n                throw new Error(\"duplicate file of type '\" + x.type + \"' detected during MatrixMarket unserialization\");\n            }\n            args[x.type] = x.file;\n        }\n\n        if (!(\"mtx\" in args)) {\n            throw new Error(\"expected file of type 'mtx' for during MatrixMarket unserialization\");\n        }\n\n        let feat = null;\n        if (\"genes\" in args) {\n            feat = args.genes;\n        }\n\n        let barcode = null;\n        if (\"annotations\" in args) {\n            barcode = args.annotations;\n        }\n\n        let output = new TenxMatrixMarketDataset(args.mtx, feat, barcode);\n        output.setOptions(options);\n        return output;\n    }\n}\n","export function stream(file, chunkSize, callback, resolve, reject) {\n    reject(\"no support for file paths in the browser context\");\n}\n\nexport function peek(file, n) {\n    throw new Error(\"no support for file paths in the browser context\");\n}\n","import * as pako from \"pako\";\nimport ppp from \"papaparse\";\nimport * as astream from \"./abstract/stream.js\";\nimport * as afile from \"../abstract/file.js\";\n\nexport function extractHDF5Strings(handle, name) {\n    if (!(name in handle.children)) {\n        return null;\n    }\n\n    if (handle.children[name] !== \"DataSet\") {\n        return null;\n    }\n\n    let content = handle.open(name);\n    if (content.type !== \"String\") {\n        return null;\n    }\n\n    return content.load();\n}\n\n/**\n * Summarize an array, typically corresponding to a single column of per-cell annotation.\n * This can be used as part of a preflight response in a Reader.\n *\n * @param {Array|TypedArray} array - Per-cell annotation array of length equal to the number of cells for a given matrix.\n * An Array is treated as categorical data and should contain strings, while TypedArrays are treated as continuous data.\n * @param {object} [options] - Optional parameters.\n * @param {number} [options.limit=50] - Maximum number of unique values to report for categorical `x`.\n *\n * @return {object} Object containing `type`, a string indicating whether `array` was categorical or continuous.\n *\n * If `\"categorical\"`, the object will contain `values`, an array of unique values up to the length specified by `limit`.\n * It will also contain `truncated`, a boolean indicating whether the actual number of unique values exceeds `limit`.\n *\n * If `\"continuous\"`, the object will contain the numbers `min` and `max` specifying the minimum and maximum value in `x`, respectively.\n * `min` or `max` may be negative or positive infinity, respectively, if there is no bound on one or both ends.\n * If `min > max`, all values in `array` are `NaN`s such that no bound can be found.\n */\nexport function summarizeArray(array, { limit = 50 } = {}) {\n    if (array instanceof Array) {\n        let chosen = Array.from(new Set(array));\n        chosen.sort();\n        let truncated = false;\n        if (chosen.length > limit) {\n            chosen = chosen.slice(0, limit);\n            truncated = true;\n        }\n        return {\n            \"type\": \"categorical\",\n            \"values\": chosen,\n            \"truncated\": truncated\n        };\n    } else {\n        let min = Number.POSITIVE_INFINITY, max = Number.NEGATIVE_INFINITY;\n        array.forEach(x => {\n            if (x < min) {\n                min = x;\n            }\n            if (x > max) {\n                max = x;\n            }\n        });\n\n        return { \n            \"type\": \"continuous\",\n            \"min\": min, \n            \"max\": max \n        };\n    }\n}\n\nfunction guess_compression(x, compression) {\n    if (compression !== null) {\n        return compression;\n    }\n\n    let buffer;\n    if (x instanceof Uint8Array) {\n        buffer = x;\n    } else {\n        buffer = astream.peek(x, 3);\n    }\n\n    // Compare against magic words for auto-detection.\n    if (buffer.length >= 3 && buffer[0] == 0x1F && buffer[1] == 0x8B && buffer[2] == 0x08) {\n        return 'gz';\n    }\n\n    return 'none';\n}\n\nexport function unpackText(buffer, { compression = null } = {}) {\n    compression = guess_compression(buffer, compression);\n    let txt = (compression === \"gz\" ? pako.ungzip(buffer) : buffer);\n    const dec = new TextDecoder();\n    return dec.decode(txt);\n}\n\n// Soft-deprecated as of 1.1.0.\nexport function readLines(buffer, { compression = null } = {}) {\n    let decoded = unpackText(buffer, { compression: compression });\n    let lines = decoded.split(\"\\n\");\n    if (lines.length > 0 && lines[lines.length - 1] == \"\") { // ignoring the trailing newline.\n        lines.pop();\n    }\n    return lines;    \n}\n\nfunction merge_bytes(leftovers, decoder) {\n    let total = 0;\n    for (const x of leftovers) {\n        total += x.length;\n    }\n\n    let combined = new Uint8Array(total);\n    total = 0;\n    for (const x of leftovers) {\n        combined.set(x, total);\n        total += x.length;\n    }\n\n    return decoder.decode(combined);\n}\n\nasync function stream_callback(x, compression, chunkSize, callback) {\n    // Force the input to be either a Uint8Array or a file path string.\n    if (typeof x == \"string\") {\n        ;\n    } else if (x instanceof Uint8Array) {\n        ;\n    } else if (x instanceof afile.SimpleFile) {\n        x = x.content();\n    } else {\n        x = (new afile.SimpleFile(x, { name: \"dummy\" })).content();\n    }\n\n    if (guess_compression(x, compression) == \"gz\") {\n        await (new Promise((resolve, reject) => {\n            let gz = new pako.Inflate({ chunkSize: chunkSize });\n            gz.onData = callback;\n            gz.onEnd = status => {\n                if (status) {\n                    reject(\"gzip decompression failed; \" + gz.msg);\n                } else {\n                    resolve(null);\n                }\n            };\n\n            if (typeof x == \"string\") {\n                astream.stream(x, chunkSize, chunk => gz.push(chunk), null, reject);\n            } else {\n                gz.push(x);\n            }\n        }));\n        return;\n    }\n\n    // Remaining possibilities are uncompressed.\n    if (typeof x == \"string\") {\n        await (new Promise((resolve, reject) => astream.stream(x, chunkSize, callback, resolve, reject)));\n        return;\n    }\n\n    callback(x);\n    return;\n}\n\n/**\n * Read lines of text from a file, possibly with decompression.\n *\n * @param {string|Uint8Array|SimpleFile|File} x - Contents of the file to be read.\n * On Node.js, this may be a string containing a path to a file;\n * on browsers, this may be a File object.\n * @param {object} [options={}] - Optional parameters.\n * @param {?string} [options.compression=null] - Compression of `buffer`, either `\"gz\"` or `\"none\"`.\n * If `null`, it is determined automatically from the `buffer` header.\n * @param {number} [options.chunkSize=65536] - Chunk size in bytes to use for file reading (if `x` is a file path) and decompression (if `compression=\"gz\"`).\n * Larger values improve speed at the cost of memory.\n *\n * @return {Array} Array of strings where each entry contains a line in `buffer`.\n * The newline itself is not included in each string.\n * @async \n */\nexport async function readLines2(x, { compression = null, chunkSize = 65536 } = {}) {\n    const dec = new TextDecoder;\n    let leftovers = [];\n    let lines = [];\n\n    let callback = (chunk) => {\n        let last = 0;\n        for (var i = 0; i < chunk.length; i++) {\n            if (chunk[i] == 10) { // i.e., ASCII newline.\n                let current = chunk.subarray(last, i);\n                if (leftovers.length) {\n                    leftovers.push(current);\n                    lines.push(merge_bytes(leftovers, dec));\n                    leftovers = [];\n                } else {\n                    lines.push(dec.decode(current));\n                }\n                last = i + 1; // skip past the newline.\n            }\n        }\n\n        if (last != chunk.length) {\n            leftovers.push(chunk.slice(last)); // copy to avoid problems with ownership as chunk gets deref'd.\n        }\n    };\n\n    await stream_callback(x, compression, chunkSize, callback);\n\n    if (leftovers.length) {\n        lines.push(merge_bytes(leftovers, dec));\n    }\n\n    return lines;    \n}\n\n// Soft-deprecated as of 1.1.0.\nexport function readTable(buffer, { compression = null, delim = \"\\t\", firstOnly = false } = {}) {\n    let decoded = unpackText(buffer, { compression: compression });\n    let res = ppp.parse(decoded, { delimiter: delim, preview: (firstOnly ? 1 : 0) });\n\n    // Handle terminating newlines.\n    let last = res.data[res.data.length - 1];\n    if (last.length === 1 && last[0] === \"\") {\n        res.data.pop();\n    }\n\n    return res.data;\n}\n\n/**\n * Read a delimiter-separated table from a buffer, possibly with decompression.\n * This assumes that newlines represent the end of each row of the table, i.e., there cannot be newlines inside quoted strings.\n *\n * @param {string|Uint8Array|SimpleFile|File} x - Contents of the file to be read.\n * On Node.js, this may be a string containing a path to a file;\n * on browsers, this may be a File object.\n * @param {object} [options={}] - Optional parameters.\n * @param {?string} [options.compression=null] - Compression of `buffer`, either `\"gz\"` or `\"none\"`.\n * If `null`, it is determined automatically from the `buffer` header.\n * @param {string} [options.delim=\"\\t\"] - Delimiter between fields.\n * @param {number} [options.chunkSize=1048576] - Chunk size in bytes to use for file reading (if `x` is a path), parsing of rows, and decompression (if `compression=\"gz\"`).\n * Larger values improve speed at the cost of memory.\n *\n * @return {Array} Array of length equal to the number of lines in `buffer`.\n * Each entry is an array of strings, containing the `delim`-separated fields for its corresponding line.\n *\n * @async\n */\nexport async function readTable2(x, { compression = null, delim = \"\\t\", chunkSize = 1048576 } = {}) {\n    const dec = new TextDecoder;\n\n    let rows = [];\n    let parse = (str) => {\n        let out = ppp.parse(str, { delimiter: delim });\n        if (out.meta.aborted) {\n            let msg = \"failed to parse delimited file\";\n            for (const e of out.errors) {\n                msg += \"; \" + e.message;\n            }\n            throw new Error(msg);\n        }\n        for (const x of out.data) {\n            rows.push(x);\n        }\n    };\n\n    let leftovers = [];\n    let size_left = 0;\n    let callback = (chunk) => {\n        let last = 0;\n        for (var i = 0; i < chunk.length; i++) {\n            // We assume that all newlines are end-of-rows, i.e., there are no\n            // newlines inside quoted strings. Under this assumption, we can\n            // safely chunk the input stream based on newlines, parse each\n            // chunk, and then combine the parsing results together. To avoid\n            // too many parsing calls, we accumulate buffers until we hit \n            // the chunkSize and then we decode + parse them altogether.\n            if (chunk[i] == 10 && (i - last) + size_left >= chunkSize) {\n                let current = chunk.subarray(last, i);\n                if (leftovers.length) {\n                    leftovers.push(current);\n                    parse(merge_bytes(leftovers, dec));\n                    leftovers = [];\n                } else {\n                    parse(dec.decode(current));\n                }\n                last = i + 1; // skip past the newline.\n                size_left = 0;\n            }\n        }\n\n        if (last != chunk.length) {\n            leftovers.push(chunk.slice(last)); // copy to avoid problems with ownership as chunk gets deref'd.\n            size_left += chunk.length - last;\n        }\n    };\n\n    await stream_callback(x, compression, chunkSize, callback);\n\n    if (leftovers.length) {\n        let combined = merge_bytes(leftovers, dec);\n        parse(combined);\n        if (combined[combined.length - 1] == \"\\n\") { // guaranteed to have non-zero length, by virtue of how 'leftovers' is filled.\n            rows.pop();            \n        }\n    }\n\n    return rows;    \n}\n\n/**\n * Detect if an array contains only stringified numbers and, if so, convert it into a TypedArray.\n * Conversion will still be performed for non-number strings corresponding to missing values or explicit not-a-number entries.\n *\n * @param {Array} x Array of strings, usually corresponding to a column in a table read by {@linkcode readDSVFromBuffer}.\n *\n * @return {?Float64Array} A Float64Array is returned if `x` contains stringified numbers.\n * Otherwise, `null` is returned if the conversion could not be performed.\n */\nexport function promoteToNumber(x) {\n    let as_num = new Float64Array(x.length);\n\n    for (const [i, v] of Object.entries(x)) {\n        // See discussion at https://stackoverflow.com/questions/175739/how-can-i-check-if-a-string-is-a-valid-number.\n        let opt1 = Number(v);\n        let opt2 = parseFloat(v);\n        if (!isNaN(opt1) && !isNaN(opt2)) {\n            as_num[i] = opt1;\n        } else if (v === \"\" || v === \"NA\" || v == \"na\" || v == \"NaN\" || v == \"nan\") {\n            as_num[i] = NaN;\n        } else if (v == \"Inf\" || v == \"inf\") {\n            as_num[i] = Number.POSITIVE_INFINITY;\n        } else if (v == \"-Inf\" || v == \"-inf\") {\n            as_num[i] = Number.NEGATIVE_INFINITY;\n        } else {\n            return null;\n        }\n    }\n\n    return as_num;\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\n\nfunction create_solo_default_object(value, modality) {\n    let output = {};\n    output[modality] = value;\n    return output;\n}\n\nexport function reportFeatures(rawFeatures, typeField) {\n    if (rawFeatures.hasColumn(typeField)) {\n        let by_type = bioc.presplitFactor(rawFeatures.column(typeField));\n        let copy = rawFeatures.removeColumn(typeField);\n        return bioc.SPLIT(copy, by_type);\n    } else {\n        return create_solo_default_object(rawFeatures, \"\");\n    }\n}\n\nfunction is_subset_noop(indices, full_length) {\n    if (indices.length != full_length) {\n        return false;\n    }\n    for (var i = 0; i < full_length; i++) {\n        if (i !== indices[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction renameByModality(input, featureTypeMapping) {\n    let output = {};\n    for (const [k, v] of Object.entries(featureTypeMapping)) {\n        if (v !== null && v in input) {\n            output[k] = input[v];\n        }\n    }\n    return output;\n}\n\nfunction splitByModality(features, typeField, featureTypeMapping) {\n    let by_type = bioc.presplitFactor(features.column(typeField));\n    if (featureTypeMapping === null) {\n        return by_type;\n    }\n    return renameByModality(by_type, featureTypeMapping);\n}\n\nfunction findUnnamedDefault(featureTypeMapping, featureTypeDefault) {\n    let found = null;\n    let multiple = false;\n    for (const [k, v] of Object.entries(featureTypeMapping)) {\n        if (v !== null) {\n            if (found !== null) {\n                multiple = true;\n            }\n            found = k;\n        }\n    }\n\n    if (found === null || multiple) {\n        return featureTypeDefault;\n    } else {\n        return found;\n    }\n}\n\nexport function extractSplitPrimaryIds(features, typeField, featureTypeMapping, featureTypeDefault, primary) {\n    if (typeField !== null && features.hasColumn(typeField)) {\n        let by_type = splitByModality(features, typeField, featureTypeMapping);\n        for (const [k, v] of Object.entries(by_type)) {\n            let col = extractPrimaryIdColumn(k, features, primary);\n            by_type[k] = bioc.SLICE(col, v);\n        }\n        return by_type;\n    }\n\n    // Seeing if any featureTypeMapping is set to the unnamed string.\n    let new_default = findUnnamedDefault(featureTypeMapping, featureTypeDefault);\n    let output = {};\n    output[new_default] = extractPrimaryIdColumn(new_default, features, primary);\n    return output;\n}\n\nexport function splitScranMatrixAndFeatures(loaded, rawFeatures, typeField, featureTypeMapping, featureTypeDefault) {\n    let output = { matrix: new scran.MultiMatrix };\n\n    try {\n        let out_mat = loaded.matrix;\n        let out_ids = loaded.row_ids;\n        output.matrix.add(\"\", out_mat);\n\n        let current_features;\n        if (out_ids !== null) {\n            current_features = bioc.SLICE(rawFeatures, out_ids);\n        } else {\n            current_features = bioc.CLONE(rawFeatures, { deepCopy: false }); // because we're deleting a column.\n            out_ids = new Int32Array(out_mat.numberOfRows());\n            out_ids.forEach((x, i) => { out_ids[i] = i });\n        }\n\n        if (typeField !== null && current_features.hasColumn(typeField)) {\n            let by_type = splitByModality(current_features, typeField, featureTypeMapping);\n            let type_keys = Object.keys(by_type);\n            let skip_subset = is_subset_noop(type_keys[0], out_mat.numberOfRows());\n\n            if (type_keys.length > 1 || !skip_subset) {\n                let replacement = new scran.MultiMatrix({ store: scran.splitRows(out_mat, by_type) });\n                scran.free(output.matrix);\n                output.matrix = replacement;\n            } else {\n                output.matrix.rename(\"\", type_keys[0]);\n            }\n\n            delete current_features[typeField];\n            output.features = bioc.SPLIT(current_features, by_type);\n            output.row_ids = bioc.SPLIT(out_ids, by_type);\n\n        } else {\n            output.matrix.rename(\"\", featureTypeDefault);\n            output.row_ids = create_solo_default_object(out_ids, featureTypeDefault);\n            output.features = create_solo_default_object(current_features, featureTypeDefault);\n        }\n    } catch (e) {\n        scran.free(output.matrix);\n        throw e;\n    }\n\n    return output;\n}\n\nfunction extractPrimaryIdColumn(modality, modality_features, primary) {\n    if (!(modality in primary)) {\n        throw new Error(\"modality '\" + modality + \"' has no primary key identifier\");  \n    }\n    let id = primary[modality];\n\n    if ((typeof id == \"string\" && modality_features.hasColumn(id)) || (typeof id == \"number\" && id < modality_features.numberOfColumns())) {\n        return modality_features.column(id);\n    } \n\n    return modality_features.rowNames();\n}\n\nexport function extractPrimaryIds(features, primary) {\n    let output = {};\n    for (const [k, v] of Object.entries(features)) {\n        output[k] = extractPrimaryIdColumn(k, v, primary);\n    }\n    return output;\n}\n\nexport function extractRemappedPrimaryIds(features, featureTypeMapping, primary) {\n    let renamed = renameByModality(features, featureTypeMapping);\n    return extractPrimaryIds(renamed, primary);\n}\n","/**\n * Webpack (or something in kana's build system) specifically recognizes the\n * hard-coded path in this 'new Worker(new URL(...))' pattern. This is why we\n * have hard-coded creators for the workers rather than allowing callers to\n * pass in the URL as a variable, as that doesn't pack the worker's JS.\n */\n\nexport function createTsneWorker() {\n    return new Worker(new URL(\"../tsne.worker.js\", import.meta.url), { type: \"module\" });\n}\n\nexport function createUmapWorker() {\n    return new Worker(new URL(\"../umap.worker.js\", import.meta.url), { type: \"module\" });\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as nutils from \"./utils/normalization.js\";\nimport * as qc_module from \"./adt_quality_control.js\";\nimport * as filter_module from \"./cell_filtering.js\";\n\nexport const step_name = \"adt_normalization\";\n\n/**\n * This step performs normalization and log-transformation on the QC-filtered ADT matrix from the {@linkplain CellFilteringState}.\n * It wraps the [`groupedSizeFactors`](https://kanaverse.github.io/scran.js/global.html#groupedSizeFactors) \n * and [`logNormCounts`](https://kanaverse.github.io/scran.js/global.html#logNormCounts) functions\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class AdtNormalizationState {\n    #qc;\n    #filter;\n    #parameters;\n    #cache;\n\n    constructor(qc, filter, parameters = null, cache = null) {\n        if (!(qc instanceof qc_module.AdtQualityControlState)) {\n            throw new Error(\"'qc' should be a AdtQualityControlState object\");\n        }\n        this.#qc = qc;\n\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.matrix);\n        utils.freeCache(this.#cache.total_buffer);\n        utils.freeCache(this.#cache.sf_buffer);\n        utils.freeCache(this.#cache.centered_sf_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        let filtered = this.#filter.fetchFilteredMatrix();\n        return filtered.has(\"ADT\");\n    }\n\n    /**\n     * @return {external:ScranMatrix} A {@linkplain external:ScranMatrix ScranMatrix} object containing the normalized ADT values,\n     * available after running {@linkcode AdtNormalizationState#compute compute}.\n     */\n    fetchNormalizedMatrix() {\n        if (!(\"matrix\" in this.#cache)) {\n            this.#raw_compute();\n        }\n        return this.#cache.matrix;\n    }\n\n    /**\n     * @return {Float64WasmArray} Array of length equal to the number of cells, \n     * containing the ADT-derived size factor for each cell in the (QC-filtered) dataset.\n     * This is available after running {@linkcode AdtNormalizationState#compute compute}.\n     */\n    fetchSizeFactors() {\n        let buff;\n        if (this.#cache.sf_buffer) {\n            buff = utils.allocateCachedArray(this.#cache.sf_buffer.length, \"Float64Array\", this.#cache, \"centered_sf_buffer\");\n            scran.centerSizeFactors(this.#cache.sf_buffer, { buffer: buff, block: this.#filter.fetchFilteredBlock() })\n        }\n        return buff;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #raw_compute() {\n        var mat = this.#filter.fetchFilteredMatrix().get(\"ADT\");\n        var block = this.#filter.fetchFilteredBlock();\n\n        var buffer = this.#cache.sf_buffer;\n        if (buffer.length != mat.numberOfColumns()) {\n            throw new Error(\"length of size factor vector should equal number of columns after QC\");\n        }\n\n        utils.freeCache(this.#cache.matrix);\n        this.#cache.matrix = scran.logNormCounts(mat, { sizeFactors: buffer, block: block, allowZeros: true });\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `adt_normalization` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {boolean} parameters.remove_bias - Whether to remove composition bias between cell subpopulations.\n     * This is done by clustering cells and computing median-based size factors between the average pseudo-cells for each cluster.\n     * Users can set this to `false` to speed up the compute.\n     * @param {number} parameters.num_pcs - Number of PCs to use for creating a low-dimensional embedding for clustering.\n     * Only used if `remove_bias = true`.\n     * @param {number} parameters.num_clusters - Number of clusters to create with k-means clustering.\n     * Only used if `remove_bias = true`.\n     *\n     * @return The object is updated with new results.\n     */\n    compute(parameters) {\n        const { num_pcs, num_clusters } = parameters;\n        let remove_bias = true;\n        if (\"remove_bias\" in parameters) {\n            remove_bias = parameters.remove_bias;\n        }\n\n        this.changed = false;\n\n        if (this.#qc.changed || \n            this.#filter.changed || \n            remove_bias !== this.#parameters.remove_bias ||\n            (\n                remove_bias &&\n                (\n                    num_pcs !== this.#parameters.num_pcs || \n                    num_clusters != this.#parameters.num_clusters\n                ) \n            )\n        ) {\n            if (this.valid()) {\n                var mat = this.#filter.fetchFilteredMatrix().get(\"ADT\");\n                let total_buffer = nutils.subsetSums(this.#qc, this.#filter, mat, this.#cache, \"total_buffer\");\n                var block = this.#filter.fetchFilteredBlock();\n                var sf_buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Float64Array\", this.#cache, \"sf_buffer\");\n\n                if (remove_bias) {\n                    scran.quickAdtSizeFactors(mat, { \n                        totals: total_buffer, \n                        block: block, \n                        buffer: sf_buffer, \n                        numberOfPCs: num_pcs, \n                        numberOfClusters: num_clusters \n                    });\n                } else {\n                    scran.centerSizeFactors(total_buffer, { buffer: sf_buffer, block: block });\n                }\n\n                this.changed = true;\n            }\n\n        } \n\n        this.#parameters.remove_bias = remove_bias;\n        this.#parameters.num_pcs = num_pcs;\n        this.#parameters.num_clusters = num_clusters;\n\n        if (this.changed) {\n            if (this.valid()) {\n                this.#raw_compute();\n            }\n        }\n\n        return;\n    }\n\n    static defaults() {\n        return {\n           remove_bias: true,\n           num_pcs: 25,\n           num_clusters: 20\n        };\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, qc, filter) {\n    let cache = {};\n    let parameters = AdtNormalizationState.defaults();\n    let output;\n\n    if (step_name in handle.children) {\n        let ghandle = handle.open(step_name);\n\n        let phandle = ghandle.open(\"parameters\");\n        parameters.num_pcs = phandle.open(\"num_pcs\", { load: true }).values[0];\n        parameters.num_clusters = phandle.open(\"num_clusters\", { load: true }).values[0];\n\n        try {\n            let rhandle = ghandle.open(\"results\");\n            \n            if (\"size_factors\" in rhandle.children) {\n                let sf = rhandle.open(\"size_factors\", { load: true }).values;\n                cache.sf_buffer = scran.createFloat64WasmArray(sf.length);\n                cache.sf_buffer.set(sf);\n            }\n\n            output = new AdtNormalizationState(qc, filter, parameters, cache);\n        } catch (e) {\n            utils.freeCache(cache.sf_buffer);\n            utils.freeCache(output);\n            throw e;\n        }\n    } else {\n        // Fallback for v1.\n        output = new AdtNormalizationState(qc, filter, parameters, cache);\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as norm_module from \"./adt_normalization.js\";\n\nexport const step_name = \"adt_pca\";\n\n/**\n * This step performs a principal components analysis (PCA) to compact and denoise ADT data.\n * The resulting PCs can be used as input to various per-cell analyses like clustering and dimensionality reduction.\n * It wraps the [`runPCA`](https://kanaverse.github.io/scran.js/global.html#runPCA) function\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class AdtPcaState {\n    #filter;\n    #norm;\n    #cache;\n    #parameters;\n\n    constructor(filter, norm, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(norm instanceof norm_module.AdtNormalizationState)) {\n            throw new Error(\"'norm' should be a AdtNormalizationState object\");\n        }\n        this.#norm = norm;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.pcs);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        return this.#norm.valid();\n    }\n\n    /**\n     * @return {external:RunPCAResults} Results of the PCA on the normalized ADT matrix,\n     * available after running {@linkcode AdtPcaState#compute compute}.\n     */\n    fetchPCs() {\n        return this.#cache.pcs;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `adt_pca` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.num_pcs - Number of PCs to return.\n     * @param {string} parameters.block_method - Blocking method to use when dealing with multiple samples.\n     * This can be `\"none\"`, `\"regress\"` or `\"weight\"`, see comments in {@linkplain RnaPcaState}.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { num_pcs, block_method } = parameters;\n        this.changed = false;\n\n        if (this.#norm.changed || num_pcs !== this.#parameters.num_pcs || block_method !== this.#parameters.block_method) { \n            if (this.valid()) {\n                let block = this.#filter.fetchFilteredBlock();\n                var mat = this.#norm.fetchNormalizedMatrix();\n                utils.freeCache(this.#cache.pcs);\n                this.#cache.pcs = scran.runPCA(mat, { numberOfPCs: num_pcs, block: block, blockMethod: block_method });\n\n                this.changed = true;\n            }\n\n            this.#parameters.num_pcs = num_pcs;\n            this.#parameters.block_method = block_method;\n        }\n\n        return;\n    }\n\n    static defaults() {\n        return {\n            num_pcs: 20,\n            block_method: \"none\"\n        };\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, filter, norm) {\n    let cache = {};\n    let parameters = AdtPcaState.defaults();\n    let output;\n\n    if (step_name in handle.children) {\n        let ghandle = handle.open(step_name);\n\n        let phandle = ghandle.open(\"parameters\"); \n        parameters.num_pcs = phandle.open(\"num_pcs\", { load: true }).values[0];\n        parameters.block_method = phandle.open(\"block_method\", { load: true }).values[0];\n\n        try {\n            let rhandle = ghandle.open(\"results\");\n\n            if (\"var_exp\" in rhandle.children) {\n                let pcs_handle = rhandle.open(\"pcs\", { load: true });\n                let pcs = pcs_handle.values;\n                let var_exp = rhandle.open(\"var_exp\", { load: true }).values;\n\n                cache.pcs = scran.emptyRunPCAResults(pcs_handle.shape[0], pcs_handle.shape[1]);\n                cache.pcs.principalComponents({ fillable: true }).set(pcs);\n                cache.pcs.varianceExplained({ fillable: true }).set(var_exp);\n                cache.pcs.setTotalVariance(1); // because the file only stores proportions.\n            }\n\n            output = new AdtPcaState(filter, norm, parameters, cache);\n        } catch (e) {\n            utils.freeCache(cache.pcs);\n            utils.freeCache(output);\n            throw e;\n        }\n    } else {\n        output = new AdtPcaState(filter, norm, parameters, cache);\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as inputs_module from \"./inputs.js\";\n\nexport const step_name = \"adt_quality_control\";\n\n/**\n * Results of computing per-cell ADT-derived QC metrics,\n * see [here](https://kanaverse.github.io/scran.js/PerCellAdtQcMetricsResults.html) for details.\n *\n * @external PerCellAdtQcMetricsResults\n */\n\n/**\n * Suggested filters for the ADT-derived QC metrics,\n * see [here](https://kanaverse.github.io/scran.js/SuggestAdtQcFiltersResults.html) for details.\n *\n * @external SuggestAdtQcFiltersResults\n */\n\n/**\n * This step applies quality control on the ADT count matrix.\n * Specifically, it computes the QC metrics and filtering thresholds, \n * wrapping the [`perCellAdtQcMetrics`](https://kanaverse.github.io/scran.js/global.html#perCellAdtQcMetrics)\n * and [`suggestAdtQcFilters`](https://kanaverse.github.io/scran.js/global.html#suggestAdtQcFilters) functions\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n * Note that the actual filtering is done by {@linkplain CellFilteringState}.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class AdtQualityControlState {\n    #inputs;\n    #cache;\n    #parameters;\n\n    constructor(inputs, parameters = null, cache = null) {\n        if (!(inputs instanceof inputs_module.InputsState)) {\n            throw new Error(\"'inputs' should be a State object from './inputs.js'\");\n        }\n        this.#inputs = inputs;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.metrics);\n        utils.freeCache(this.#cache.filters);\n        utils.freeCache(this.#cache.metrics_buffer);\n        utils.freeCache(this.#cache.discard_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        let input = this.#inputs.fetchCountMatrix();\n        return input.has(\"ADT\");\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /**\n     * @return {external:SuggestAdtQcFiltersResults} Result of filtering on the ADT-derived QC metrics.\n     * This is available after running {@linkcode AdtQualityControlState#compute compute}.\n     */\n    fetchFilters() {\n        return this.#cache.filters;\n    }\n\n    /**\n     * @return {Uint8WasmArray} Buffer containing the discard vector of length equal to the number of cells,\n     * where each element is truthy if the corresponding cell is to be discarded.\n     * This is available after running {@linkcode AdtQualityControlState#compute compute}.\n     */\n    fetchDiscards() {\n        return this.#cache.discard_buffer;\n    }\n\n    /**\n     * @return {external:PerCellAdtQcMetricsResults} ADT-derived QC metrics,\n     * available after running {@linkcode AdtQualityControlState#compute compute}.\n     */\n    fetchMetrics() {\n        return this.#cache.metrics;\n    }\n\n    /****************************\n     ******** Defaults **********\n     ****************************/\n\n    static defaults() {\n        return {\n            automatic: true,\n            tag_id_column: null,\n            igg_prefix: \"IgG\",\n            nmads: 3,\n            min_detected_drop: 0.1\n        };\n    }\n\n    static configureFeatureParameters(lower_igg, annotations) {\n        let counter = val => {\n            let n = 0;\n            val.forEach(x => {\n                if (x.toLowerCase().startsWith(lower_igg)) {\n                    n++;\n                }\n            });\n            return n;\n        };\n\n        let best_key = null;\n        let best = 0;\n\n        let rn = annotations.rowNames();\n        if (rn !== null) {\n            best = counter(rn);\n        }\n\n        for (const key of annotations.columnNames()) {\n            let latest = counter(annotations.column(key));\n            if (latest > best) {\n                best_key = key;\n                best = latest;\n            }\n        }\n\n        return best_key;\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     * \n     * @param {object} parameters - Parameter object, equivalent to the `adt_quality_control` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {boolean} parameters.automatic - Automatically choose feature-based parameters based on the feature annotations. \n     * Specifically, `tag_id_column` is set to the column with the most matches to `igg_prefix`.\n     * @param {?(string|number)} parameters.tag_id_column - Name or index of the column of the feature annotations that contains the tag identifiers.\n     * If `null`, the row names are used.\n     * Ignored if `automatic = true`.\n     * @param {?string} parameters.igg_prefix - Prefix of the identifiers for isotype controls.\n     * If `null`, no prefix-based identification is performed.\n     * @param {number} parameters.nmads - Number of MADs to use for automatically selecting the filter threshold for each metric.\n     * @param {number} parameters.min_detected_drop - Minimum proportional drop in the number of detected features before a cell is to be considered low-quality.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { igg_prefix, nmads, min_detected_drop } = parameters;\n        this.changed = false;\n\n        let automatic;\n        let tag_id_column; \n        if (\"automatic\" in parameters) {\n            automatic = parameters.automatic;\n            tag_id_column = parameters.tag_id_column;\n        } else {\n            automatic = true;\n            tag_id_column = null;\n        }\n\n        if (\n            this.#inputs.changed || \n            automatic !== this.#parameters.automatic ||\n            igg_prefix !== this.#parameters.igg_prefix ||\n            (!automatic && tag_id_column !== this.#parameters.tag_id_column)\n        ) {\n            utils.freeCache(this.#cache.metrics);\n\n            if (this.valid()) {\n                var tag_info = this.#inputs.fetchFeatureAnnotations()[\"ADT\"];\n                var subsets = utils.allocateCachedArray(tag_info.numberOfRows(), \"Uint8Array\", this.#cache, \"metrics_buffer\");\n                subsets.fill(0);\n\n                if (igg_prefix !== null) {\n                    var lower_igg = igg_prefix.toLowerCase();\n                    let key = tag_id_column;\n                    if (automatic) {\n                        key = AdtQualityControlState.configureFeatureParameters(lower_igg, tag_info);\n                    }\n\n                    let val = (key == null ? tag_info.rowNames() : tag_info.column(key));\n                    if (val !== null) {\n                        var sub_arr = subsets.array();\n                        val.forEach((x, i) => { \n                            if (x.toLowerCase().startsWith(lower_igg)) {\n                                sub_arr[i] = 1;                        \n                            }\n                        });\n                    }\n                }\n\n                var mat = this.#inputs.fetchCountMatrix().get(\"ADT\");\n                this.#cache.metrics = scran.perCellAdtQcMetrics(mat, [subsets]);\n                this.changed = true;\n            } else {\n                delete this.#cache.metrics;\n            }\n        }\n\n        this.#parameters.automatic = automatic;\n        this.#parameters.tag_id_column = tag_id_column;\n        this.#parameters.igg_prefix = igg_prefix;\n\n        if (this.changed || nmads !== this.#parameters.nmads || min_detected_drop !== this.#parameters.min_detected_drop) {\n            utils.freeCache(this.#cache.filters);\n\n            if (this.valid()) {\n                let block = this.#inputs.fetchBlock();\n                this.#cache.filters = scran.suggestAdtQcFilters(this.#cache.metrics, { numberOfMADs: nmads, minDetectedDrop: min_detected_drop, block: block });\n                var discard = utils.allocateCachedArray(this.#cache.metrics.numberOfCells(), \"Uint8Array\", this.#cache, \"discard_buffer\");\n                this.#cache.filters.filter(this.#cache.metrics, { block: block, buffer: discard });\n                this.changed = true;\n            } else {\n                delete this.#cache.filters;\n            }\n\n            this.#parameters.nmads = nmads;\n            this.#parameters.min_detected_drop = min_detected_drop;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, inputs) {\n    let cache = {};\n    let parameters = AdtQualityControlState.defaults();\n    let output;\n\n    if (step_name in handle.children) {\n        let ghandle = handle.open(step_name);\n\n        let phandle = ghandle.open(\"parameters\"); \n        parameters.igg_prefix = phandle.open(\"igg_prefix\", { load: true }).values[0];\n        parameters.nmads = phandle.open(\"nmads\", { load: true }).values[0];\n        parameters.min_detected_drop = phandle.open(\"min_detected_drop\", { load: true }).values[0];\n\n        try {\n            let rhandle = ghandle.open(\"results\");\n\n            if (\"metrics\" in rhandle.children) { // if skip=true or valid() is false, QC metrics may not be reported.\n                let mhandle = rhandle.open(\"metrics\");\n\n                let detected = mhandle.open(\"detected\", { load: true }).values;\n                cache.metrics = scran.emptyPerCellAdtQcMetricsResults(detected.length, 1);\n                cache.metrics.detected({ fillable: true }).set(detected);\n\n                let sums = mhandle.open(\"sums\", { load: true }).values;\n                cache.metrics.sums({ fillable: true }).set(sums);\n                let igg_total = mhandle.open(\"igg_total\", { load: true }).values;\n                cache.metrics.subsetTotals(0, { fillable: true }).set(igg_total);\n            }\n\n            if (\"thresholds\" in rhandle.children) { // if skip=true or valid() is false, QC thresholds may not be reported.\n                let discards = rhandle.open(\"discards\", { load: true }).values; \n                cache.discard_buffer = scran.createUint8WasmArray(discards.length);\n                cache.discard_buffer.set(discards);\n\n                let thandle = rhandle.open(\"thresholds\");\n                let thresholds_detected = thandle.open(\"detected\", { load: true }).values;\n                let thresholds_igg_total = thandle.open(\"igg_total\", { load: true }).values;\n\n                cache.filters = scran.emptySuggestAdtQcFiltersResults(1, thresholds_detected.length);\n                cache.filters.thresholdsDetected({ fillable: true }).set(thresholds_detected);\n                cache.filters.thresholdsSubsetTotals(0, { fillable: true }).set(thresholds_igg_total);\n            }\n\n            output = new AdtQualityControlState(inputs, parameters, cache);\n        } catch (e) {\n            utils.freeCache(cache.metrics);\n            utils.freeCache(cache.filters)\n            utils.freeCache(output);\n            throw e;\n        }\n    } else {\n        // Fallback for v1.\n        output = new AdtQualityControlState(inputs, parameters, cache);\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as combine_module from \"./combine_embeddings.js\";\n\nexport const step_name = \"batch_correction\";\n\n/**\n * Correct for batch effects in PC space based on mutual nearest neighbors.\n * This wraps the [`mnnCorrect`](https://kanaverse.github.io/scran.js/global.html#mnnCorrect) function\n * from [**scran.js**](https://kanaverse.github.io/scran.js).\n * \n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class BatchCorrectionState {\n    #filter;\n    #combined;\n    #parameters;\n    #cache;\n\n    constructor(filter, combined, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(combined instanceof combine_module.CombineEmbeddingsState)) {\n            throw new Error(\"'pca' should be a CombineEmbeddingsState object\");\n        }\n        this.#combined = combined;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.corrected);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {Float64WasmArray} Buffer containing the batch-corrected embeddings as a column-major dense matrix,\n     * where the rows are the dimensions and the columns are the cells.\n     * This is available after running {@linkcode BatchCorrectionState#compute compute}.\n     */\n    fetchCorrected() {\n        return this.#cache.corrected;\n    }\n\n    /**\n     * @return {number} Number of cells in {@linkcode BatchCorrectionState#fetchCorrected fetchCorrected}.\n     */\n    fetchNumberOfCells() {\n        return this.#combined.fetchNumberOfCells();\n    }\n\n    /**\n     * @return {number} Number of dimensions in {@linkcode BatchCorrectionState#fetchCorrected fetchCorrected}.\n     */\n    fetchNumberOfDimensions() {\n        return this.#combined.fetchNumberOfDimensions();\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `batch_correction` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {string} parameters.method - The correction method to use.\n     * Currently this can be either `\"mnn\"` or `\"none\"`.\n     * If `\"mnn\"`, it is recommended that upstream PCA steps (i.e., {@linkplain RnaPcaState} and {@linkplain AdtPcaState}) use `block_method = \"weight\"`.\n     * @param {number} parameters.num_neighbors - Number of neighbors to use during MNN correction.\n     * @param {boolean} parameters.approximate - Whether to use an approximate method to identify MNNs.\n     *\n     * @return The object is updated with new results.\n     */\n    compute(parameters) {\n        let { method, num_neighbors, approximate} = parameters;\n        this.changed = false;\n\n        if (this.#filter.changed || this.#combined.changed) {\n            this.changed = true;\n        }\n        let block = this.#filter.fetchFilteredBlock();\n        let needs_correction = (method == \"mnn\" && block !== null);\n\n        if (this.changed || method !== this.#parameters.method || num_neighbors !== this.#parameters.num_neighbors || approximate !== this.#parameters.approximate) { \n            if (needs_correction) {\n                let pcs = this.#combined.fetchCombined();\n                let corrected = utils.allocateCachedArray(pcs.length, \"Float64Array\", this.#cache, \"corrected\");\n                scran.mnnCorrect(pcs, block, { \n                    k: num_neighbors, \n                    buffer: corrected, \n                    numberOfCells: this.#combined.fetchNumberOfCells(), \n                    numberOfDims: this.#combined.fetchNumberOfDimensions(), \n                    approximate: approximate \n                });\n                this.changed = true;\n            }\n        }\n\n        if (this.changed) {\n            // If no correction is actually required, we shouldn't respond to\n            // changes in parameters, because they won't have any effect.\n            if (!needs_correction) {\n                utils.freeCache(this.#cache.corrected);\n                this.#cache.corrected = this.#combined.fetchCombined().view();\n            }\n        }\n\n        // Updating all parameters, even if they weren't used.\n        this.#parameters.method = method;\n        this.#parameters.num_neighbors = num_neighbors;\n        this.#parameters.approximate = approximate;\n        return;\n    }\n\n    static defaults() {\n        return {\n            method: \"mnn\",\n            num_neighbors: 15,\n            approximate: true\n        };\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, filter, combined) {\n    let cache = {};\n    let parameters = BatchCorrectionState.defaults();\n    let output;\n    \n    if (step_name in handle.children) {\n        let ghandle = handle.open(step_name);\n\n        let phandle = ghandle.open(\"parameters\"); \n        parameters.method = phandle.open(\"method\", { load: true }).values[0];\n        parameters.num_neighbors = phandle.open(\"num_neighbors\", { load: true }).values[0];\n        parameters.approximate = phandle.open(\"approximate\", { load: true }).values[0] > 0;\n\n        try {\n            let rhandle = ghandle.open(\"results\");\n\n            if (\"corrected\" in rhandle.children) {\n                let corrected = rhandle.open(\"corrected\", { load: true }).values;\n                cache.corrected = scran.createFloat64WasmArray(corrected.length);\n                cache.corrected.set(corrected);\n            } else {\n                // Creating a view from the upstream combined state.\n                let pcs = combined.fetchCombined();\n                cache.corrected = pcs.view();\n            }\n\n            output = new BatchCorrectionState(filter, combined, parameters, cache);\n        } catch (e) {\n            utils.freeCache(cache.corrected);\n            utils.freeCache(output);\n            throw e;\n        }\n    } else {\n        // Fallback for v1.\n        let ghandle = handle.open(\"pca\");\n\n        let rhandle = ghandle.open(\"results\");\n        if (\"corrected\" in rhandle.children) {\n            let corrected = rhandle.open(\"corrected\", { load: true }).values;\n            let corbuffer = utils.allocateCachedArray(corrected.length, \"Float64Array\", cache, \"corrected\");\n            corbuffer.set(corrected);\n        } else {\n            cache.corrected = combined.fetchCombined().view();\n        }\n\n        output = new BatchCorrectionState(filter, combined, parameters, cache);\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as rna_qc_module from \"./rna_quality_control.js\";\nimport * as adt_qc_module from \"./adt_quality_control.js\";\nimport * as crispr_qc_module from \"./crispr_quality_control.js\";\nimport * as inputs_module from \"./inputs.js\";\n\nexport const step_name = \"cell_filtering\";\n\nfunction find_usable_upstream_states(qc_states, in_use) {\n    let tmp = utils.findValidUpstreamStates(qc_states);\n    let to_use = [];\n    for (const k of tmp) {\n        if (in_use[k]) {\n            to_use.push(qc_states[k]);\n        }\n    }\n    return to_use;\n}\n\n/**\n * This step filters the count matrices to remove low-quality cells,\n * based on metrics and thresholds computed in {@linkplain RnaQualityControlState} and friends.\n * It wraps the [`filterCells`](https://kanaverse.github.io/scran.js/global.html#filterCells) function\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n * For multi-modal datasets, this can combine quality calls from all valid modalities; \n * a cell is removed if it is considered low-quality in any individual modality.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CellFilteringState {\n    #inputs;\n    #qc_states;\n    #cache;\n    #parameters;\n\n    constructor(inputs, qc_states, parameters = null, cache = null) {\n        if (!(inputs instanceof inputs_module.InputsState)) {\n            throw new Error(\"'inputs' should be an InputsState object\");\n        }\n        this.#inputs = inputs;\n\n        if (!(qc_states.RNA instanceof rna_qc_module.RnaQualityControlState)) {\n            throw new Error(\"'qc_states.RNA' should be a RnaQualityControlState object\");\n        }\n        if (!(qc_states.ADT instanceof adt_qc_module.AdtQualityControlState)) {\n            throw new Error(\"'qc_states.ADT' should be a AdtQualityControlState object\");\n        }\n        if (!(qc_states.CRISPR instanceof crispr_qc_module.CrisprQualityControlState)) {\n            throw new Error(\"'qc_states.CRISPR' should be a CrisprQualityControlState object\");\n        }\n        this.#qc_states = qc_states;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.block_buffer);\n        utils.freeCache(this.#cache.discard_buffer);\n        utils.freeCache(this.#cache.matrix);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {external:MultiMatrix} A {@linkplain external:MultiMatrix MultiMatrix} object containing the filtered and normalized matrices for all modalities,\n     * available after running {@linkcode CellFilteringState#compute compute}.\n     */\n    fetchFilteredMatrix() {\n        if (!(\"matrix\" in this.#cache)) {\n            this.#raw_compute_matrix();\n        }\n        return this.#cache.matrix;\n    }\n\n    /**\n     * @return {Int32WasmArray} Array of length equal to the number of cells after filtering, \n     * containing the block assignment for each cell.\n     * This is available after running {@linkcode CellFilteringState#compute compute}.\n     * Alternatively `null` if no blocks are present in the dataset.\n     */\n    fetchFilteredBlock() {\n        if (!(\"block_buffer\" in this.#cache)) {\n            this.#raw_compute_block();\n        }\n        return this.#cache.block_buffer;\n    }\n\n    /**\n     * @return {?Uint8WasmArray} Combined discard vector, i.e., an array of length equal to the number of cells in the dataset,\n     * indicating whether each cell should be removed.\n     * This is available after running {@linkcode CellFilteringState#compute compute}.\n     * Alternatively `null`, if no upstream filtering steps were performed.\n     */\n    fetchDiscards() {\n        if (\"discard_buffer\" in this.#cache) {\n            return this.#cache.discard_buffer;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #raw_compute_matrix() {\n        utils.freeCache(this.#cache.matrix);\n        this.#cache.matrix = new scran.MultiMatrix;\n\n        let inputs = this.#inputs.fetchCountMatrix();\n        for (const a of inputs.available()) {\n            let src = inputs.get(a);\n\n            let sub;\n            if (\"discard_buffer\" in this.#cache) {\n                sub = scran.filterCells(src, this.#cache.discard_buffer);\n            } else {\n                sub = src.clone();\n            }\n\n            this.#cache.matrix.add(a, sub);\n        }\n    }\n\n    #raw_compute_block() {\n        utils.freeCache(this.#cache.block_buffer);\n\n        let block = this.#inputs.fetchBlock();\n        if (block !== null) {\n            if (\"discard_buffer\" in this.#cache) {\n                // Filtering on the block. Might as well force a load of the\n                // matrix, it'll be needed once we have the blocks anyway.\n                let filtered_ncols = this.fetchFilteredMatrix().numberOfColumns();\n                let bcache = utils.allocateCachedArray(filtered_ncols, \"Int32Array\", this.#cache, \"block_buffer\");\n                scran.filterBlock(block, this.#cache.discard_buffer, { buffer: bcache });\n            } else {\n                this.#cache.block_buffer = block.view();\n            }\n        } else {\n            this.#cache.block_buffer = null;\n        }\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `cell_filtering` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {boolean} parameters.use_rna - Whether to use the RNA-derived QC metrics for filtering.\n     * @param {boolean} parameters.use_adt - Whether to use the ADT-derived QC metrics for filtering.\n     * @param {boolean} parameters.use_crispr - Whether to use the CRISPR-derived QC metrics for filtering.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { use_rna, use_adt, use_crispr } = parameters;\n        this.changed = false;\n\n        if (this.#inputs.changed) {\n            this.changed = true;\n        }\n\n        if (this.#parameters.use_rna !== use_rna || this.#parameters.use_adt !== use_adt || this.#parameters.use_crispr !== use_crispr) {\n            this.#parameters.use_rna = use_rna;\n            this.#parameters.use_adt = use_adt;\n            this.#parameters.use_crispr = use_crispr;\n            this.changed = true;\n        }\n\n        let to_use = find_usable_upstream_states(this.#qc_states, { RNA: use_rna, ADT: use_adt, CRISPR: use_crispr });\n        if (!this.changed) {\n            for (const u of to_use) {\n                if (u.changed) {\n                    this.changed = true;\n                    break;\n                }\n            }\n        }\n\n        if (this.changed) {\n            if (to_use.length > 0) {\n                let first = to_use[0].fetchDiscards();\n\n                if (to_use.length > 1) {\n                    // A discard signal in any modality causes the cell to be removed. \n                    let disc_buffer = utils.allocateCachedArray(first.length, \"Uint8Array\", this.#cache, \"discard_buffer\");\n                    disc_buffer.fill(0);\n\n                    let disc_arr = disc_buffer.array();\n                    for (const u of to_use) {\n                        u.fetchDiscards().forEach((y, i) => { disc_arr[i] |= y; });\n                    }\n                } else {\n                    // If there's only one valid modality, we just create a view on it\n                    // to avoid unnecessary duplication.\n                    utils.freeCache(this.#cache.discard_buffer);\n                    this.#cache.discard_buffer = first.view();\n                }\n\n            } else {\n                // Deleting this so that serialization will behave correctly.\n                utils.freeCache(this.#cache.discard_buffer);\n                delete this.#cache.discard_buffer;\n            }\n\n            this.#raw_compute_matrix();\n            this.#raw_compute_block();\n        }\n    }\n\n    static defaults() {\n        return {\n            use_rna: true,\n            use_adt: true,\n            use_crispr: true\n        };\n    }\n\n    /**\n     * Apply the same filter to an array of data for each cell in the unfiltered dataset.\n     * This is typically used to filter the columns of {@linkcode InputsState#fetchCellAnnotations InputsState.fetchCellAnnotations} for downstream use.\n     * (See the {@linkcode CellFilteringState#undoFilter undoFilter} method for the reverse operation.)\n     * Any calls to this method should be done after running {@linkcode CellFilteringState#compute compute}.\n     *\n     * @param {Array|TypedArray} Any array-like object of length equal to the number of cells in the unfiltered dataset.\n     * \n     * @return {Array|TypedArray} An array-like object of the same type as `x`,\n     * where all elements corresponding to low-quality cells have been discarded.\n     * This will have number of columns equal to that of {@linkcode CellFilteringState#fetchFilteredMatrix fetchFilteredMatrix}.\n     */\n    applyFilter(x) {\n        let expect_len = this.#inputs.fetchCountMatrix().numberOfColumns();\n        if (expect_len != x.length) {\n            throw new Error(\"length of 'x' should be equal to the number of cells in the unfiltered dataset\");\n        }\n\n        if (!(\"discard_buffer\" in this.#cache)) {\n            return x.slice(); // making a copy.\n        } else {\n            let discard = this.#cache.discard_buffer.array();\n            return x.filter((y, i) => !discard[i]);\n        }\n    }\n\n    /**\n     * Undo the effect of filtering on an array of column indices on the filtered matrix, so that they now refer to column indices on the unfiltered matrix.\n     * This is primarily useful for adjusting indices from downstream steps like {@linkcode CustomSelectionsState#fetchSelectionIndices CustomSelectionsState.fetchSelectionIndices}.\n     * The output of this function can be combined with {@linkcode InputsState#undoSubset InputsState.undoSubset} to obtain column indices on the original matrix,\n     * which can be used in other contexts, e.g., like {@linkcode subsetInputs}.\n     *\n     * @param {Array|TypedArray} indices - Array of column indices to the filtered matrix.\n     * Note that this will be modified in-place.\n     *\n     * @return Entries of `indices` are replaced with indices to the unfiltered matrix.\n     */\n    undoFilter(indices) {\n        let max_index = this.fetchFilteredMatrix().numberOfColumns();\n        for (const x of indices) {\n            if (x < 0 || x >= max_index) {\n                throw new Error(\"entries of 'indices' should be less than the number of cells in the filtered dataset\");\n            }\n        }\n\n        if (!('discard_buffer' in this.#cache)) {\n            return;\n        }\n\n        let keep = [];\n        this.#cache.discard_buffer.forEach((x, i) => {\n            if (x == 0) {\n                keep.push(i);\n            }\n        });\n\n        indices.forEach((x, i) => {\n            indices[i] = keep[x];\n        });\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, inputs, qc_states) {\n    let parameters = CellFilteringState.defaults();\n    let cache = {};\n    let output;\n\n    try {\n        if (step_name in handle.children) {\n            let ghandle = handle.open(step_name);\n\n            if (\"parameters\" in ghandle.children) {\n                let phandle = ghandle.open(\"parameters\");\n                if (\"use_rna\" in phandle.children) {\n                    parameters.use_rna = phandle.open(\"use_rna\", { load: true }).values[0] > 0;\n                    parameters.use_adt = phandle.open(\"use_adt\", { load: true }).values[0] > 0;\n                    parameters.use_crispr = phandle.open(\"use_crispr\", { load: true }).values[0] > 0;\n                }\n            }\n\n            let rhandle = ghandle.open(\"results\");\n            if (\"discards\" in rhandle.children) {\n                let discards = rhandle.open(\"discards\", { load: true }).values; \n                cache.discard_buffer = scran.createUint8WasmArray(discards.length);\n                cache.discard_buffer.set(discards);\n            }\n        } \n\n        if (!(\"discard_buffer\" in cache)) {\n            let to_use = find_usable_upstream_states(qc_states, { RNA: parameters.use_rna, ADT: parameters.use_adt, CRISPR: parameters.use_crispr });\n\n            if (to_use.length == 1) {\n                // We figure out which upstream QC state contains the discard vector\n                // and create a view on it so that our discard_buffer checks work properly.\n                // (v1 and earlier also implicitly falls in this category.)\n                cache.discard_buffer = to_use[0].fetchDiscards().view();\n            } else if (to_use.length == 0) {\n                // No-op; we don't need to define discard_buffer.\n                ;\n            } else {\n                throw new Error(\"no more than one upstream QC state should be valid if 'discards' is not available\");\n            }\n        }\n\n        output = new CellFilteringState(inputs, qc_states, parameters, cache);\n    } catch (e) {\n        utils.freeCache(cache.discard_buffer);\n        utils.freeCache(output);\n        throw e;\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as utils from \"./utils/general.js\";\nimport * as rutils from \"../readers/index.js\";\nimport * as inputs_module from \"./inputs.js\";\nimport * as norm_module from \"./rna_normalization.js\";\n\nconst baseUrl = \"https://github.com/kanaverse/singlepp-references/releases/download/2023-04-28\";\n\nexport const step_name = \"cell_labelling\";\n\n/************************************\n ****** Internals for loading *******\n ************************************/\n\nvar download_fun  = utils.defaultDownload;\n\nfunction set_download(fun) {\n    let previous = download_fun;\n    download_fun = fun;\n    return previous;\n}\n\nasync function acquire_file(name, suffix) {\n    let full = name + \"_\" + suffix;\n    let b = await download_fun(baseUrl + \"/\" + full);\n    return new rutils.SimpleFile(b, { name: full })\n}\n\nconst all_loaded = {};\n\nfunction flush_prepared(cache) {\n    if (\"prepared\" in cache) {\n        for (const v of Object.values(cache.prepared)) {\n            v.built.raw.free();\n        }\n        delete cache.prepared;\n    }\n}\n\nasync function process_genes(file) {\n    let gene_lines = await rutils.readLines2(file.content(), { compression: \"gz\" }); // gene names\n    let acquired = [];\n\n    for (const x of gene_lines) {\n        let val = null;\n        if (x !== \"\") {\n            val = x.split(\"\\t\");\n            if (val.length == 1) {\n                val = val[0];\n            }\n        }\n        acquired.push(val);\n    }\n\n    return acquired;\n}\n\nasync function load_reference(name, gene_id_type) {\n    let gene_suffix = \"genes_\" + gene_id_type.toLowerCase() + \".csv.gz\";\n\n    if (name in all_loaded) {\n        let output = all_loaded[name];\n        let known_genes = output.genes;\n        if (!(gene_id_type in known_genes)) {\n            known_genes[gene_id_type] = await process_genes(await acquire_file(name, gene_suffix));\n        }\n        return output;\n    }\n\n    const suffixes = [ \n        \"labels_fine.csv.gz\",\n        \"label_names_fine.csv.gz\",\n        \"markers_fine.gmt.gz\",\n        \"matrix.csv.gz\",\n        gene_suffix\n    ];\n\n    let contents = await Promise.all(suffixes.map(x => acquire_file(name, x)));\n\n    let loaded;\n    let stored;\n    try {\n        loaded = scran.loadLabelledReferenceFromBuffers(\n            contents[3].buffer(), // rank matrix\n            contents[2].buffer(), // markers\n            contents[0].buffer()  // label per sample\n        );\n\n        let labels = await rutils.readLines2(contents[1].content(), { compression: \"gz\" }); // full label names\n        stored = {\n            \"raw\": loaded, \n            \"labels\": labels,\n            \"genes\": {}\n        };\n\n        stored.genes[gene_id_type] = await process_genes(contents[4]);\n        all_loaded[name] = stored;\n\n    } catch (e) {\n        utils.freeCache(loaded);\n        throw e;\n    }\n\n    return stored;\n}\n\nfunction flush_loaded() {\n    for (const [k, v] of Object.entries(all_loaded)) {\n        v.raw.free();\n        delete all_loaded[k];\n    }\n}\n\n/*************************************\n ****** Internals for building *******\n *************************************/\n\nconst available_references = {\n    \"9606\": [ \"BlueprintEncode\", \"DatabaseImmuneCellExpression\", \"HumanPrimaryCellAtlas\", \"MonacoImmune\", \"NovershternHematopoietic\" ],\n    \"10090\": [ \"ImmGen\", \"MouseRNAseq\" ]\n};\n\nfunction internal_build_reference(name, gene_ids, gene_id_type) {\n    let built;\n    let output;\n    try {\n        let current = all_loaded[name];\n        let loaded = current.raw;\n\n        if (!(gene_id_type in current.genes)) {\n            throw new Error(\"unknown gene type '\" + gene_id_type + \"'\");\n        }\n        let chosen_ids = current.genes[gene_id_type];\n\n        built = scran.buildLabelledReference(gene_ids, loaded, chosen_ids); \n        output = {\n            \"loaded\": current,\n            \"built\": {\n                \"features\": chosen_ids,\n                \"raw\": built\n            }\n        };\n\n    } catch (e) {\n        utils.freeCache(built);\n        throw e;\n    }\n\n    return output;\n}\n\nasync function build_reference(cache, references, automatic, species, gene_id_column, gene_id_type, old_parameters, annofun, guessfun) {\n    if (\n        automatic !== old_parameters.automatic ||\n        utils.changedParameters(references, old_parameters.references) ||\n        (\n            !automatic &&\n            (\n                species !== old_parameters.species ||\n                gene_id_column !== old_parameters.gene_id_column ||\n                gene_id_type !== old_parameters.gene_id_type\n            )\n        )\n    ) {\n        let species2 = species;\n        let gene_id_column2 = gene_id_column;\n        let gene_id_type2 = gene_id_type;\n\n        if (automatic) {\n            let auto = CellLabellingState.configureFeatureParameters(guessfun());\n            species2 = auto.species;\n            gene_id_column2 = auto.gene_id_column;\n            gene_id_type2 = auto.gene_id_type;\n        }\n\n        let allowable = new Set;\n        for (const s of species2) {\n            if (s in available_references) {\n                available_references[s].forEach(x => { allowable.add(x); });\n            }\n        }\n\n        // Building each individual reference.\n        let feats = annofun();\n        let gene_ids = (gene_id_column2 == null ? feats.rowNames() : feats.column(gene_id_column2));\n        cache.gene_ids = gene_ids;\n\n        let valid = {};\n        if (gene_ids !== null) {\n            if (references == null) {\n                references = Array.from(allowable);\n            }\n            for (const ref of references) {\n                if (allowable.has(ref)) {\n                    await load_reference(ref, gene_id_type2);\n                    valid[ref] = internal_build_reference(ref, gene_ids, gene_id_type2);\n                }\n            }\n        }\n\n        flush_prepared(cache);\n        cache.prepared = valid;\n\n        // Building an integrated reference, if necessary.\n        let used_refs = Object.keys(valid);\n        if (used_refs.length > 1) {\n            let arr = Object.values(valid);\n            let loaded = arr.map(x => x.loaded.raw);\n            let feats = arr.map(x => x.built.features);\n            let built = arr.map(x => x.built.raw);\n\n            utils.freeCache(cache.integrated);\n            cache.integrated = scran.integrateLabelledReferences(gene_ids, loaded, feats, built);\n        } else {\n            utils.freeCache(cache.integrated);\n            delete cache.integrated;\n        }\n        cache.used_refs = used_refs;\n\n       return true;\n    }\n\n    return false;\n}\n\nfunction create_defaults() {\n    return {\n        references: null,\n        automatic: true,\n        species: [],\n        gene_id_column: null,\n        gene_id_type: \"ENSEMBL\"\n    };\n}\n\nfunction transplant_parameters(references, automatic, species, gene_id_column, gene_id_type, parameters) {\n    parameters.references = bioc.CLONE(references); // make a copy to avoid pass-by-reference behavior.\n    parameters.automatic = automatic;\n    parameters.species = bioc.CLONE(species);\n    parameters.gene_id_column = gene_id_column;\n    parameters.gene_id_type = gene_id_type;\n}\n\nfunction fetch_parameters(parameters) {\n    // Avoid pass-by-reference behavior.\n    let out = { ...parameters };\n    out.references = bioc.CLONE(out.references);\n    out.species = bioc.CLONE(out.species);\n    return out;\n}\n\n/************************************\n ****** Internals for compute *******\n ************************************/\n\nfunction transform_results(names, results, assigned) {\n    let nclusters = results.numberOfCells();\n    let ntargets = names.length;\n    let output = new Array(nclusters);\n\n    for (var r = 0; r < nclusters; r++) {\n        let all_scores = {};\n        let cscores = results.scoresForCell(r);\n        for (var l = 0; l < ntargets; l++) {\n            all_scores[names[l]] = cscores[l];\n        }\n        output[r] = { best: names[assigned[r]], all: all_scores };\n    }\n\n    return output;\n}\n\nfunction assign_labels_internal(x, cache) {\n    let matrix = x;\n    let temp_cluster_means;\n    let temp_matrix;\n\n    // Converting marker results into means.\n    if (x instanceof scran.ScoreMarkersResults) {\n        let ngroups = x.numberOfGroups();\n\n        if (cache.gene_ids === null) {\n            matrix = null;                \n        } else {\n            let ngenes = cache.gene_ids.length;\n\n            // Creating a column-major array of mean vectors for each cluster.\n            temp_cluster_means = scran.createFloat64WasmArray(ngroups * ngenes);\n            for (var g = 0; g < ngroups; g++) {\n                let means = x.means(g, { copy: false }); // Warning: direct view in wasm space - be careful.\n                if (means.length !== ngenes) {\n                    throw new Error(\"unexpected number of genes in marker results\");\n                }\n                let cluster_array = temp_cluster_means.array();\n                cluster_array.set(means, g * ngenes);\n            }\n\n            temp_matrix = scran.ScranMatrix.createDenseMatrix(ngenes, ngroups, temp_cluster_means, { columnMajor: true, copy: false });\n            matrix = temp_matrix;\n        }\n    } else {\n        if (cache.gene_ids !== null && x.numberOfRows() !== cache.gene_ids.length) {\n            throw new Error(\"unexpected number of genes in the input matrix\"); \n        }\n    }\n\n    // Running classifications; this is a no-op if gene_ids = null as 'valid' should be empty.\n    let valid = cache.prepared;\n    let results = { per_reference: {} };\n    let raw = {};\n    for (const [key, ref] of Object.entries(valid)) {\n        let current = scran.labelCells(matrix, ref.built.raw);\n        raw[key] = current;\n        results.per_reference[key] = transform_results(ref.loaded.labels, current, current.predictedLabels({ copy: false }));\n    }\n\n    if (\"integrated\" in cache) {\n        let single_results = [];\n        for (const key of cache.used_refs) { // enforce correct order.\n            single_results.push(raw[key]);\n        }\n\n        let current = scran.integrateCellLabels(matrix, single_results, cache.integrated);\n        results.integrated = transform_results(cache.used_refs, current, current.predictedReferences({ copy: false }));\n        current.free();\n    }\n\n    for (const v of Object.values(raw)) {\n        v.free();\n    }\n    utils.freeCache(temp_matrix);\n    utils.freeCache(temp_cluster_means);\n\n    return results;\n}\n\nfunction assign_labels(x, group, cache) {\n    if (group === null) {\n        return assign_labels_internal(x, cache);\n    }\n\n    let to_collect = [];\n    let output;\n    try {\n        let dump = utils.subsetInvalidFactors([group]);\n        to_collect.push(dump.arrays[0].ids);\n\n        let mat = x;\n        if (dump.retain !== null) {\n            let sub = scran.subsetColumns(x, dump.retain);\n            to_collect.push(sub);\n            mat = sub;\n        }\n\n        let aggr = scran.aggregateAcrossCells(mat, dump.arrays[0].ids, { average: true });\n        to_collect.push(aggr);\n\n        let aggrmat = scran.ScranMatrix.createDenseMatrix(\n            mat.numberOfRows(), \n            aggr.numberOfGroups(), \n            aggr.sums(null, { copy: \"view\" }),\n            { columnMajor: true, copy: false }\n        );\n        to_collect.push(aggrmat);\n\n        output = assign_labels_internal(aggrmat, cache);\n        output.groups = dump.arrays[0].levels;\n    } finally {\n        to_collect.forEach(utils.freeCache);\n    }\n\n    return output;\n}\n\n/********************\n ****** State *******\n ********************/\n\n/**\n * Cell labelling involves assigning cell type labels to clusters using the [**SingleR** algorithm](https://github.com/LTLA/CppSingleR),\n * based on [pre-formatted reference expression profiles](https://github.com/clusterfork/singlepp-references).\n * This wraps [`labelCells`](https://kanaverse.github.io/scran.js/global.html#labelCells)\n * and related functions from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * In theory, we could do this at the single-cell level, but we use clusters instead to expedite the computation and simplify interpretation.\n * If multiple references are requested, we will use each for assignment before attempting to choose the best label for each cluster across references.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CellLabellingState {\n    #inputs;\n    #parameters;\n    #cache;\n\n    constructor(inputs, parameters = null, cache = null) {\n        if (!(inputs instanceof inputs_module.InputsState)) {\n            throw new Error(\"'inputs' should be a State object from './inputs.js'\");\n        }\n        this.#inputs = inputs;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        flush_prepared(this.#cache);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        let mat = this.#inputs.fetchCountMatrix();\n        return mat.has(\"RNA\");\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        // Avoid any pass-by-reference activity.\n        let out = { ...this.#parameters };\n        out.references = bioc.CLONE(out.references);\n        out.species = bioc.CLONE(out.species);\n        return out;\n    }\n\n    /**\n     * @return {object} Object where each key is the name of a reference and each value is the number of shared features between the test and reference daatasets.\n     */\n    fetchNumberOfSharedFeatures() {\n        let output = {};\n        for (const key of this.#cache.used_refs) {\n            output[key] = this.#cache.prepared[key].built.raw.sharedFeatures();\n        }\n        return output;\n    }\n\n    /****************************\n     ******** Defaults **********\n     ****************************/\n\n    /**\n     * @return {object} Default parameters that may be modified and fed into {@linkcode CellLabellingCore#compute compute}.\n     */\n    static defaults() {\n        return create_defaults();\n    }\n\n    static configureFeatureParameters(guesses) {\n        let best_key = null;\n        let best = { type: \"symbol\", species: \"human\", confidence: 0 };\n\n        if (\"row_names\" in guesses) {\n            let val = guesses.row_names;\n            if (val.confidence > best.confidence) {\n                best = val;\n            }\n        }\n\n        for (const [key, val] of Object.entries(guesses.columns)) {\n           if (val.confidence > best.confidence) {\n                best = val;\n                best_key = key;\n            }\n        }\n\n        return {\n            gene_id_column: best_key,\n            species: [best.species],\n            gene_id_type: best.type.toUpperCase()\n        };\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return fetch_parameters(this.#parameters);\n    }\n\n    /***************************\n     ******** Remotes **********\n     ***************************/\n\n    /**\n     * Available references for each species.\n     * Each key is a taxonomy ID and each value is an array of strings containing the names of references for that species.\n     * @type {object}\n     */\n    static availableReferences = available_references;\n\n    /**\n     * Flush all cached references.\n     *\n     * By default, {@linkcode CellLabellingState#compute compute} will cache the loaded references in a global cache for re-use across {@linkplain CellLabellingState} instances.\n     * These cached references are not tied to any single instance and will not be removed by garbage collectors or by {@linkcode freeAnalysis}.\n     * Rather, this function should be called to release the relevant memory.\n     */\n    static flush() {\n        flush_loaded();\n        return;\n    }\n\n    /**\n     * Specify a function to download references for the cell labelling step.\n     *\n     * @param {function} fun - Function that accepts a single string containing a URL and returns any value that can be used in the {@linkplain SimpleFile} constructor.\n     * This is most typically a Uint8Array of that URL's contents, but it can also be a path to a locally cached file on Node.js.\n     *\n     * @return `fun` is set as the global downloader for this step. \n     * The _previous_ value of the downloader is returned.\n     */\n    static setDownload(fun) {\n        return set_download(fun);\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `cell_labelling` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {?Array} parameters.references - Array of strings specifying the names of the reference datasets, see {@linkcode CellLabellingState.availableReferences availableReferences} for more details.\n     * If `null`, all reference datasets from all species are used.\n     * @param {boolean} parameters.automatic - Automatically choose feature-based parameters based on the feature annotation for the RNA modality.\n     * If `true`, the column of the annotation that best matches human/mouse Ensembl/symbols is identified and used to set `species`, `gene_id_column` and `gene_id_type`.\n     * @param {Array} parameters.species - Array of strings specifying zero, one or more species involved in this dataset.\n     * Each entry should be a taxonomy ID (e.g. `\"9606\"`, `\"10090\"`) as specified in {@linkcode CellLabellingState.availableReferences availableReferences}.\n     * This is used internally to filter `references` to the entries relevant to these species. \n     * Ignored if `automatic = true`.\n     * @param {?(string|number)} parameters.gene_id_column - Name or index of the column of the RNA entry of {@linkcode InputsState#fetchFeatureAnnotations InputsState.fetchFeatureAnnotations} containing the identity of each gene. \n     * If `null`, identifiers are taken from the row names.\n     * Ignored if `automatic = true`.\n     * @param {string} parameters.gene_id_type - Type of feature identifier in `gene_id_column`.\n     * This should be one of `\"ENSEMBL\"`, `\"SYMBOL\"` or `\"ENTREZ\"`\n     * Ignored if `automatic = true`.\n     *\n     * @return The object is updated with the new results.\n     * @async\n     */\n    async compute(parameters) {\n        let references;\n        let automatic;\n        let species;\n        let gene_id_column;\n        let gene_id_type;\n\n        if (\"references\" in parameters) {\n            references = parameters.references;\n            automatic = parameters.automatic;\n            species = parameters.species;\n            gene_id_column = parameters.gene_id_column;\n            gene_id_type = parameters.gene_id_type;\n        } else {\n            references = null;\n            automatic = true;\n            let def = CellLabellingState.defaults();\n            species = def.species;\n            gene_id_column = def.gene_id_column;\n            gene_id_type = def.gene_id_type;\n        }\n\n        this.changed = false;\n\n        if (this.valid()) {\n            this.changed = await build_reference(\n                this.#cache, \n                references, \n                automatic, \n                species, \n                gene_id_column, \n                gene_id_type, \n                this.#parameters, \n                () => this.#inputs.fetchFeatureAnnotations()[\"RNA\"],\n                () => this.#inputs.guessRnaFeatureTypes()\n            );\n        }\n\n        transplant_parameters(\n            references, \n            automatic, \n            species, \n            gene_id_column, \n            gene_id_type, \n            this.#parameters\n        );\n    }\n\n    /**\n     * @param {external:ScranMatrix|external:ScoreMarkersResults} x - A matrix of (normalized or unnormalized) expression values, with genes in rows and cells/clusters in columns.\n     * Alternatively, an object containing marker results, e.g., as computed by {@linkcode MarkerDetectionState}. \n     *\n     * In both cases, the identity of genes should correspond to that in the upstream {@linkcode InputsState}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Array|TypedArray)} [options.group=null] - Array of length equal to the number of columns of `x`, containing grouping assignments.\n     * If provided, the average expression profile of each group is used for cell type labelling.\n     * This is only used if `x` is a {@linkplain external:ScranMatrix ScranMatrix}.\n     * \n     * @return {object} Object containing:\n     *\n     * - `per_reference`: an object where each key is the name of a reference dataset and its value is an array.\n     *   Each array is of length equal to the number of columns of `x` (if matrix), groups in `x` (if marker results), or groups in `group`.\n     *   Each entry is an object containing `best`, the name of the best label assigned to a column/group in this reference;\n     *   and `all`, an object where each key is a label in this reference dataset and its value is the score for assigning that label to this column/group.\n     * - (optional) `integrated`: an array of length equal to the number of columns/groups.\n     *   Each entry is an object containing `best`, the name of the best reference for this column/group;\n     *   and `all`, an object where each key is the name of a reference dataset and its value is the score for this column/group.\n     *   This property is only reported if multiple references are used.\n     * - (optional) `groups`: an array of length equal to the number of groups, containing the identity of each group.\n     *   Only reported if an input `group` is supplied and `x` is a {@linkplain externl:ScranMatrix ScranMatrix}.\n     */\n    computeLabels(x, { group = null } = {}) {\n        return assign_labels(x, group, this.#cache);\n    }\n}\n\n/*****************************\n ******** Standalone *********\n *****************************/\n\n/**\n * Standalone version of {@linkplain CellLabellingState} that provides the same functionality outside of {@linkcode runAnalysis}.\n * Users can supply their own feature annotations to build the reference datasets prior to label assignment.\n * Users should await on the return value of the {@linkcode CellLabellingStandalone#ready ready} method after construction.\n * Once resolved, other methods in this class may be used.\n */\nexport class CellLabellingStandalone {\n    #parameters;\n    #cache;\n    #annotations;\n    #guesses;\n    #pre_parameters;\n\n    /**\n     * @param {external:DataFrame} annotations - Feature annotations for the dataset.\n     */\n    constructor(annotations) {\n        this.#parameters = {};\n        this.#pre_parameters = CellLabellingStandalone.defaults();\n        this.#annotations = annotations;\n        this.#cache = {};\n        this.#guesses = null;\n    }\n\n    free() {\n        flush_prepared(this.#cache);\n    }\n\n    /**\n     * @return {object} Default parameters that may be modified and fed into {@linkcode CellLabellingCore#compute compute}.\n     */\n    static defaults() {\n        return create_defaults();\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return fetch_parameters(this.#pre_parameters);\n    }\n\n    /***************************\n     ******** Remotes **********\n     ***************************/\n\n    /**\n     * Available references for each species.\n     * Each key is a taxonomy ID and each value is an array of strings containing the names of references for that species.\n     * @type {object}\n     */\n    static availableReferences = available_references;\n\n    /**\n     * Flush all cached references.\n     *\n     * By default, this class will cache the loaded references in a global cache for re-use across {@linkplain CellLabellingStandlone} instances.\n     * These cached references are not tied to any single instance and will not be removed by garbage collectors or by {@linkcode CellLabellingStandalone#free free}.\n     * Rather, this function should be called to release the relevant memory.\n     */\n    static flush() {\n        flush_loaded();\n        return;\n    }\n\n    /**\n     * Specify a function to download references for the cell labelling step.\n     *\n     * @param {function} fun - Function that accepts a single string containing a URL and returns any value that can be used in the {@linkplain SimpleFile} constructor.\n     * This is most typically a Uint8Array of that URL's contents, but it can also be a path to a locally cached file on Node.js.\n     *\n     * @return `fun` is set as the global downloader for this step. \n     * The _previous_ value of the downloader is returned.\n     */\n    static setDownload(fun) {\n        return set_download(fun);\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #guessFeatureTypes() {\n        if (this.#guesses == null) {\n            this.#guesses = utils.guessFeatureTypes(this.#annotations);\n        }\n        return this.#guesses;\n    }\n\n    /**\n     * @param {object} parameters - Parameter object, equivalent to the `cell_labelling` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {?Array} parameters.references - Array of strings specifying the names of the reference datasets, see {@linkcode CellLabellingState.availableReferences availableReferences} for more details.\n     * If `null`, all reference datasets from all species are used.\n     * @param {boolean} parameters.automatic - Automatically choose feature-based parameters based on the feature annotation for the RNA modality.\n     * If `true`, the column of the annotation that best matches human/mouse Ensembl/symbols is identified and used to set `species`, `gene_id_column` and `gene_id_type`.\n     * @param {Array} parameters.species - Array of strings specifying zero, one or more species involved in this dataset.\n     * Each entry should be a taxonomy ID (e.g. `\"9606\"`, `\"10090\"`) as specified in {@linkcode CellLabellingState.availableReferences availableReferences}.\n     * This is used internally to filter `references` to the entries relevant to these species. \n     * Ignored if `automatic = true`.\n     * @param {?(string|number)} parameters.gene_id_column - Name or index of the column of the RNA entry of {@linkcode InputsState#fetchFeatureAnnotations InputsState.fetchFeatureAnnotations} containing the identity of each gene. \n     * If `null`, identifiers are taken from the row names.\n     * Ignored if `automatic = true`.\n     * @param {string} parameters.gene_id_type - Type of feature identifier in `gene_id_column`.\n     * This should be one of `\"ENSEMBL\"`, `\"SYMBOL\"` or `\"ENTREZ\"`\n     * Ignored if `automatic = true`.\n     *\n     * @return The object is updated with the new results.\n     * @async\n     */\n    async setParameters(parameters) {\n        let { references, automatic, species, gene_id_column, gene_id_type } = parameters;\n        transplant_parameters(references, automatic, species, gene_id_column, gene_id_type, this.#pre_parameters);\n    }\n\n    /**\n     * This should be called after construction and/or {@linkcode FeatureSetEnrichmenStandalone#setParameters setParameters}. \n     * Users should wait for the return value to resolve before calling any other methods of this class.\n     * \n     * @return Reference datasets are loaded into memory. \n     * @async\n     */\n    async ready() {\n        let { references, automatic, species, gene_id_column, gene_id_type } = this.#pre_parameters;\n\n        await build_reference(\n            this.#cache, \n            references, \n            automatic, \n            species, \n            gene_id_column, \n            gene_id_type, \n            this.#parameters, \n            () => this.#annotations,\n            () => this.#guessFeatureTypes()\n        );\n\n        this.#parameters = this.#pre_parameters;\n    }\n\n    /**\n     * @param {external:ScranMatrix|external:ScoreMarkersResults} x - A matrix of (normalized or unnormalized) expression values, with genes in rows and cells/clusters in columns.\n     * Alternatively, an object containing marker results, e.g., as computed by {@linkcode MarkerDetectionState}. \n     *\n     * In both cases, the identity of genes should correspond to that in `annotations` in the constructor of this instance.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Array|TypedArray)} [options.group=null] - Array of length equal to the number of columns of `x`, containing grouping assignments.\n     * If provided, the average expression profile of each group is used for cell type labelling.\n     * This is only used if `x` is a {@linkplain external:ScranMatrix ScranMatrix}.\n     * \n     * @return {object} Object containing:\n     *\n     * - `per_reference`: an object where each key is the name of a reference dataset and its value is an array.\n     *   Each array is of length equal to the number of columns of `x` (if matrix), groups in `x` (if marker results), or groups in `group`.\n     *   Each entry is an object containing `best`, the name of the best label assigned to a column/group in this reference;\n     *   and `all`, an object where each key is a label in this reference dataset and its value is the score for assigning that label to this column/group.\n     * - (optional) `integrated`: an array of length equal to the number of columns/groups.\n     *   Each entry is an object containing `best`, the name of the best reference for this column/group;\n     *   and `all`, an object where each key is the name of a reference dataset and its value is the score for this column/group.\n     *   This property is only reported if multiple references are used.\n     * - (optional) `groups`: an array of length equal to the number of groups, containing the identity of each group.\n     *   Only reported if an input `group` is supplied and `x` is a {@linkplain external:ScranMatrix ScranMatrix}.\n     */\n    computeLabels(x, { group = null } = {}) {\n        return assign_labels(x, group, this.#cache);\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, inputs) {\n    let parameters = {};\n\n    // Protect against old analysis states that don't have cell_labelling.\n    if (\"cell_labelling\" in handle.children) {\n        let ghandle = handle.open(\"cell_labelling\");\n        \n        {\n            let phandle = ghandle.open(\"parameters\");\n            let mouse_references = phandle.open(\"mouse_references\", { load: true }).values;\n            let human_references = phandle.open(\"human_references\", { load: true }).values;\n            parameters.references = [ ...mouse_references, ...human_references ];\n        }\n    }\n\n    return new CellLabellingState(inputs, parameters);\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as snn_module from \"./snn_graph_cluster.js\";\nimport * as kmeans_module from \"./kmeans_cluster.js\";\n\n/**\n * This step chooses between the k-means and SNN graph clusterings from {@linkplain KmeansClusterState} and {@linkplain SnnGraphClusterState}, respectively.\n * We added this step to preserve the cache for each clustering step - \n * specifically, each clustering does not need to be recomputed when a user changes their choice.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class ChooseClusteringState {\n    #snn_cluster;\n    #kmeans_cluster;\n    #parameters;\n    #cache;\n\n    constructor(snn, kmeans, parameters = null, cache = null) {\n        if (!(snn instanceof snn_module.SnnGraphClusterState)) {\n            throw new Error(\"'snn' should be a State object from './snn_graph_cluster.js'\");\n        }\n        this.#snn_cluster = snn;\n\n        if (!(kmeans instanceof kmeans_module.KmeansClusterState)) {\n            throw new Error(\"'kmeans' should be a State object from './kmeans_cluster.js'\");\n        }\n        this.#kmeans_cluster = kmeans;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {}\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {Int32WasmArray} Array of cluster assignments for each cell in the (filtered) dataset,\n     * available after running {@linkcode ChooseClusteringState#compute compute}.\n     */\n    fetchClusters() {\n        if (this.#parameters.method == \"snn_graph\") {\n            return this.#snn_cluster.fetchClusters();\n        } else if (this.#parameters.method == \"kmeans\") {\n            return this.#kmeans_cluster.fetchClusters();\n        }\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters };\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `choose_clustering` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {string} parameters.method - Clustering method to use, either `\"kmeans\"` or `\"snn_graph\"`.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { method } = parameters;\n        this.changed = true;\n        \n        if (method == this.#parameters.method) {\n            if (method == \"snn_graph\") {\n                if (!this.#snn_cluster.changed) {\n                    this.changed = false;\n                }\n            } else if (method == \"kmeans\") {\n                if (!this.#kmeans_cluster.changed) {\n                    this.changed = false;\n                }\n            }\n        }\n\n        this.#parameters.method = method;\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, snn, kmeans) {\n    let ghandle = handle.open(\"choose_clustering\");\n\n    let parameters;\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            method: phandle.open(\"method\", { load: true }).values[0]\n        };\n    }\n\n    let cache = {};\n    return new ChooseClusteringState(snn, kmeans, parameters, cache);\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as rna_pca_module from \"./rna_pca.js\";\nimport * as adt_pca_module from \"./adt_pca.js\";\nimport * as crispr_pca_module from \"./crispr_pca.js\";\n\nexport const step_name = \"combine_embeddings\";\n\nfunction find_nonzero_upstream_states(pca_states, weights) {\n    let tmp = utils.findValidUpstreamStates(pca_states);\n    let to_use = [];\n    for (const k of tmp) {\n        if (weights[k] > 0) {\n            to_use.push(k);\n        }\n    }\n    return to_use;\n}\n\n/**\n * This step combines multiple embeddings from different modalities into a single matrix for downstream analysis.\n * It wraps the [`scaleByNeighbors`](https://kanaverse.github.io/scran.js/global.html#scaleByNeighbors) function\n * from [**scran.js**](https://kanaverse.github.io/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CombineEmbeddingsState {\n    #pca_states;\n    #parameters;\n    #cache;\n\n    constructor(pca_states, parameters = null, cache = null) {\n        if (!(pca_states.RNA instanceof rna_pca_module.RnaPcaState)) {\n            throw new Error(\"'pca_states.RNA' should be an RnaPcaState object\");\n        }\n        if (!(pca_states.ADT instanceof adt_pca_module.AdtPcaState)) {\n            throw new Error(\"'pca_states.ADT' should be an AdtPcaState object\");\n        }\n        if (!(pca_states.CRISPR instanceof crispr_pca_module.CrisprPcaState)) {\n            throw new Error(\"'pca_states.CRISPR' should be an CrisprPcaState object\");\n        }\n        this.#pca_states = pca_states;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.combined_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {Float64WasmArray} Buffer containing the combined embeddings as a column-major dense matrix,\n     * where the rows are the dimensions and the columns are the cells.\n     * This is available after running {@linkcode CombineEmbeddingsState#compute compute}.\n     */\n    fetchCombined() {\n        return this.#cache.combined_buffer;\n    }\n\n    /**\n     * @return {number} Number of cells in {@linkcode CombineEmbeddingsState#fetchCombined fetchCombined},\n     * available after running {@linkcode CombineEmbeddingsState#compute compute}.\n     */\n    fetchNumberOfCells() {\n        return this.#cache.num_cells;\n    }\n\n    /**\n     * @return {number} Number of dimensions in {@linkcode CombineEmbeddingsState#fetchCombined fetchCombined},\n     * available after running {@linkcode CombineEmbeddingsState#compute compute}.\n     */\n    fetchNumberOfDimensions() {\n        return this.#cache.total_dims;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        // Avoid any pass-by-reference activity.\n        return { ...this.#parameters };\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    static defaults() {\n        return { \n            rna_weight: 1,\n            adt_weight: 1,\n            crispr_weight: 0,\n            approximate: true\n        };\n    }\n\n    static createPcsView(cache, upstream) {\n        utils.freeCache(cache.combined_buffer);\n        cache.combined_buffer = upstream.principalComponents({ copy: \"view\" }).view();\n        cache.num_cells = upstream.numberOfCells();\n        cache.total_dims = upstream.numberOfPCs();\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `adt_normalization` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.rna_weight - Relative weight of the RNA embeddings.\n     * @param {number} parameters.adt_weight - Relative weight of the ADT embeddings.\n     * @param {number} parameters.crispr_weight - Relative weight of the CRISPR embeddings.\n     * @param {boolean} parameters.approximate - Whether an approximate nearest neighbor search should be used by `scaleByNeighbors`.\n     *\n     * @return The object is updated with new results.\n     */\n    compute(parameters) {\n        let { rna_weight, adt_weight, crispr_weight, approximate } = parameters;\n        this.changed = false;\n\n        for (const v of Object.values(this.#pca_states)) {\n            if (v.changed) {\n                this.changed = true;\n                break;\n            }\n        }\n\n        if (approximate !== this.#parameters.approximate) {\n            this.#parameters.approximate = approximate;\n            this.changed = true;\n        }\n\n        if (rna_weight !== this.#parameters.rna_weight || adt_weight !== this.#parameters.adt_weight || crispr_weight !== this.#parameters.crispr_weight) {\n            this.#parameters.rna_weight = rna_weight;\n            this.#parameters.adt_weight = adt_weight;\n            this.#parameters.crispr_weight = crispr_weight;\n            this.changed = true;\n        }\n\n        if (this.changed) { \n            const weights = { RNA: rna_weight, ADT: adt_weight, CRISPR: crispr_weight };\n            let to_use = find_nonzero_upstream_states(this.#pca_states, weights);\n\n            if (to_use.length > 1) {\n                let weight_arr = to_use.map(x => weights[x]);\n                let collected = [];\n                let total = 0;\n                let ncells = null;\n\n                for (const k of to_use) {\n                    let curpcs = this.#pca_states[k].fetchPCs();\n                    collected.push(curpcs.principalComponents({ copy: \"view\" }));\n                    if (ncells == null) {\n                        ncells = curpcs.numberOfCells();\n                    } else if (ncells !== curpcs.numberOfCells()) {\n                        throw new Error(\"number of cells should be consistent across all embeddings\");\n                    }\n                    total += curpcs.numberOfPCs();\n                }\n\n                let buffer = utils.allocateCachedArray(ncells * total, \"Float64Array\", this.#cache, \"combined_buffer\");\n                scran.scaleByNeighbors(collected, ncells, { buffer: buffer, weights: weight_arr, approximate: approximate });\n                this.#cache.num_cells = ncells;\n                this.#cache.total_dims = total;\n\n            } else {\n                // If there's only one embedding, we shouldn't respond to changes\n                // in parameters, because they won't have any effect.\n                let pcs = this.#pca_states[to_use[0]].fetchPCs();\n                this.constructor.createPcsView(this.#cache, pcs);\n            }\n        }\n\n        // Updating all parameters anyway. This requires us to take ownership\n        // of 'weights' to avoid pass-by-reference shenanigans.\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, pca_states) {\n    let cache = {};\n    let parameters = CombineEmbeddingsState.defaults();\n    let output;\n\n    try {\n        if (step_name in handle.children) {\n            let ghandle = handle.open(step_name);\n\n            {\n                let phandle = ghandle.open(\"parameters\");\n                parameters.approximate = phandle.open(\"approximate\", { load: true }).values[0] > 0;\n\n                if ('weights' in phandle.children) { // v2.0\n                    let whandle = phandle.open(\"weights\");\n                    if (\"RNA\" in whandle.children) {\n                        parameters.rna_weight = whandle.open(\"RNA\", { load: true }).values[0];\n                    }\n                    if (\"ADT\" in whandle.children) {\n                        parameters.adt_weight = whandle.open(\"ADT\", { load: true }).values[0];\n                    }\n                    if (\"CRISPR\" in whandle.children) {\n                        parameters.crispr_weight = whandle.open(\"CRISPR\", { load: true }).values[0];\n                    }\n                } else {\n                    parameters.rna_weight = phandle.open(\"rna_weight\", { load: true }).values[0];\n                    parameters.adt_weight = phandle.open(\"adt_weight\", { load: true }).values[0];\n                    parameters.crispr_weight = phandle.open(\"crispr_weight\", { load: true }).values[0];\n                }\n            }\n\n            let rhandle = ghandle.open(\"results\");\n\n            if (\"combined\" in rhandle.children) {\n                let phandle = rhandle.open(\"combined\", { load: true });\n                cache.num_cells = phandle.shape[0];\n                cache.total_dims = phandle.shape[1];\n\n                let vals = phandle.values;\n                cache.combined_buffer = scran.createFloat64WasmArray(vals.length);\n                cache.combined_buffer.set(vals);\n            }\n        }\n\n        if (!(\"combined_buffer\" in cache)) {\n            // This only happens if there was only one upstream PCA state; in which case, \n            // we figure out which upstream PCA state contains the PC vector\n            // and create a view on it so that our fetchPCs() works properly.\n            // (v1 and earlier also implicitly falls in this category.)\n            const weights = { RNA: parameters.rna_weight, ADT: parameters.adt_weight, CRISPR: parameters.crispr_weight };\n            let to_use = find_nonzero_upstream_states(pca_states, weights);\n\n            if (to_use.length != 1) {\n                throw new Error(\"only one upstream PCA state should be valid with non-zero weight if 'combined' is not available\");\n            }\n\n            let pcs = pca_states[to_use[0]].fetchPCs();\n            CombineEmbeddingsState.createPcsView(cache, pcs);\n        }\n\n        output = new CombineEmbeddingsState(pca_states, parameters, cache);\n    } catch (e) {\n        utils.freeCache(cache.combined_buffer);\n        utils.freeCache(output);\n        throw e;\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as nutils from \"./utils/normalization.js\";\nimport * as qc_module from \"./crispr_quality_control.js\";\nimport * as filter_module from \"./cell_filtering.js\";\n\nexport const step_name = \"crispr_normalization\";\n\n/**\n * This step performs normalization and log-transformation on the QC-filtered CRISPR count matrix from the {@linkplain CellFilteringState}.\n * It wraps the [`logNormCounts`](https://kanaverse.github.io/scran.js/global.html#logNormCounts) functions\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CrisprNormalizationState {\n    #qc;\n    #filter;\n    #parameters;\n    #cache;\n\n    constructor(qc, filter, parameters = null, cache = null) {\n        if (!(qc instanceof qc_module.CrisprQualityControlState)) {\n            throw new Error(\"'qc' should be a CrisprQualityControlState object\");\n        }\n        this.#qc = qc;\n\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.matrix);\n        utils.freeCache(this.#cache.total_buffer);\n        utils.freeCache(this.#cache.centered_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        let filtered = this.#filter.fetchFilteredMatrix();\n        return filtered.has(\"CRISPR\");\n    }\n\n    /**\n     * @return {external:ScranMatrix} A {@linkplain external:ScranMatrix ScranMatrix} object containing the normalized CRISPR abundances,\n     * available after running {@linkcode CrisprNormalizationState#compute compute}.\n     */\n    fetchNormalizedMatrix() {\n        if (!(\"matrix\" in this.#cache)) {\n            this.#raw_compute();\n        }\n        return this.#cache.matrix;\n    }\n\n    /**\n     * @return {Float64WasmArray} Array of length equal to the number of cells, \n     * containing the CRISPR-derived size factor for each cell.\n     * This is available after running {@linkcode RnaNormalizationState#compute compute}.\n     */\n    fetchSizeFactors() {\n        let buff;\n        if (this.#cache.sum_buffer) {\n            buff = utils.allocateCachedArray(this.#cache.sum_buffer.length, \"Float64Array\", this.#cache, \"centered_buffer\");\n            scran.centerSizeFactors(this.#cache.sum_buffer, { buffer: buff, block: this.#filter.fetchFilteredBlock() })\n        }\n        return buff;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #raw_compute() {\n        var mat = this.#filter.fetchFilteredMatrix().get(\"CRISPR\");\n        let buffer = nutils.subsetSums(this.#qc, this.#filter, mat, this.#cache, \"sum_buffer\");\n\n        var block = this.#filter.fetchFilteredBlock();\n        utils.freeCache(this.#cache.matrix);\n        this.#cache.matrix = scran.logNormCounts(mat, { sizeFactors: buffer, block: block, allowZeros: true });\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `crispr_normalization` property of the `parameters` of {@linkcode runAnalysis}.\n     *\n     * @return The object is updated with new results.\n     */\n    compute(parameters) {\n        this.changed = false;\n        if (this.#qc.changed || this.#filter.changed) {\n            if (this.valid()) {\n                this.#raw_compute();\n                this.changed = true;\n            }\n        } \n\n        return;\n    }\n\n    static defaults() {\n        return {};\n    }\n\n    /*************************\n     ******** Saving *********\n     *************************/\n\n    serialize(handle) {\n        let ghandle = handle.createGroup(step_name);\n        let phandle = ghandle.createGroup(\"parameters\"); \n        let rhandle = ghandle.createGroup(\"results\"); \n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, qc, filter) {\n    return new CrisprNormalizationState(qc, filter);\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as norm_module from \"./crispr_normalization.js\";\n\nexport const step_name = \"crispr_pca\";\n\n/**\n * This step performs a principal components analysis (PCA) to compact and denoise CRISPR abundance data.\n * The resulting PCs can be used as input to various per-cell analyses like clustering and dimensionality reduction.\n * It wraps the [`runPCA`](https://kanaverse.github.io/scran.js/global.html#runPCA) function\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CrisprPcaState {\n    #filter;\n    #norm;\n    #cache;\n    #parameters;\n\n    constructor(filter, norm, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(norm instanceof norm_module.CrisprNormalizationState)) {\n            throw new Error(\"'norm' should be a CrisprNormalizationState object\");\n        }\n        this.#norm = norm;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.pcs);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        return this.#norm.valid();\n    }\n\n    /**\n     * @return {external:RunPCAResults} Results of the PCA on the normalized CRISPR abundance matrix,\n     * available after running {@linkcode CrisprPcaState#compute compute}.\n     */\n    fetchPCs() {\n        return this.#cache.pcs;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `crispr_pca` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.num_pcs - Number of PCs to return.\n     * @param {string} parameters.block_method - Blocking method to use when dealing with multiple samples.\n     * This can be `\"none\"`, `\"regress\"` or `\"weight\"`, see comments in {@linkplain RnaPcaState}.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { num_pcs, block_method } = parameters;\n        this.changed = false;\n\n        if (this.#norm.changed || num_pcs !== this.#parameters.num_pcs || block_method !== this.#parameters.block_method) { \n            if (this.valid()) {\n                let block = this.#filter.fetchFilteredBlock();\n                var mat = this.#norm.fetchNormalizedMatrix();\n                utils.freeCache(this.#cache.pcs);\n                this.#cache.pcs = scran.runPCA(mat, { numberOfPCs: num_pcs, block: block, blockMethod: block_method });\n\n                this.changed = true;\n            }\n\n            this.#parameters.num_pcs = num_pcs;\n            this.#parameters.block_method = block_method;\n        }\n\n        return;\n    }\n\n    static defaults() {\n        return {\n            num_pcs: 20,\n            block_method: \"none\"\n        };\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, filter, norm) {\n    let cache = {};\n    let parameters = CrisprPcaState.defaults();\n    let output;\n\n    if (step_name in handle.children) {\n        let ghandle = handle.open(step_name);\n\n        let phandle = ghandle.open(\"parameters\"); \n        parameters.num_pcs = phandle.open(\"num_pcs\", { load: true }).values[0];\n        parameters.block_method = phandle.open(\"block_method\", { load: true }).values[0];\n\n        try {\n            let rhandle = ghandle.open(\"results\");\n\n            if (\"var_exp\" in rhandle.children) {\n                let pcs_handle = rhandle.open(\"pcs\", { load: true });\n                let pcs = pcs_handle.values;\n                let var_exp = rhandle.open(\"var_exp\", { load: true }).values;\n\n                cache.pcs = scran.emptyRunPCAResults(pcs_handle.shape[0], pcs_handle.shape[1]);\n                cache.pcs.principalComponents({ fillable: true }).set(pcs);\n                cache.pcs.varianceExplained({ fillable: true }).set(var_exp);\n                cache.pcs.setTotalVariance(1); // because the file only stores proportions.\n            }\n\n            output = new CrisprPcaState(filter, norm, parameters, cache);\n        } catch (e) {\n            utils.freeCache(cache.pcs);\n            utils.freeCache(output);\n            throw e;\n        }\n    } else {\n        output = new CrisprPcaState(filter, norm, parameters, cache);\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as inputs_module from \"./inputs.js\";\n\nexport const step_name = \"crispr_quality_control\";\n\n/**\n * Results of computing per-cell CRISPR-derived QC metrics,\n * see [here](https://kanaverse.github.io/scran.js/PerCellCrisprQcMetricsResults.html) for details.\n *\n * @external PerCellCrisprQcMetricsResults\n */\n\n/**\n * Suggested filters for the CRISPR-derived QC metrics,\n * see [here](https://kanaverse.github.io/scran.js/SuggestCrisprQcFiltersResults.html) for details.\n *\n * @external SuggestCrisprQcFiltersResults\n */\n\n/**\n * This step applies quality control on the CRISPR guide count matrix.\n * Specifically, it computes the QC metrics and filtering thresholds, \n * wrapping the [`perCellCrisprQcMetrics`](https://kanaverse.github.io/scran.js/global.html#perCellCrisprQcMetrics)\n * and [`suggestCrisprQcFilters`](https://kanaverse.github.io/scran.js/global.html#suggestCrisprQcFilters) functions\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n * Note that the actual filtering is done by {@linkplain CellFilteringState}.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CrisprQualityControlState {\n    #inputs;\n    #cache;\n    #parameters;\n\n    constructor(inputs, parameters = null, cache = null) {\n        if (!(inputs instanceof inputs_module.InputsState)) {\n            throw new Error(\"'inputs' should be a State object from './inputs.js'\");\n        }\n        this.#inputs = inputs;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.metrics);\n        utils.freeCache(this.#cache.filters);\n        utils.freeCache(this.#cache.metrics_buffer);\n        utils.freeCache(this.#cache.discard_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        let input = this.#inputs.fetchCountMatrix();\n        return input.has(\"CRISPR\");\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /**\n     * @return {external:SuggestCrisprQcFiltersResults} Result of filtering on the CRISPR-derived QC metrics.\n     * This is available after running {@linkcode CrisprQualityControlState#compute compute}.\n     */\n    fetchFilters() {\n        return this.#cache.filters;\n    }\n\n    /**\n     * @return {Uint8WasmArray} Buffer containing the discard vector of length equal to the number of cells,\n     * where each element is truthy if the corresponding cell is to be discarded.\n     * This is available after running {@linkcode CrisprQualityControlState#compute compute}.\n     */\n    fetchDiscards() {\n        return this.#cache.discard_buffer;\n    }\n\n    /**\n     * @return {external:PerCellCrisprQcMetricsResults} CRISPR-derived QC metrics,\n     * available after running {@linkcode CrisprQualityControlState#compute compute}.\n     */\n    fetchMetrics() {\n        return this.#cache.metrics;\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    static defaults() {\n        return {\n            nmads: 3\n        };\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `crispr_quality_control` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.nmads - Number of MADs to use for automatically selecting the filter threshold on the maximum count. \n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { nmads } = parameters;\n        this.changed = false;\n\n        if (this.#inputs.changed) {\n            utils.freeCache(this.#cache.metrics);\n\n            if (this.valid()) {\n                var mat = this.#inputs.fetchCountMatrix().get(\"CRISPR\");\n                this.#cache.metrics = scran.perCellCrisprQcMetrics(mat);\n                this.changed = true;\n            } else {\n                delete this.#cache.metrics;\n            }\n        }\n\n        if (this.changed || nmads !== this.#parameters.nmads) {\n            utils.freeCache(this.#cache.filters);\n\n            if (this.valid()) {\n                let block = this.#inputs.fetchBlock();\n                this.#cache.filters = scran.suggestCrisprQcFilters(this.#cache.metrics, { numberOfMADs: nmads, block: block });\n                var discard = utils.allocateCachedArray(this.#cache.metrics.numberOfCells(), \"Uint8Array\", this.#cache, \"discard_buffer\");\n                this.#cache.filters.filter(this.#cache.metrics, { block: block, buffer: discard });\n                this.changed = true;\n            } else {\n                delete this.#cache.filters;\n            }\n\n            this.#parameters.nmads = nmads;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, inputs) {\n    let cache = {};\n    let parameters = CrisprQualityControlState.defaults();\n    let output;\n\n    if (step_name in handle.children) {\n        let ghandle = handle.open(step_name);\n\n        let phandle = ghandle.open(\"parameters\"); \n        parameters.nmads = phandle.open(\"nmads\", { load: true }).values[0];\n\n        try {\n            let rhandle = ghandle.open(\"results\");\n\n            if (\"metrics\" in rhandle.children) { // if skip=true or valid() is false, QC metrics may not be reported.\n                let mhandle = rhandle.open(\"metrics\");\n\n                let detected = mhandle.open(\"detected\", { load: true }).values;\n                cache.metrics = scran.emptyPerCellCrisprQcMetricsResults(detected.length);\n                cache.metrics.detected({ fillable: true }).set(detected);\n\n                let sums = mhandle.open(\"sums\", { load: true }).values;\n                cache.metrics.sums({ fillable: true }).set(sums);\n\n                let max_prop = mhandle.open(\"max_proportion\", { load: true }).values;\n                cache.metrics.maxProportions({ fillable: true }).set(max_prop);\n\n                let max_index = mhandle.open(\"max_index\", { load: true }).values;\n                cache.metrics.maxIndex({ fillable: true }).set(max_index);\n            }\n\n            if (\"thresholds\" in rhandle.children) { // if skip=true or valid() is false, QC thresholds may not be reported.\n                let discards = rhandle.open(\"discards\", { load: true }).values; \n                cache.discard_buffer = scran.createUint8WasmArray(discards.length);\n                cache.discard_buffer.set(discards);\n\n                let thandle = rhandle.open(\"thresholds\");\n                let thresholds_max_count = thandle.open(\"max_count\", { load: true }).values;\n\n                cache.filters = scran.emptySuggestCrisprQcFiltersResults(thresholds_max_count.length);\n                cache.filters.thresholdsMaxCount({ fillable: true }).set(thresholds_max_count);\n            }\n\n            output = new CrisprQualityControlState(inputs, parameters, cache);\n        } catch (e) {\n            utils.freeCache(cache.metrics);\n            utils.freeCache(cache.filters)\n            utils.freeCache(output);\n            throw e;\n        }\n    } else {\n        // Fallback if the results aren't available. \n        output = new CrisprQualityControlState(inputs, parameters, cache);\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as norm_module from \"./rna_normalization.js\";\n\n/**\n * Results of per-gene variance modelling,\n * see [here](https://kanaverse.github.io/scran.js/ModelGeneVarResults.html) for details.\n *\n * @external ModelGeneVarResults\n */\n\n/**\n * Feature selection is performed by modelling the per-gene variance and finding highly variable genes.\n * This wraps the [`modelGeneVar`](https://kanaverse.github.io/scran.js/global.html#modelGeneVar) function \n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class FeatureSelectionState {\n    #filter;\n    #norm;\n    #cache;\n    #parameters;\n\n    constructor(filter, norm, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(norm instanceof norm_module.RnaNormalizationState)) {\n            throw new Error(\"'norm' should be an RnaNormalizationState object\");\n        }\n        this.#norm = norm;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.matrix);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        return this.#norm.valid();\n    }\n\n    /**\n     * @return {external:ModelGeneVarResults} Variance modelling results,\n     * available after running {@linkcode FeatureSelectionState#compute compute}.\n     */\n    fetchResults() {\n        return this.#cache.results;\n    }\n\n    /**\n     * @return {Float64Array} Array of length equal to the number of genes,\n     * containing the sorted residuals after fitting a mean-dependent trend to the variances.\n     * Available after running {@linkcode FeatureSelectionState#compute compute}.\n     */\n    fetchSortedResiduals() {\n        return this.#cache.sorted_residuals;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference activity.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n \n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `feature_selection` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.span - Value between 0 and 1 specifying the span for the LOWESS smoother.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { span } = parameters;\n        this.changed = false;\n        \n        if (this.#norm.changed || span != this.#parameters.span) {\n            utils.freeCache(this.#cache.results);\n\n            if (this.valid()) {\n                let mat = this.#norm.fetchNormalizedMatrix();\n                let block = this.#filter.fetchFilteredBlock();\n                this.#cache.results = scran.modelGeneVar(mat, { span: span, block: block });\n\n                this.#cache.sorted_residuals = this.#cache.results.residuals().slice(); // a separate copy.\n                this.#cache.sorted_residuals.sort();\n\n                this.changed = true;\n            }\n\n            this.#parameters.span = span;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, permuter, filter, norm) {\n    let ghandle = handle.open(\"feature_selection\");\n\n    let parameters;\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            span: phandle.open(\"span\", { load: true }).values[0]\n        };\n    }\n\n    let cache = {};\n    {\n        let rhandle = ghandle.open(\"results\");\n\n        if (\"means\" in rhandle.children) {\n            // Possibly permuting it to match the new permutation order;\n            // see 'unserialize' in 'inputs.js'.\n            let reloaded = {};\n            for (const key of [ \"means\", \"vars\", \"fitted\", \"resids\" ]) {\n                let value = rhandle.open(key, { load: true }).values;\n                reloaded[key] = permuter(value);\n            }\n\n            cache.results = scran.emptyModelGeneVarResults(reloaded.means.length, 1);\n            cache.results.means({ fillable: true }).set(reloaded.means);\n            cache.results.variances({ fillable: true }).set(reloaded.vars);\n            cache.results.fitted({ fillable: true }).set(reloaded.fitted);\n            cache.results.residuals({ fillable: true }).set(reloaded.resids);\n\n            cache.sorted_residuals = cache.results.residuals({ copy: true });\n            cache.sorted_residuals.sort();\n        }\n    }\n\n    return new FeatureSelectionState(filter, norm, parameters, cache);\n}\n\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as correct_module from \"./batch_correction.js\";\n\n/**\n * This step performs k-means clustering on the PCs, \n * wrapping the [`clusterKmeans`](https://kanaverse.github.io/scran.js/global.html#clusterKmeans) function \n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class KmeansClusterState {\n    #correct;\n    #parameters;\n    #cache;\n\n    constructor(correct, parameters = null, cache = null) {\n        if (!(correct instanceof correct_module.BatchCorrectionState)) {\n            throw new Error(\"'correct' should be a BatchCorrectionState object\");\n        }\n        this.#correct = correct;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.raw);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {Int32WasmArray} Array of cluster assignments for each cell in the (filtered) dataset,\n     * available after running {@linkcode KmeansClusterState#compute compute}.\n     */\n    fetchClusters() {\n        if (!this.#valid()) {\n            throw new Error(\"cannot fetch k-means clusters from an invalid state\");\n        } else {\n            return this.#cache.raw.clusters({ copy: \"view\" });\n        }\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters };\n    };\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #valid() {\n        return \"raw\" in this.#cache;\n    }\n\n    /** \n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {boolean} run_me - Whether or not to run this step, depending on the clustering method chosen by the user (see {@linkplain ChooseClusteringState}).\n     * @param {object} parameters - Parameter object, equivalent to the `choose_clustering` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.k - Number of clusters to create.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(run_me, parameters) {\n        let { k } = parameters;\n        this.changed = false;\n\n        if (this.#correct.changed || k != this.#parameters.k || (!this.#valid() && run_me)) {\n            utils.freeCache(this.#cache.raw);\n\n            if (run_me) {\n                var pcs = this.#correct.fetchCorrected();\n                this.#cache.raw = scran.clusterKmeans(pcs, k, { \n                    numberOfDims: this.#correct.fetchNumberOfDimensions(),\n                    numberOfCells: this.#correct.fetchNumberOfCells(),\n                    initMethod: \"pca-part\" \n                });\n            } else {\n                delete this.#cache.raw; // ensure this step gets re-run later when run_me = true. \n            }\n\n            this.#parameters.k = k;\n            this.changed = true;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, pca) {\n    let parameters = {\n        k: 10\n    };\n    let cache = {};\n\n    // Protect against old analysis states that don't have kmeans_cluster.\n    if (\"kmeans_cluster\" in handle.children) {\n        let ghandle = handle.open(\"kmeans_cluster\");\n\n        {\n            let phandle = ghandle.open(\"parameters\");\n            parameters.k = phandle.open(\"k\", { load: true }).values[0];\n        }\n\n        {\n            let rhandle = ghandle.open(\"results\");\n            if (\"clusters\" in rhandle.children) {\n                let clusters = rhandle.open(\"clusters\", { load: true }).values;\n                cache.raw = scran.emptyClusterKmeansResults(clusters.length, parameters.k, pca.fetchNumberOfDimensions());\n                cache.raw.clusters({ fillable: true }).set(clusters);\n            }\n        }\n    }\n\n    return new KmeansClusterState(pca, parameters, cache);\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as markers from \"./utils/markers.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as choice_module from \"./choose_clustering.js\";\nimport * as rna_norm_module from \"./rna_normalization.js\";\nimport * as adt_norm_module from \"./adt_normalization.js\";\nimport * as crispr_norm_module from \"./crispr_normalization.js\";\n\nexport const step_name = \"marker_detection\";\n\n/**\n * Results of marker detection,\n * see [here](https://www.kanaverse.github.io/scran.js/ScoreMarkersResults.html) for details.\n *\n * @external ScoreMarkersResults\n */\n\n/*********************\n ***** Internals *****\n *********************/\n\nfunction _free(cache) {\n    for (const v of Object.values(cache.raw)) {\n        utils.freeCache(v);\n    }\n    cache.raw = {};\n    markers.freeVersusResults(cache.versus);\n    delete cache.versus;\n}\n\nfunction _computeVersus(left, right, matrices, clusters, { cache = {}, block = null, lfc_threshold = 0, compute_auc = true } = {}) {\n    let cache_info = markers.locateVersusCache(left, right, cache);\n    let left_index = (cache_info.left_small ? 0 : 1);\n    let right_index = (cache_info.left_small ? 1 : 0);\n\n    if (cache_info.run) {\n        let new_clusters = [];\n        let keep = [];\n        let leftfound = false, rightfound = false;\n        clusters.forEach((x, i) => {\n            if (x == left) {\n                new_clusters.push(left_index);\n                keep.push(i);\n                leftfound = true;\n            } else if (x == right) {\n                new_clusters.push(right_index);\n                keep.push(i);\n                rightfound = true;\n            }\n        });\n\n        if (!leftfound || !rightfound) {\n            throw new Error(\"non-zero entries should be present for both requested clusters in versus mode\");\n        }\n\n        markers.computeVersusResults(matrices, new_clusters, block, keep, cache_info.cached, lfc_threshold, compute_auc);\n    }\n\n    return { \n        results: cache_info.cached,\n        left: left_index,\n        right: right_index\n    };\n}\n\n/*****************\n ***** State *****\n *****************/\n\n/**\n * This step performs marker detection for each cluster of cells by performing pairwise comparisons to each other cluster.\n * This wraps the [`scoreMarkers`](https://kanaverse.github.io/scran.js/global.html#scoreMarkers) function \n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n * The clustering is obtained from the upstream {@linkplain ChooseClusteringState}.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class MarkerDetectionState {\n    #filter;\n    #norm_states;\n    #choice;\n    #parameters;\n    #cache;\n\n    constructor(filter, norm_states, choice, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a State object from './cell_filtering.js'\");\n        }\n        this.#filter = filter;\n\n        if (!(norm_states.RNA instanceof rna_norm_module.RnaNormalizationState)) {\n            throw new Error(\"'norm_states.RNA' should be an RnaNormalizationState object\");\n        }\n        if (!(norm_states.ADT instanceof adt_norm_module.AdtNormalizationState)) {\n            throw new Error(\"'norm_states.ADT' should be an AdtNormalizationState object\");\n        }\n        if (!(norm_states.CRISPR instanceof crispr_norm_module.CrisprNormalizationState)) {\n            throw new Error(\"'norm_states.CRISPR' should be an CrisprNormalizationState object\");\n        }\n        this.#norm_states = norm_states;\n\n        if (!(choice instanceof choice_module.ChooseClusteringState)) {\n            throw new Error(\"'choice' should be a State object from './choose_clustering.js'\");\n        }\n        this.#choice = choice;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? { \"raw\": {} } : cache);\n        this.changed = false;\n    }\n\n    /**\n     * Frees all resources associated with this instance.\n     */\n    free() {\n        _free(this.#cache);\n    }\n\n    /**\n     * Obtain the marker detection results for all modalities.\n     * It is assumed that {@linkcode runAnalysis} was already run on this MarkerDetectionState instance before calling this method.\n     *\n     * @return {object} Object where each key is a modality name and each value is an {@linkplain external:ScoreMarkersResults ScoreMarkerResults} object,\n     * containing marker detection statistics for all clusters.\n     */\n    fetchResults() {\n        return this.#cache.raw;\n    }\n\n    /**\n     * Parameters used to compute the results.\n     * It is assumed that {@linkcode runAnalysis} was already run on this MarkerDetectionState instance before calling this method.\n     *\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `marker_detection` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.lfc_threshold - Log-fold change threshold to use when computing the Cohen's d and AUC for each pairwise comparison.\n     * @param {boolean} parameters.compute_auc - Whether to compute the AUCs.\n     * Setting this to `false` will skip AUC calculations and improve speed and memory efficiency.\n     *\n     * @return The state is updated with new results.\n     */\n    compute(parameters) {\n        let { lfc_threshold, compute_auc } = parameters;\n        this.changed = false;\n        let changed_params = (lfc_threshold !== this.#parameters.lfc_threshold || compute_auc !== this.#parameters.compute_auc);\n        \n        for (const [k, v] of Object.entries(this.#norm_states)) {\n            if (!v.valid()) {\n                continue;\n            }\n\n            if (this.#choice.changed || v.changed || changed_params) {\n                var mat = v.fetchNormalizedMatrix();\n                var clusters = this.#choice.fetchClusters();\n                var block = this.#filter.fetchFilteredBlock();\n                \n                utils.freeCache(this.#cache.raw[k]);\n                this.#cache.raw[k] = scran.scoreMarkers(mat, clusters, { block: block, lfcThreshold: lfc_threshold, computeAuc: compute_auc });\n\n                this.changed = true;\n            }\n        }\n\n        this.#parameters.lfc_threshold = lfc_threshold;\n        this.#parameters.compute_auc = compute_auc;\n        if (this.changed) {\n            markers.freeVersusResults(this.#cache.versus);\n        }\n\n        return;\n    }\n\n    /**\n     * @return {object} Default parameters that may be modified and fed into {@linkcode MarkerDetectionCore#compute compute}.\n     */\n    static defaults() {\n        return {\n            lfc_threshold: 0,\n            compute_auc: true\n        };\n    }\n\n    // Soft-deprecated.\n    static computeVersusCustom(left, right, matrices, clusters, { cache = {}, block = null, lfc_threshold = 0, compute_auc = true } = {}) {\n        return computeVersus(left, right, matrices, clusters, { cache, block, lfc_threshold, compute_auc });\n    }\n\n    /**\n     * Extract markers for a pairwise comparison between two clusters for more detailed examination of the differences between them.\n     * It is assumed that {@linkcode runAnalysis} was already run on this MarkerDetectionState instance before calling this method.\n     *\n     * @param {number} left - Index of one cluster in which to find upregulated markers.\n     * @param {number} right - Index of another cluster to be compared against `left`.\n     *\n     * @return {object} Object containing:\n     *\n     * - `results`: object containing the marker statistics for the comparison between two clusters.\n     *    Each key is a modality name and each value is a {@linkplain external:ScoreMarkersResults ScoreMarkersResults} object.\n     * - `left`: index of the group corresponding to the `left` cluster in each ScoreMarkersResults object,\n     *    e.g., Cohen's d for the RNA markers of the `left` cluster are defined as `output.results.RNA.cohen(output.left)`.\n     * - `right`: index of the group corresponding to the `right` cluster in each ScoreMarkersResults object.\n     *    e.g., Cohen's d for the RNA markers of the `left` cluster are defined as `output.results.RNA.cohen(output.right)`.\n     */\n    computeVersus(left, right) {\n        var clusters = this.#choice.fetchClusters();\n        var block = this.#filter.fetchFilteredBlock();\n\n        // No need to free this afterwards; we don't own the normalized matrices anyway.\n        let matrices = new scran.MultiMatrix;\n        for (const [modality, state] of Object.entries(this.#norm_states)) {\n            if (!state.valid()) {\n                continue;\n            }\n            matrices.add(modality, state.fetchNormalizedMatrix());\n        }\n\n        if (!(\"versus\" in this.#cache)) {\n            this.#cache[\"versus\"] = {};\n        }\n\n        return _computeVersus(left, right, matrices, clusters, { \n            cache: this.#cache.versus, \n            block: block,\n            lfc_threshold: this.#parameters.lfc_threshold,\n            compute_auc: this.#parameters.compute_auc\n        });\n    }\n}\n\n/**********************\n ***** Standalone *****\n **********************/\n\n/**\n * Standalone version of {@linkplain MarkerDetectionState} that provides the same functionality outside of {@linkcode runAnalysis}.\n * Users can supply their own normalized matrices, groups and blocking factor to compute the various marker statistics for each group.\n * Users are also responsible for ensuring that the lifetime of the supplied objects exceeds that of the constructed MarkerDetectionStandalone instance,\n * i.e., the Wasm-related `free()` methods are not called while the MarkerDetectionStandalone instance is still in operation.\n */\nexport class MarkerDetectionStandalone {\n    #matrices;\n\n    #groups;\n    #group_levels;\n    #block;\n    #block_levels;\n\n    #cache;\n    #parameters;\n\n    /**\n     * @param {external:MultiMatrix} normalized - A {@linkplain external:MultiMatrix MultiMatrix} of log-normalized values for multiple modalities.\n     * @param {Array|TypedArray} groups - Array of length equal to the number of columns in any value of `normalized`, containing the group assignments for each column. \n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Array|TypedArray)} [options.block=null] - Array of length equal to the number of columns in any value of `normalized`, containing the block assignments for each column.\n     * If `null`, all columns are assigned to the same block.\n     */\n    constructor(normalized, groups, { block = null } = {}) {\n        // Checking dimensions.\n        let N = groups.length;\n\n        for (const k of normalized.available()) {\n            let v = normalized.get(k);\n            if (v.numberOfColumns() != N) {\n                throw new Error(\"all matrices in 'normalized' should have the same number of columns as the length of 'groups'\");\n            }\n        }\n\n        if (block !== null) {\n            if (block.length != N) {\n                throw new Error(\"'block' should have the same length as 'groups' if not null\");\n            }\n        }\n\n        let arrays = [ groups ];\n        if (block !== null) {\n            arrays.push(block);\n        }\n        let dump = utils.subsetInvalidFactors(arrays);\n\n        // Maybe taking a subset to eliminate invalid entries.\n        let new_matrices;\n        if (dump.retain !== null) {\n            new_matrices = new scran.MultiMatrix;\n            let temp = scran.createInt32WasmArray(dump.retain.length);\n            try {\n                temp.set(dump.retain);\n                for (const k of normalized.available()) {\n                    new_matrices.add(k, scran.subsetColumns(normalized.get(k), temp))\n                }\n            } catch (e) {\n                new_matrices.free();\n                throw e;\n            } finally {\n                scran.free(temp);\n            }\n        } else {\n            new_matrices = normalized.clone();\n        }\n\n        this.#matrices = new_matrices;\n        this.#groups = dump.arrays[0].ids;\n        this.#group_levels = dump.arrays[0].levels;\n\n        if (block !== null) {\n            this.#block = dump.arrays[1].ids;\n            this.#block_levels = dump.arrays[1].levels;\n        } else {\n            this.#block = null;\n            this.#block_levels = null;\n        }\n\n        this.#cache = { raw: {}, init: true };\n        this.#parameters = MarkerDetectionState.defaults();\n        this.changed = false;\n    }\n\n    /**\n     * Frees all resources associated with this instance.\n     */\n    free() {\n        scran.free(this.#groups);\n        scran.free(this.#block);\n        scran.free(this.#matrices);\n        _free(this.#cache);\n    }\n\n    /**\n     * @return {object} Marker detection results for the all modalities.\n     * Each key is a modality name and each value is an {@linkplain external:ScoreMarkersResults ScoreMarkerResults} object,\n     * containing marker detection statistics for all groups.\n     * This is available after running {@linkcode MarkerDetectionState#compute compute}.\n     */\n    fetchResults() {\n        return this.#cache.raw;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the return value on output.\n     * Set to `false` for greater efficiency in strictly read-only applications.\n     *\n     * @return {Array} Array of levels for the grouping factor.\n     * Group indices in the {@linkplain external:ScoreMarkersResults ScoreMarkersResults} instances returned by {@linkcode fetchResults} can be cross-referenced to this array.\n     */\n    fetchGroupLevels({ copy = true } = {}) {\n        let ret = this.#group_levels;\n        return (copy ? ret.slice() : ret);\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the return value on output.\n     * Set to `false` for greater efficiency in strictly read-only applications.\n     *\n     * @return {Array} Array of levels for the blocking factor.\n     * Block indices in the {@linkplain external:ScoreMarkersResults ScoreMarkersResults} instances returned by {@linkcode fetchResults} can be cross-referenced to this array.\n     */\n    fetchBlockLevels({ copy = true } = {}) {\n        let ret = this.#block_levels;\n        return (copy ? ret.slice() : ret);\n    }\n\n    // Testing functions to check that the sanitization worked correctly.\n    _peekMatrices() {\n        return this.#matrices;\n    }\n\n    _peekGroups() {\n        return this.#groups;\n    }\n\n    _peekBlock() {\n        return this.#block;\n    }\n\n    /**\n     * If this method is not called, the parameters default to those in {@linkcode MarkerDetectionState#defaults MarkerDetectionState.defaults}.\n     *\n     * @param {object} parameters - Parameter object, see the argument of the same name in {@linkcode MarkerDetectionState#compute MarkerDetectionState.compute} for more details.\n     *\n     * @return The state is updated with new parameters.\n     */\n    setParameters(parameters) {\n        if (this.#parameters.lfc_threshold !== parameters.lfc_threshold || this.#parameters.compute_auc !== parameters.compute_auc) {\n            this.free();\n        }\n        this.#parameters = { ...parameters };\n        return;\n    }\n\n    /**\n     * Compute markers for all groups.\n     *\n     * @return The state is updated with new results.\n     */\n    computeAll() {\n        let { lfc_threshold, compute_auc } = this.#parameters;\n        for (const k of this.#matrices.available()) {\n            var mat = this.#matrices.get(k);\n            utils.freeCache(this.#cache.raw[k]);\n            this.#cache.raw[k] = scran.scoreMarkers(mat, this.#groups, { block: this.#block, lfcThreshold: lfc_threshold, computeAuc: compute_auc });\n        }\n        return;\n    }\n\n    /**\n     * Extract markers for a pairwise comparison between two groups, \n     * for more detailed examination of the differences between them.\n     *\n     * @param {number} left - Index of one group in which to find upregulated markers.\n     * @param {number} right - Index of another group to be compared against `left`.\n     *\n     * @return {object} Object containing:\n     *\n     * - `results`: object containing the marker statistics for the comparison between two groups.\n     *    Each key is a modality name and each value is a {@linkplain external:ScoreMarkersResults ScoreMarkersResults} object.\n     * - `left`: index of the group corresponding to the `left` group in each ScoreMarkersResults object,\n     *    e.g., Cohen's d for the RNA markers of the `left` group are defined as `output.results.RNA.cohen(output.left)`.\n     * - `right`: index of the group corresponding to the `right` group in each ScoreMarkersResults object.\n     *    e.g., Cohen's d for the RNA markers of the `left` group are defined as `output.results.RNA.cohen(output.right)`.\n     */\n    computeVersus(left, right) {\n        if (!(\"versus\" in this.#cache)) {\n            this.#cache[\"versus\"] = {};\n        }\n        return _computeVersus(left, right, this.#matrices, this.#groups, { \n            cache: this.#cache.versus, \n            block: this.#block,\n            lfc_threshold: this.#parameters.lfc_threshold,\n            compute_auc: this.#parameters.compute_auc\n        });\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nfunction fill_results(stats, num_blocks) {\n    let keys = Object.keys(stats);\n    let first = stats[keys[0]];\n    let ngenes = first.means.length;\n    let object = scran.emptyScoreMarkersResults(ngenes, keys.length, num_blocks, { computeAuc: (\"auc\" in first) });\n\n    for (const k of keys) {\n        let i = Number(k);\n        let vals = stats[k];\n        object.means(i, { fillable: true }).set(vals.means);\n        object.detected(i, { fillable: true }).set(vals.detected);\n\n        for (const [s, v] of Object.entries(vals.cohen)) {\n            object.cohen(i, { summary: markers.summaries2int[s], fillable: true }).set(v);\n        }\n\n        for (const [s, v] of Object.entries(vals.lfc)) {\n            object.lfc(i, { summary: markers.summaries2int[s], fillable: true }).set(v);\n        }\n\n        for (const [s, v] of Object.entries(vals.delta_detected)) {\n            object.deltaDetected(i, { summary: markers.summaries2int[s], fillable: true }).set(v);\n        }\n\n        if (\"auc\" in vals) {\n            for (const [s, v] of Object.entries(vals.auc)) {\n                object.auc(i, { summary: markers.summaries2int[s], fillable: true }).set(v);\n            }\n        }\n    }\n\n    return object;\n}\n\nexport function unserialize(handle, permuters, filter, norm_states, choice) {\n    let ghandle = handle.open(\"marker_detection\");\n\n    let parameters = MarkerDetectionState.defaults();\n    {\n        let phandle = ghandle.open(\"parameters\");\n        if (\"lfc_threshold\" in phandle.children) {\n            parameters.lfc_threshold = phandle.open(\"lfc_threshold\", { load: true }).values[0];\n        }\n        if (\"compute_auc\" in phandle.children) {\n            parameters.compute_auc = phandle.open(\"compute_auc\", { load: true }).values[0] > 0;\n        }\n    }\n\n    // Figure out the number of blocks.\n    let num_blocks = 1;\n    {\n        let filtered = filter.fetchFilteredBlock();\n        if (filtered != null) {\n            filtered.forEach(x => {\n                if (x + 1 > num_blocks) {\n                    num_blocks = x + 1;\n                }\n            });\n        }\n    }\n\n    // Set up the marker detection statistics.\n    let cache = {};\n    {\n        let rhandle = ghandle.open(\"results\");\n        cache.raw = {};\n\n        if (\"clusters\" in rhandle.children) { \n            // below v2.0\n            let chandle = rhandle.open(\"clusters\");\n            let clusters = {};\n            for (const cl of Object.keys(chandle.children)) {\n                clusters[Number(cl)] = markers.unserializeGroupStats(chandle.open(cl), permuters[\"RNA\"], { compute_auc: parameters.compute_auc });\n            }\n            cache.raw.RNA = fill_results(clusters, num_blocks);\n        } else {\n            // after v2.0.\n            let chandle = rhandle.open(\"per_cluster\");\n            for (const a of Object.keys(chandle.children)) {\n                let clusters = {};\n                let ahandle = chandle.open(a);\n                for (const cl of Object.keys(ahandle.children)) {\n                    clusters[Number(cl)] = markers.unserializeGroupStats(ahandle.open(cl), permuters[a], { compute_auc: parameters.compute_auc });\n                }\n                cache.raw[a] = fill_results(clusters, num_blocks);\n            }\n        }\n \n    }\n\n    return new MarkerDetectionState(filter, norm_states, choice, parameters, cache);\n}\n\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as correct_module from \"./batch_correction.js\";\n\nexport const step_name = \"neighbor_index\";\n\n/**\n * This step assembles the neighbor search indices from the PCs (see {@linkplain PcaState}) in preparation for nearest neighbor searches in downstream steps.\n * It wraps the [`buildNeighborSearchIndex`](https://kanaverse.github.io/scran.js/global.html#buildNeighborSearchIndex) function \n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class NeighborIndexState {\n    #correct;\n    #parameters;\n    #cache;\n\n    constructor(correct, parameters = null, cache = null) {\n        if (!(correct instanceof correct_module.BatchCorrectionState)) {\n            throw new Error(\"'correct' should be a BatchCorrectionState object\");\n        }\n        this.#correct = correct;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.raw);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {BuildNeighborSearchIndexResults} Index for a nearest-neighbor search,\n     * available after running {@linkcode NeighborIndexState#compute compute}.\n     */\n    fetchIndex() {\n        if (!(\"raw\" in this.#cache)) {\n            this.#raw_compute(this.#parameters.approximate);\n        }\n        return this.#cache.raw;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    static defaults() {\n        return {\n            approximate: true\n        };\n    }\n\n    #raw_compute(approximate) {\n        this.#cache.raw = scran.buildNeighborSearchIndex(this.#correct.fetchCorrected(), { \n            approximate: approximate, \n            numberOfDims: this.#correct.fetchNumberOfDimensions(),\n            numberOfCells: this.#correct.fetchNumberOfCells()\n        });\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `neighbor_index` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {boolean} parameters.approximate - Whether to create an approximate search index.\n     * If `false`, an exact index is used.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { approximate } = parameters;\n        this.changed = false;\n\n        if (this.#correct.changed || approximate != this.#parameters.approximate) {\n            utils.freeCache(this.#cache.raw);\n            this.#raw_compute(approximate);\n            this.#parameters.approximate = approximate;\n            this.changed = true;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, pca) {\n    let ghandle = handle.open(\"neighbor_index\");\n\n    let parameters = {};\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            approximate: phandle.open(\"approximate\", { load: true }).values[0] > 0\n        };\n    }\n\n    let cache = {};\n    return new NeighborIndexState(pca, parameters, cache);\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as nutils from \"./utils/normalization.js\";\nimport * as qc_module from \"./rna_quality_control.js\";\nimport * as filter_module from \"./cell_filtering.js\";\n\nexport const step_name = \"rna_normalization\";\n\n/**\n * This step performs normalization and log-transformation on the QC-filtered matrix from the {@linkplain QualityControlState}.\n * It wraps the [`logNormCounts`](https://kanaverse.github.io/scran.js/global.html#logNormCounts) function\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class RnaNormalizationState {\n    #qc\n    #filter;\n    #parameters;\n    #cache;\n\n    constructor(qc, filter, parameters = null, cache = null) {\n        if (!(qc instanceof qc_module.RnaQualityControlState)) {\n            throw new Error(\"'qc' should be a RnaQualityControlState object\");\n        }\n        this.#qc = qc;\n\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.matrix);\n        utils.freeCache(this.#cache.sum_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        let filtered = this.#filter.fetchFilteredMatrix();\n        return filtered.has(\"RNA\");\n    }\n\n    /**\n     * @return {external:ScranMatrix} A {@linkplain external:ScranMatrix ScranMatrix} object containing normalized expression values,\n     * available after running {@linkcode RnaNormalizationState#compute compute}.\n     */\n    fetchNormalizedMatrix() {\n        if (!(\"matrix\" in this.#cache)) {\n            this.#raw_compute();\n        }\n        return this.#cache.matrix;\n    }\n\n    /**\n     * @return {Float64WasmArray} Array of length equal to the number of cells, \n     * containing the RNA-derived size factor for each cell.\n     * This is available after running {@linkcode RnaNormalizationState#compute compute}.\n     */\n    fetchSizeFactors() {\n        let buff;\n        if (this.#cache.sum_buffer) {\n            buff = utils.allocateCachedArray(this.#cache.sum_buffer.length, \"Float64Array\", this.#cache, \"centered_buffer\");\n            scran.centerSizeFactors(this.#cache.sum_buffer, { buffer: buff, block: this.#filter.fetchFilteredBlock() })\n        }\n        return buff;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #raw_compute() {\n        var mat = this.#filter.fetchFilteredMatrix().get(\"RNA\");\n        let buffer = nutils.subsetSums(this.#qc, this.#filter, mat, this.#cache, \"sum_buffer\");\n\n        var block = this.#filter.fetchFilteredBlock();\n        utils.freeCache(this.#cache.matrix);\n        this.#cache.matrix = scran.logNormCounts(mat, { sizeFactors: buffer, block: block, allowZeros: true });\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `rna_normalization` property of the `parameters` of {@linkcode runAnalysis}.\n     *\n     * @return The object is updated with new results.\n     */\n    compute(parameters) {\n        this.changed = false;\n        if (this.#qc.changed || this.#filter.changed) {\n            if (this.valid()) {\n                this.changed = true;\n            }\n        } \n\n        if (this.changed) {\n            this.#raw_compute();\n        }\n        return;\n    }\n\n    static defaults() {\n        return {};\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, qc, filter) {\n    return new RnaNormalizationState(qc, filter);\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as norm_module from \"./rna_normalization.js\";\nimport * as feat_module from \"./feature_selection.js\";\n\nexport const step_name = \"rna_pca\";\n\n/**\n * Results of running PCA on some input matrix,\n * see [here](https://kanaverse.github.io/scran.js/RunPCAResults.html) for details.\n *\n * @external RunPCAResults\n */\n\n/**\n * This step performs a principal components analysis (PCA) to compact and denoise the data.\n * The resulting PCs can be used as input to various per-cell analyses like clustering and dimensionality reduction.\n * It wraps the [`runPCA`](https://kanaverse.github.io/scran.js/global.html#runPCA) function\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class RnaPcaState { \n    #filter;\n    #norm;\n    #feat;\n    #cache;\n    #parameters;\n\n    constructor(filter, norm, feat, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(norm instanceof norm_module.RnaNormalizationState)) {\n            throw new Error(\"'norm' should be an RnaNormalizationState object\");\n        }\n        this.#norm = norm;\n\n        if (!(feat instanceof feat_module.FeatureSelectionState)) {\n            throw new Error(\"'feat' should be a FeatureSelectionState object\");\n        }\n        this.#feat = feat;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.hvg_buffer);\n        utils.freeCache(this.#cache.pcs);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        return this.#norm.valid();\n    }\n\n    /**\n     * @return {external:RunPCAResults} Results of the PCA on the normalized gene expression values.\n     */\n    fetchPCs() {\n        return this.#cache.pcs;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `rna_pca` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.num_pcs - Number of PCs to return.\n     * @param {number} parameters.num_hvgs - Number of highly variable genes (see {@linkplain FeatureSelectionState}) to use in the PCA.\n     * @param {string} parameters.block_method - Blocking method to use when dealing with multiple samples.\n     * This can be one of:\n     *\n     * - `\"none\"`, in which case nothing is done using the sample information. \n     * - `\"regress\"`, where linear regression is applied to remove mean differences between samples.\n     * - `\"weight\"`, where samples are weighted so that they contribute equally regardless of the number of cells.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { num_hvgs, num_pcs, block_method } = parameters;\n        this.changed = false;\n\n        if (this.#feat.changed || num_hvgs !== this.#parameters.num_hvgs) {\n            if (this.valid()) {\n                choose_hvgs(num_hvgs, this.#feat, this.#cache);\n                this.changed = true;\n            }\n\n            this.#parameters.num_hvgs = num_hvgs;\n        }\n\n        if (this.changed || this.#norm.changed || num_pcs !== this.#parameters.num_pcs || block_method !== this.#parameters.block_method) { \n            utils.freeCache(this.#cache.pcs);\n\n            if (this.valid()) {\n                let sub = this.#cache.hvg_buffer;\n                let block = this.#filter.fetchFilteredBlock();\n                var mat = this.#norm.fetchNormalizedMatrix();\n                this.#cache.pcs = scran.runPCA(mat, { features: sub, numberOfPCs: num_pcs, block: block, blockMethod: block_method });\n                this.changed = true;\n            }\n\n            this.#parameters.num_pcs = num_pcs;\n            this.#parameters.block_method = block_method;\n        }\n\n        return;\n    }\n\n    static defaults() {\n        return {\n            num_hvgs: 2000,\n            num_pcs: 20,\n            block_method: \"none\"\n        };\n    }\n}\n\n/**************************\n ******* Internals ********\n **************************/\n\nfunction choose_hvgs(num_hvgs, feat, cache) {\n    var sorted_resids = feat.fetchSortedResiduals();\n    var sub = utils.allocateCachedArray(sorted_resids.length, \"Uint8Array\", cache, \"hvg_buffer\");\n\n    if (num_hvgs < sorted_resids.length) {\n        var threshold_at = sorted_resids[sorted_resids.length - num_hvgs];\n        var unsorted_resids = feat.fetchResults().residuals({ copy: false });\n        sub.array().forEach((element, index, array) => {\n            array[index] = unsorted_resids[index] >= threshold_at;\n        });\n    } else {\n        sub.fill(1);\n    }\n\n    return sub;\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, filter, norm, feat) {\n    let ghandle = handle.open(\"rna_pca\" in handle.children ? \"rna_pca\" : \"pca\");\n\n    let parameters = {};\n    {\n        let phandle = ghandle.open(\"parameters\"); \n        parameters = { \n            num_hvgs: phandle.open(\"num_hvgs\", { load: true }).values[0],\n            num_pcs: phandle.open(\"num_pcs\", { load: true }).values[0]\n        };\n\n        // For back-compatibility.\n        if (\"block_method\" in phandle.children) {\n            parameters.block_method = phandle.open(\"block_method\", { load: true }).values[0];\n            if (parameters.block_method == \"mnn\") {\n                parameters.block_method = \"weight\";\n            }\n        } else {\n            parameters.block_method = \"none\";\n        }\n    }\n\n    let output;\n    let cache = {};\n    try {\n        if (feat.valid()) {\n            choose_hvgs(parameters.num_hvgs, feat, cache);\n\n            let rhandle = ghandle.open(\"results\");\n            if (\"pcs\" in rhandle.children) {\n                let pcs_handle = rhandle.open(\"pcs\", { load: true });\n                let pcs = pcs_handle.values;\n                let var_exp = rhandle.open(\"var_exp\", { load: true }).values;\n\n                cache.pcs = scran.emptyRunPCAResults(pcs_handle.shape[0], pcs_handle.shape[1]);\n                cache.pcs.principalComponents({ fillable: true }).set(pcs);\n                cache.pcs.varianceExplained({ fillable: true }).set(var_exp);\n                cache.pcs.setTotalVariance(1); // because the file only stores proportions.\n            }\n        }\n\n        output = new RnaPcaState(filter, norm, feat, parameters, cache);\n    } catch (e) {\n        utils.freeCache(cache.hvg_buffer);\n        utils.freeCache(cache.pcs);\n        utils.freeCache(output);\n        throw e;\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\"; \nimport * as bioc from \"bioconductor\";\nimport * as utils from \"./utils/general.js\";\nimport * as inputs_module from \"./inputs.js\";\nimport * as rutils from \"../readers/index.js\";\n\nconst baseUrl = \"https://github.com/kanaverse/kana-special-features/releases/download/v1.0.0\";\n\nexport const step_name = \"rna_quality_control\";\n\n/**\n * Results of computing per-cell RNA-derived QC metrics,\n * see [here](https://kanaverse.github.io/scran.js/PerCellRnaQcMetricsResults.html) for details.\n *\n * @external PerCellRnaQcMetricsResults\n */\n\n/**\n * Suggested filters for the RNA-derived QC metrics,\n * see [here](https://kanaverse.github.io/scran.js/SuggestRnaQcFiltersResults.html) for details.\n *\n * @external SuggestRnaQcFiltersResults\n */\n\n/**\n * This step applies quality control on the RNA count matrix.\n * Specifically, it computes the QC metrics and filtering thresholds, \n * wrapping the [`perCellRnaQcMetrics`](https://kanaverse.github.io/scran.js/global.html#perCellRnaQcMetrics)\n * and [`suggestRnaQcFilters`](https://kanaverse.github.io/scran.js/global.html#suggestRnaQcFilters) functions\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n * Note that the actual filtering is done by {@linkplain CellFilteringState}.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class RnaQualityControlState {\n    #inputs;\n    #cache;\n    #parameters;\n    #automatic;\n\n    constructor(inputs, parameters = null, cache = null) {\n        if (!(inputs instanceof inputs_module.InputsState)) {\n            throw new Error(\"'inputs' should be an InputsState object\");\n        }\n        this.#inputs = inputs;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.#automatic = false;\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.metrics);\n        utils.freeCache(this.#cache.filters);\n        utils.freeCache(this.#cache.metrics_buffer);\n        utils.freeCache(this.#cache.discard_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n    \n    valid() {\n        let input = this.#inputs.fetchCountMatrix();\n        return input.has(\"RNA\");\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        let output = { ...this.#parameters }; // avoid pass-by-reference links.\n        output.species = bioc.CLONE(output.species);\n        return output;\n    }\n\n    /**\n     * @return {Uint8WasmArray} Buffer containing the discard vector of length equal to the number of cells,\n     * where each element is truthy if the corresponding cell is to be discarded.\n     */\n    fetchDiscards() {\n        return this.#cache.discard_buffer;\n    }\n\n    /**\n     * @return {external:SuggestRnaQcFiltersResults} Result of filtering on the RNA-derived QC metrics.\n     */\n    fetchFilters() {\n        return this.#cache.filters;\n    }\n\n    /**\n     * @return {external:PerCellRnaQcMetricsResults} RNA-derived QC metrics.\n     */\n    fetchMetrics() {\n        return this.#cache.metrics;\n    }\n\n    /****************************\n     ******** Defaults **********\n     ****************************/\n\n    static defaults () {\n        return {\n            automatic: true,\n            gene_id_column: null,\n            use_reference_mito: true,\n            species: [],\n            gene_id_type: \"ENSEMBL\",\n            mito_prefix: \"mt-\",\n            nmads: 3\n        };\n    }\n\n    static configureFeatureParameters(use_reference_mito, guesses) {\n        let best_key = null;\n        let best = { type: \"symbol\", species: \"human\", confidence: 0 };\n\n        if (\"row_names\" in guesses) {\n            let val = guesses.row_names;\n            if (val.confidence > best.confidence && (use_reference_mito || val.type == \"symbol\")) {\n                best = val;\n            }\n        }\n\n        for (const [key, val] of Object.entries(guesses.columns)) {\n            if (val.confidence > best.confidence && (use_reference_mito || val.type == \"symbol\")) {\n                best = val;\n                best_key = key;\n            }\n        }\n\n        return {\n            gene_id_column: best_key,\n            species: [best.species],\n            gene_id_type: best.type.toUpperCase()\n        };\n    }\n\n    /**\n     * Array of strings containing the taxonomy IDs for species where mitochondrial gene lists are available.\n     * @type {Array}\n     */\n    static mitochondriaSpecies = [ \n        \"9606\",  // Mouse\n        \"10090\", // Human\n        \"6239\",  // C. elegans\n        \"10116\", // Rat\n        \"9541\",  // M. fascicularis\n        \"7227\",  // Fly\n        \"7955\",  // Zebrafish\n        \"9598\"   // Chimp\n    ];\n\n    /***************************\n     ******** Remotes **********\n     ***************************/\n\n    async #acquire_reference(species, feature_type) {\n        let output = new Set;\n        let mito_lists = RnaQualityControlState.#mito_lists;\n\n        for (const s of species) {\n            let target = s + \"-mito-\" + feature_type.toLowerCase() + \".txt.gz\";\n            if (!(target in mito_lists)) {\n                let contents = await RnaQualityControlState.#downloadFun(baseUrl + \"/\" + target);\n                let lines = await rutils.readLines2(contents, { compression: \"gz\" });\n                mito_lists[target] = lines;\n            }\n\n            mito_lists[target].forEach(x => { output.add(x); });\n        }\n\n        return output;\n    }\n\n    static #mito_lists = {};\n\n    /**\n     * Flush all cached lists of mitochondrial genes.\n     *\n     * By default, {@linkcode RnaQualityControlState#compute compute} will cache the mitochondrial gene lists in a static member for re-use across {@linkplain RnaQualityControlState} instances.\n     * These cached lists are not tied to any single instance and will not be removed by garbage collectors or by {@linkcode freeAnalysis}.\n     * Rather, this function should be called to release the relevant memory.\n     */\n    static flush() {\n        RnaQualityControlState.#mito_lists = {};\n        return;\n    }\n\n    static #downloadFun = utils.defaultDownload;\n\n    /**\n     * Specify a function to download the reference mitochondrial gene lists.\n     *\n     * @param {function} fun - Function that accepts a single string containing a URL and returns any value that can be used in the {@linkplain SimpleFile} constructor.\n     * This is most typically a Uint8Array of that URL's contents, but it can also be a path to a locally cached file on Node.js.\n     *\n     * @return `fun` is set as the global downloader for this step. \n     * The _previous_ value of the downloader is returned.\n     */\n    static setDownload(fun) {\n        let previous = RnaQualityControlState.#downloadFun;\n        RnaQualityControlState.#downloadFun = fun;\n        return previous;\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `rna_quality_control` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {boolean} parameters.automatic - Automatically choose feature-based parameters based on the feature annotation for the RNA modality.\n     * If set to `true`, the following logic is applied:\n     *\n     * - If `use_reference_mito = true`, the annotation column that best matches human/mouse Ensembl/symbols is set as `gene_id_column`.\n     *   Based on the identified species and feature type, `species` and `gene_id_type` are also set.\n     * - If `use_reference_mito = false`, the annotation column that best matches human/mouse symbols is set as `gene_id_column`.\n     *\n     * @param {?(string|number)} parameters.gene_id_column - Name or index of the column of the feature annotations that contains the gene identifiers for the RNA modality.\n     * If `null`, the row names are used.\n     * Ignored if `automatic = true`.\n     * @param {boolean} parameters.use_reference_mito - Whether to use the reference lists of mitochondrial genes.\n     * If `false`, mitochondrial genes are instead identified from their prefix.\n     * @param {Array} parameters.species - Array of strings specifying zero, one or more species to use to obtain a reference list of mitochondrial genes.\n     * Each entry should be a taxonomy ID (e.g. `\"9606\"`, `\"10090\"`) as specified in {@linkcode RnaQualityControlState#mitochondriaSpecies mitochondriaSpecies}).\n     * Ignored if `automatic = true`.\n     * @param {string} parameters.gene_id_type - Name of the feature type in the reference list of mitochondrial genes.\n     * This can be any one of `\"ENSEMBL\"`, `\"SYMBOL\"`, or `\"ENTREZ\"`.\n     * Ignored if `automatic = true`.\n     * @param {?string} parameters.mito_prefix - Case-insensitive prefix to use to identify mitochondrial genes from the dataset.\n     * Only used when `use_reference_mito = false`; in such cases, `gene_id_column` should point to symbols.\n     * If `null`, no prefix-based identification is performed.\n     * @param {number} parameters.nmads - Number of MADs to use for automatically selecting the filter threshold for each metric.\n     *\n     * @return The object is updated with the new results.\n     * @async\n     */\n    async compute(parameters) {\n        let { mito_prefix, nmads } = parameters;\n        let automatic;\n        let use_reference_mito;\n        let gene_id_column;\n        let species;\n        let gene_id_type;\n\n        // Some back-compatibility here.\n        if (\"use_reference_mito\" in parameters) {\n            automatic = parameters.automatic;\n            use_reference_mito = parameters.use_reference_mito;\n            gene_id_column = parameters.gene_id_column;\n            species = parameters.species;\n            gene_id_type = parameters.gene_id_type;\n        } else {\n            automatic = true;\n            use_reference_mito = parameters.use_mito_default;\n            let def = RnaQualityControlState.defaults();\n            gene_id_column = def.gene_id_column;\n            species = def.species;\n            gene_id_type = def.gene_id_type;\n        }\n\n        this.changed = false;\n\n        if (\n            this.#inputs.changed || \n            automatic !== this.#parameters.automatic ||\n            use_reference_mito !== this.#parameters.use_reference_mito || \n            (\n                !automatic && \n                (\n                    gene_id_column !== this.#parameters.gene_id_column || \n                    (!use_reference_mito && mito_prefix !== this.#parameters.mito_prefix) ||\n                    (\n                        use_reference_mito && \n                        (\n                            utils.changedParameters(species, this.#parameters.species) || \n                            gene_id_type !== this.#parameters.gene_id_type\n                        )\n                    )\n                )\n            ) \n        ) {\n            utils.freeCache(this.#cache.metrics);\n\n            if (this.valid()) {\n                let gene_id_column2 = gene_id_column;\n                let species2 = species;\n                let gene_id_type2 = gene_id_type;\n\n                if (automatic) {\n                    let guesses = this.#inputs.guessRnaFeatureTypes();\n                    let backcomp = RnaQualityControlState.configureFeatureParameters(use_reference_mito, guesses);\n                    gene_id_column2 = backcomp.gene_id_column;\n                    species2 = backcomp.species;\n                    gene_id_type2 = backcomp.gene_id_type;\n                }\n\n                var gene_info = this.#inputs.fetchFeatureAnnotations()[\"RNA\"];\n                let val = (gene_id_column2 == null ? gene_info.rowNames() : gene_info.column(gene_id_column2));\n                var subsets = utils.allocateCachedArray(gene_info.numberOfRows(), \"Uint8Array\", this.#cache, \"metrics_buffer\");\n                subsets.fill(0);\n\n                if (val !== null) {\n                    if (use_reference_mito) {\n                        let lists = await this.#acquire_reference(species2, gene_id_type2);\n                        var sub_arr = subsets.array();\n                        val.forEach((x, i) => {\n                            if (lists.has(x)) {\n                                sub_arr[i] = 1;\n                            }\n                        });\n                    } else if (mito_prefix !== null) {\n                        var lower_mito = mito_prefix.toLowerCase();\n                        var sub_arr = subsets.array();\n                        val.forEach((x, i) => {\n                            if(x.toLowerCase().startsWith(lower_mito)) {\n                                sub_arr[i] = 1;\n                            }\n                        });\n                    }\n                }\n\n                var mat = this.#inputs.fetchCountMatrix().get(\"RNA\");\n                this.#cache.metrics = scran.perCellRnaQcMetrics(mat, [subsets]);\n                this.changed = true;\n            } else {\n                delete this.#cache.metrics;\n            }\n        }\n\n        this.#parameters.automatic = automatic;\n        this.#parameters.gene_id_column = gene_id_column;\n        this.#parameters.use_reference_mito = use_reference_mito;\n        this.#parameters.species = bioc.CLONE(species); // avoid pass-by-reference behavior.\n        this.#parameters.gene_id_type = gene_id_type;\n        this.#parameters.mito_prefix = mito_prefix;\n\n        if (this.changed || nmads !== this.#parameters.nmads) {\n            utils.freeCache(this.#cache.filters);\n\n            if (this.valid()) {\n                let block = this.#inputs.fetchBlock();\n                this.#cache.filters = scran.suggestRnaQcFilters(this.#cache.metrics, { numberOfMADs: nmads, block: block });\n                var discard = utils.allocateCachedArray(this.#cache.metrics.numberOfCells(), \"Uint8Array\", this.#cache, \"discard_buffer\");\n                this.#cache.filters.filter(this.#cache.metrics, { block: block, buffer: discard });\n                this.changed = true;\n            } else {\n                delete this.#cache.filters;\n            }\n\n            this.#parameters.nmads = nmads;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, inputs) {\n    let ghandle = handle.open(\"rna_quality_control\" in handle.children ? \"rna_quality_control\" : \"quality_control\");\n\n    let parameters = RnaQualityControlState.defaults(); \n    {\n        let phandle = ghandle.open(\"parameters\"); \n        parameters.use_mito_default = phandle.open(\"use_mito_default\", { load: true }).values[0] > 0;\n        parameters.mito_prefix = phandle.open(\"mito_prefix\", { load: true }).values[0];\n        parameters.nmads = phandle.open(\"nmads\", { load: true }).values[0];\n    }\n\n    let output;\n    let cache = {};\n    try {\n        let rhandle = ghandle.open(\"results\");\n\n        if (\"metrics\" in rhandle.children) { // QC metrics may not be reported if skipped.\n            let mhandle = rhandle.open(\"metrics\");\n            let sums = mhandle.open(\"sums\", { load: true }).values;\n\n            cache.metrics = scran.emptyPerCellRnaQcMetricsResults(sums.length, 1);\n            cache.metrics.sums({ fillable: true }).set(sums);\n\n            let detected = mhandle.open(\"detected\", { load: true }).values;\n            cache.metrics.detected({ fillable: true }).set(detected);\n            let proportions = mhandle.open(\"proportion\", { load: true }).values;\n            cache.metrics.subsetProportions(0, { fillable: true }).set(proportions);\n        }\n\n        if (\"thresholds\" in rhandle.children) { // if skip=true, QC thresholds may not be reported.\n            let discards = rhandle.open(\"discards\", { load: true }).values; \n            cache.discard_buffer = scran.createUint8WasmArray(discards.length);\n            cache.discard_buffer.set(discards);\n\n            let thandle = rhandle.open(\"thresholds\");\n            let thresholds_sums = thandle.open(\"sums\", { load: true }).values;\n            let thresholds_detected = thandle.open(\"detected\", { load: true }).values;\n            let thresholds_proportion = thandle.open(\"proportion\", { load: true }).values;\n\n            cache.filters = scran.emptySuggestRnaQcFiltersResults(1, thresholds_sums.length);\n            cache.filters.thresholdsSums({ fillable: true }).set(thresholds_sums);\n            cache.filters.thresholdsDetected({ fillable: true }).set(thresholds_detected);\n            cache.filters.thresholdsSubsetProportions(0, { fillable: true }).set(thresholds_proportion);\n        }\n\n        output = new RnaQualityControlState(inputs, parameters, cache);\n    } catch (e) {\n        utils.freeCache(cache.metrics);\n        utils.freeCache(cache.filters)\n        utils.freeCache(output);\n        throw e;\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as neighbor_module from \"./neighbor_index.js\";\n\nexport const step_name = \"snn_graph_cluster\";\n\n/**\n * This step does SNN graph clustering based on the neighbor search index built by {@linkplain NeighborIndexState}.\n * This wraps [`clusterSNNGraph`](https://kanaverse.github.io/scran.js/global.html#clusterSNNGraph) \n * and related functions from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class SnnGraphClusterState {\n    #index;\n    #parameters;\n    #cache;\n\n    constructor(index, parameters = null, cache = null) {\n        if (!(index instanceof neighbor_module.NeighborIndexState)) {\n            throw new Error(\"'index' should be a State object from './neighbor_index.js'\");\n        }\n        this.#index = index;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.neighbors);\n        utils.freeCache(this.#cache.graph);\n        utils.freeCache(this.#cache.clusters);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {Int32WasmArray} Array of cluster assignments for each cell in the (filtered) dataset,\n     * available after running {@linkcode SnnGraphClusterState#compute compute}.\n     */\n    fetchClusters() {\n        if (!this.#valid()) {\n            throw \"cannot fetch SNN clusters from an invalid state\";\n        } else {\n            return this.#cache.clusters.membership({ copy: \"view\" });\n        }\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #valid() {\n        return \"clusters\" in this.#cache;\n    }\n\n    #compute_neighbors(k) {\n        this.#cache.neighbors = scran.findNearestNeighbors(this.#index.fetchIndex(), k);\n        return;\n    }\n\n    #compute_graph(scheme) {\n        if (!(\"neighbors\" in this.#cache)) { // need to check as reloaded state will not populate the internals.\n            this.#compute_neighbors(this.#parameters.k);\n        }\n        this.#cache.graph = scran.buildSNNGraph(this.#cache.neighbors, { scheme: scheme });\n        return;\n    }\n\n    #compute_clusters(algorithm, multilevel_resolution, leiden_resolution, walktrap_steps) {\n        if (!(\"graph\" in this.#cache)) {\n            this.#compute_graph(this.#parameters.scheme);\n        }\n        this.#cache.clusters = scran.clusterSNNGraph(this.#cache.graph, {\n            method: algorithm,\n            multiLevelResolution: multilevel_resolution,\n            leidenResolution: leiden_resolution,\n            leidenModularityObjective: true, // avoid problems with unstable interpretation of leidenResolution.\n            walktrapSteps: walktrap_steps\n        });\n        return;\n    }\n\n    static defaults() {\n        return { \n            k: 10,\n            scheme: \"rank\",\n            algorithm: \"multilevel\",\n            multilevel_resolution: 1,\n            leiden_resolution: 1,\n            walktrap_steps: 4\n        };\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {boolean} run_me - Whether or not to run this step, depending on the clustering method chosen by the user (see {@linkplain ChooseClusteringState}).\n     * @param {object} parameters - Parameter object, equivalent to the `snn_graph_cluster` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.k - Number of nearest neighbors used to construct the graph.\n     * @param {string} parameters.scheme - Weighting scheme for graph construction.\n     * This can be one of `\"rank\"`, `\"number\"` or `\"jaccard\"`.\n     * @param {string} parameters.algorithm - Algorithm to use for community detection.\n     * This can be one of `\"multilevel\"`, `\"walktrap\"` or `\"leiden\"`.\n     * @param {number} parameters.multilevel_resolution - Resolution of the multi-level community detection.\n     * @param {number} parameters.leiden_resolution - Resolution of the Leiden community detection.\n     * @param {number} parameters.walktrap_steps - Number of merge steps for the Walktrap algorithm.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(run_me, parameters) {\n        let { k, scheme, algorithm, multilevel_resolution, leiden_resolution, walktrap_steps } = parameters;\n        this.changed = false;\n\n        if (this.#index.changed || k !== this.#parameters.k) {\n            utils.freeCache(this.#cache.neighbors);\n            if (run_me) {\n                this.#compute_neighbors(k);\n            } else {\n                delete this.#cache.neighbors; // ensuring that this is re-run on future calls to compute() with run_me = true.\n            }\n            this.#parameters.k = k;\n            this.changed = true;\n        }\n\n        if (this.changed || scheme !== this.#parameters.scheme) {\n            utils.freeCache(this.#cache.graph);\n            if (run_me) {\n                this.#compute_graph(scheme);\n            } else {\n                delete this.#cache.graph;\n            }\n            this.#parameters.scheme = scheme;\n            this.changed = true \n        }\n\n        if (this.changed \n            || algorithm !== this.#parameters.algorithm \n            || multilevel_resolution !== this.#parameters.multilevel_resolution \n            || leiden_resolution !== this.#parameters.leiden_resolution \n            || walktrap_steps !== this.#parameters.walktrap_steps \n            || (!this.#valid() && run_me))\n        {\n            utils.freeCache(this.#cache.clusters);\n            if (run_me) {\n                this.#compute_clusters(algorithm, multilevel_resolution, leiden_resolution, walktrap_steps);\n            } else {\n                delete this.#cache.clusters;\n            }\n\n            this.#parameters.algorithm = algorithm;\n            this.#parameters.multilevel_resolution = multilevel_resolution;\n            this.#parameters.leiden_resolution = leiden_resolution;\n            this.#parameters.walktrap_steps = walktrap_steps;\n            this.changed = true;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, index) {\n    let ghandle = handle.open(\"snn_graph_cluster\");\n\n    let parameters = SnnGraphClusterState.defaults();\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters.k = phandle.open(\"k\", { load: true }).values[0];\n\n        parameters.scheme = phandle.open(\"scheme\", { load: true }).values[0];\n        if (typeof parameters.scheme !== \"string\") { // because I stuffed up and tried to save a string as an int in v1.0, oops.\n            parameters.scheme = \"rank\";\n        }\n\n        if (\"algorithm\" in phandle.children) {\n            // v3.0\n            parameters.algorithm = phandle.open(\"algorithm\", { load: true }).values[0];\n            parameters.multilevel_resolution = phandle.open(\"multilevel_resolution\", { load: true }).values[0];\n            parameters.leiden_resolution = phandle.open(\"leiden_resolution\", { load: true }).values[0];\n            parameters.walktrap_steps = phandle.open(\"walktrap_steps\", { load: true }).values[0];\n        } else {\n            // v2.0\n            parameters.multilevel_resolution = phandle.open(\"resolution\", { load: true }).values[0];\n        }\n    }\n\n    let cache = {};\n    {\n        let rhandle = ghandle.open(\"results\");\n        if (\"clusters\" in rhandle.children) {\n            let clusters = rhandle.open(\"clusters\", { load: true }).values;\n            cache.clusters = scran.emptyClusterSNNGraphResults(clusters.length, 1);\n            cache.clusters.setBest(0); // whatever.\n            cache.clusters.membership({ fillable: true }).set(clusters);\n        }\n    }\n\n    return new SnnGraphClusterState(index, parameters, cache);\n}\n\n\n","import * as scran from \"scran.js\";\nimport * as vizutils from \"./utils/viz_parent.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as neighbor_module from \"./neighbor_index.js\";\nimport * as aworkers from \"./abstract/worker_parent.js\";\n\n/**\n * This creates a t-SNE embedding based on the neighbor index constructed by {@linkplain NeighborIndexState}.\n * This wraps [`runTSNE`](https://kanaverse.github.io/scran.js/global.html#runTSNE)\n * and related functions from [**scran.js**](https://github.com/kanaverse/scran.js).\n * \n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class TsneState {\n    #index;\n    #parameters;\n    #reloaded;\n\n    #worker_id;\n\n    #ready;\n    #run;\n\n    constructor(index, parameters = null, reloaded = null) {\n        if (!(index instanceof neighbor_module.NeighborIndexState)) {\n            throw new Error(\"'index' should be a State object from './neighbor_index.js'\");\n        }\n        this.#index = index;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#reloaded = reloaded;\n        this.changed = false;\n\n        let worker = aworkers.createTsneWorker();\n        let { worker_id, ready } = vizutils.initializeWorker(worker, vizutils.scranOptions);\n        this.#worker_id = worker_id;\n        this.#ready = ready;\n\n        this.#run = null;\n    }\n\n    ready() {\n        // It is assumed that the caller will await the ready()\n        // status before calling any other methods of this instance.\n        return this.#ready;\n    }\n\n    free() {\n        return vizutils.killWorker(this.#worker_id);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to create a copy of the coordinates,\n     * if the caller might mutate them.\n     *\n     * @return {object} Object containing:\n     *\n     * - `x`: a Float64Array containing the x-coordinate for each cell.\n     * - `y`: a Float64Array containing the y-coordinate for each cell.\n     * - `iterations`: the number of iterations processed.\n     *\n     * @async\n     */\n    async fetchResults({ copy = true } = {}) {\n        if (this.#reloaded !== null) {\n            let output = {\n                x: this.#reloaded.x,\n                y: this.#reloaded.y\n            };\n\n            if (copy) {\n                output.x = output.x.slice();\n                output.y = output.y.slice();\n            }\n        \n            output.iterations = this.#parameters.iterations;\n            return output;\n        } else {\n            // Vectors that we get from the worker are inherently\n            // copied, so no need to do anything extra here.\n            await this.#run;\n            return vizutils.sendTask(this.#worker_id, { \"cmd\": \"FETCH\" });\n        }\n    }\n\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #core(perplexity, iterations, animate, reneighbor) {\n        var nn_out = null;\n        if (reneighbor) {\n            var k = scran.perplexityToNeighbors(perplexity);\n            nn_out = vizutils.computeNeighbors(this.#index, k);\n        }\n\n        let args = {\n            \"perplexity\": perplexity,\n            \"iterations\": iterations,\n            \"animate\": animate\n        };\n\n        // This returns a promise but the message itself is sent synchronously,\n        // which is important to ensure that the t-SNE runs in its worker in\n        // parallel with other analysis steps. Do NOT put the runWithNeighbors\n        // call in a .then() as this may defer the message sending until \n        // the current thread is completely done processing.\n        this.#run = vizutils.runWithNeighbors(this.#worker_id, args, nn_out);\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `tsne` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.perplexity - Number specifying the perplexity for the probability calculations.\n     * @param {number} parameters.iterations - Number of iterations to run the algorithm.\n     * @param {boolean} parameters.animate - Whether to process animation iterations, see {@linkcode setVisualizationAnimate} for details.\n     *\n     * @return t-SNE coordinates are computed in parallel on a separate worker thread.\n     * A promise is returned that resolves when those calculations are complete.\n     */\n    compute(parameters) {\n        let { perplexity, iterations, animate } = parameters;\n\n        let same_neighbors = (!this.#index.changed && perplexity === this.#parameters.perplexity);\n        if (same_neighbors && iterations == this.#parameters.iterations) {\n            this.changed = false;\n            return new Promise(resolve => resolve(null));\n        }\n\n        // In the reloaded state, we must send the neighbor\n        // information, because it hasn't ever been sent before.\n        if (this.#reloaded !== null) {\n            same_neighbors = false;\n            this.#reloaded = null;\n        }\n\n        this.#core(perplexity, iterations, animate, !same_neighbors);\n\n        this.#parameters.perplexity = perplexity;\n        this.#parameters.iterations = iterations;\n        this.#parameters.animate = animate;\n\n        this.changed = true;\n        return this.#run;\n    }\n\n    /***************************\n     ******* Animators *********\n     ***************************/\n\n    /**\n     * Repeat the animation iterations.\n     * It is assumed that {@linkcode setVisualizationAnimate} has been set appropriately to process each iteration.\n     *\n     * @return A promise that resolves on successful completion of all iterations.\n     */\n    animate() {\n        if (this.#reloaded !== null) {\n            this.#reloaded = null;\n\n            // We need to reneighbor because we haven't sent the neighbors across yet.\n            this.#core(this.#parameters.perplexity, this.#parameters.iterations, true, true);\n\n            // Mimicking the response from the re-run.\n            return this.#run\n                .then(contents => {\n                    return {\n                        \"type\": \"tsne_rerun\",\n                        \"data\": { \"status\": \"SUCCESS\" }\n                    };\n                });\n        } else {\n            return vizutils.sendTask(this.#worker_id, { \"cmd\": \"RERUN\" });\n        }\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport async function unserialize(handle, index) {\n    let ghandle = handle.open(\"tsne\");\n\n    let parameters;\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            perplexity: phandle.open(\"perplexity\", { load: true }).values[0],\n            iterations: phandle.open(\"iterations\", { load: true }).values[0],\n            animate: phandle.open(\"animate\", { load: true }).values[0] > 0\n        };\n    }\n\n    let reloaded;\n    {\n        let rhandle = ghandle.open(\"results\");\n        reloaded = {\n            x: rhandle.open(\"x\", { load: true }).values,\n            y: rhandle.open(\"y\", { load: true }).values\n        };\n    }\n\n    let output = new TsneState(index, parameters, reloaded);\n    await output.ready();\n    return output;\n}\n","import * as scran from \"scran.js\";\nimport * as vizutils from \"./utils/viz_parent.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as neighbor_module from \"./neighbor_index.js\";\nimport * as aworkers from \"./abstract/worker_parent.js\";\n\n/**\n * This creates a UMAP embedding based on the neighbor index constructed at {@linkplain NeighborIndexState}.\n * This wraps [`runUMAP`](https://kanaverse.github.io/scran.js/global.html#runUMAP)\n * and related functions from [**scran.js**](https://github.com/kanaverse/scran.js).\n * \n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class UmapState {\n    #index;\n    #parameters;\n    #reloaded;\n\n    #worker_id;\n\n    #ready;\n    #run;\n\n    constructor(index, parameters = null, reloaded = null) {\n        if (!(index instanceof neighbor_module.NeighborIndexState)) {\n            throw new Error(\"'index' should be a State object from './neighbor_index.js'\");\n        }\n        this.#index = index;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#reloaded = reloaded;\n        this.changed = false;\n\n        let worker = aworkers.createUmapWorker();\n        let { worker_id, ready } = vizutils.initializeWorker(worker, vizutils.scranOptions);\n        this.#worker_id = worker_id;\n        this.#ready = ready;\n\n        this.#run = null;\n    }\n\n    ready() {\n        // It is assumed that the caller will await the ready()\n        // status before calling any other methods of this instance.\n        return this.#ready;\n    }\n\n    free() {\n        return vizutils.killWorker(this.#worker_id);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to create a copy of the coordinates,\n     * if the caller might mutate them.\n     *\n     * @return {object} Object containing:\n     *\n     * - `x`: a Float64Array containing the x-coordinate for each cell.\n     * - `y`: a Float64Array containing the y-coordinate for each cell.\n     * - `iterations`: the number of iterations processed.\n     *\n     * @async\n     */\n    async fetchResults({ copy = true } = {}) {\n        if (this.#reloaded !== null) {\n            let output = {\n                x: this.#reloaded.x,\n                y: this.#reloaded.y\n            };\n\n            if (copy) {\n                output.x = output.x.slice();\n                output.y = output.y.slice();\n            }\n\n            output.iterations = this.#parameters.num_epochs;\n            return output;\n        } else {\n            // Vectors that we get from the worker are inherently\n            // copied, so no need to do anything extra here.\n            await this.#run;\n            return vizutils.sendTask(this.#worker_id, { \"cmd\": \"FETCH\" });\n        }\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #core(num_neighbors, num_epochs, min_dist, animate, reneighbor) {\n        var nn_out = null;\n        if (reneighbor) {\n            nn_out = vizutils.computeNeighbors(this.#index, num_neighbors);\n        }\n\n        let args = {\n            \"num_neighbors\": num_neighbors,\n            \"num_epochs\": num_epochs,\n            \"min_dist\": min_dist,\n            \"animate\": animate\n        };\n\n        // This returns a promise but the message itself is sent synchronously,\n        // which is important to ensure that the UMAP runs in its worker in\n        // parallel with other analysis steps. Do NOT put the runWithNeighbors\n        // call in a .then() as this may defer the message sending until \n        // the current thread is completely done processing.\n        this.#run = vizutils.runWithNeighbors(this.#worker_id, args, nn_out);\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `umap` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.num_neighbors - Number of neighbors to use to construct the simplicial sets.\n     * @param {number} parameters.num_epochs - Number of epochs to run the algorithm.\n     * @param {number} parameters.min_dist - Number specifying the minimum distance between points.\n     * @param {boolean} parameters.animate - Whether to process animation iterations, see {@linkcode setVisualizationAnimate} for details.\n     *\n     * @return UMAP coordinates are computed in parallel on a separate worker thread.\n     * A promise that resolves when the calculations are complete.\n     */\n    compute(parameters) {\n        let { num_neighbors, num_epochs, min_dist, animate } = parameters;\n\n        let same_neighbors = (!this.#index.changed && this.#parameters.num_neighbors === num_neighbors);\n        if (same_neighbors && num_epochs === this.#parameters.num_epochs && min_dist === this.#parameters.min_dist) {\n            this.changed = false;\n            return new Promise(resolve => resolve(null));\n        }\n\n        // In the reloaded state, we must send the neighbor\n        // information, because it hasn't ever been sent before.\n        if (this.#reloaded !== null) {\n            same_neighbors = false;\n            this.#reloaded = null;\n        }\n\n        this.#core(num_neighbors, num_epochs, min_dist, animate, !same_neighbors);\n\n        this.#parameters.num_neighbors = num_neighbors;\n        this.#parameters.num_epochs = num_epochs;\n        this.#parameters.min_dist = min_dist;\n        this.#parameters.animate = animate;\n\n        this.changed = true;\n        return this.#run;\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * Repeat the animation iterations.\n     * It is assumed that {@linkcode setVisualizationAnimate} has been set appropriately to process each iteration.\n     *\n     * @return A promise that resolves on successful completion of all iterations.\n     */\n    animate() {\n        if (this.#reloaded !== null) {\n            this.#reloaded = null;\n\n            // We need to reneighbor because we haven't sent the neighbors across yet.\n            this.#core(this.#parameters.num_neighbors, this.#parameters.num_epochs, this.#parameters.min_dist, true, true);\n      \n            // Mimicking the response from the re-run.\n            return this.#run\n                .then(contents => { \n                    return {\n                        \"type\": \"umap_rerun\",\n                        \"data\": { \"status\": \"SUCCESS\" }\n                    };\n                });\n        } else {\n            return vizutils.sendTask(this.#worker_id, { \"cmd\": \"RERUN\" });\n        }\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport async function unserialize(handle, index) {\n    let ghandle = handle.open(\"umap\");\n\n    let parameters;\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            num_neighbors: phandle.open(\"num_neighbors\", { load: true }).values[0],\n            num_epochs: phandle.open(\"num_epochs\", { load: true }).values[0],\n            min_dist: phandle.open(\"min_dist\", { load: true }).values[0],\n            animate: phandle.open(\"animate\", { load: true }).values[0] > 0\n        };\n    }\n\n    let reloaded;\n    {\n        let rhandle = ghandle.open(\"results\");\n        reloaded = {\n            x: rhandle.open(\"x\", { load: true }).values,\n            y: rhandle.open(\"y\", { load: true }).values\n        };\n    }\n\n    let output = new UmapState(index, parameters, reloaded);\n    await output.ready();\n    return output;\n}\n","export function registerCallback(worker, callback) {\n    worker.onmessage = callback;\n    return;\n}\n\nexport function sendMessage(worker, message, transfer) {\n    worker.postMessage(message, transfer);\n    return;\n}\n\nexport function terminateWorker(worker) {\n    worker.terminate();\n    return;\n}\n","import * as scran from \"scran.js\";\n\nexport function freeCache(object) {\n    // Just an alias for back-compatibility.\n    scran.free(object);\n    return;\n}\n\nfunction changedParametersIllegal(x, y, xskip, yskip) {\n    // Failing if this is a TypedArray or ArrayBuffer;\n    // we shouldn't be seeing these things here anyway.\n    if (!xskip) {\n        if (x instanceof ArrayBuffer || ArrayBuffer.isView(x)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n    if (!yskip) {\n        if (y instanceof ArrayBuffer || ArrayBuffer.isView(y)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n}\n\nexport function changedParameters(x, y) {\n    if (typeof x != typeof y) {\n        changedParametersIllegal(x, y, false, false);\n        return true;\n    } else if (typeof x != \"object\") {\n        return x != y;\n    }\n\n    //Handling nulls (which are objects).\n    let xnull = x === null;\n    let ynull = y === null;\n    if (xnull !== ynull) {\n        changedParametersIllegal(x, y, xnull, ynull);\n        return true;\n    } else if (xnull) {\n        return false;\n    }\n\n    // Handling arrays (which are also objects).\n    let xarr = x instanceof Array;\n    let yarr = y instanceof Array;\n    if (xarr != yarr) {\n        changedParametersIllegal(x, y, xarr, yarr);\n        return true;\n    } else if (xarr) {\n        if (x.length != y.length) {\n            return true;\n        }\n\n        for (var i = 0; i < x.length; i++) {\n            if (changedParameters(x[i], y[i])) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    changedParametersIllegal(x, y, false, false);\n    \n    // Now actually handling objects. We don't \n    // worry about the order of the keys here.\n    let xkeys = Object.keys(x);\n    let ykeys = Object.keys(y);\n    if (xkeys.length != ykeys.length) {\n        return true;\n    }\n\n    xkeys.sort();\n    ykeys.sort();\n    for (var i = 0; i < xkeys.length; i++) {\n        if (xkeys[i] != ykeys[i]) {\n            return true;\n        }\n    }\n\n    for (const k of xkeys) {\n        if (changedParameters(x[k], y[k])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function allocateCachedArray(size, type, cache, name = \"buffer\") {\n    var reallocate = true;\n    if (name in cache) {\n        var candidate = cache[name];\n\n        // Views also trigger reallocation, because it is assumed that the\n        // caller of this function does not own the view, but downstream\n        // uses of the array will involve writing to it.\n        if (candidate.size != size || candidate.constructor.className != type || candidate.owner !== null) { \n            candidate.free();\n        } else {\n            reallocate = false;\n        }\n    }\n  \n    if (reallocate) {\n        switch (type) {\n            case \"Uint8Array\":\n                cache[name] = scran.createUint8WasmArray(size);\n                break;\n            case \"Int32Array\":\n                cache[name] = scran.createInt32WasmArray(size);\n                break;\n            case \"Float64Array\":\n                cache[name] = scran.createFloat64WasmArray(size);\n                break;\n            default:\n                // We only ever use one of the three above types in our \n                // internal data stores, so no need to go all-out here.\n                throw \"allocating '\" + type + \"' not yet supported\";\n        }\n    }\n\n    return cache[name];\n}\n\nexport function findValidUpstreamStates(states, msg) {\n    let to_use = [];\n    for (const [k, v] of Object.entries(states)) {\n        if (v.valid()) {\n            to_use.push(k);\n        }\n    }\n    if (to_use.length == 0) {\n        throw new Error(\"expected at least one valid upstream \" + msg + \" state\");\n    }\n    return to_use;\n}\n\nexport function checkIndices(indices, max) {\n    if (max !== null) {\n        for (const i of indices) {\n            if (i < 0 || i >= max) {\n                throw new Error(\"subset indices are out of range\");\n            }\n        }\n    }\n\n    for (var i = 1; i < indices.length; i++) {\n        if (indices[i] <= indices[i-1]) {\n            throw new Error(\"subset indices must be sorted and unique\");\n        }\n    }\n}\n\nexport async function defaultDownload(url) {\n    let resp = await fetch(url);\n    if (!resp.ok) {\n        throw new Error(\"failed to fetch content at \" + url + \"(\" + resp.status + \")\");\n    }\n    return new Uint8Array(await resp.arrayBuffer());\n}\n\nexport function guessFeatureTypes(genes) {\n    let output = { columns: {} };\n\n    let rn = genes.rowNames();\n    if (rn !== null) {\n        output.row_names = scran.guessFeatures(rn, { forceTaxonomy: true });\n    }\n\n    for (const key of genes.columnNames()) {\n        let curcol = genes.column(key);\n        if (curcol instanceof Array) {\n            output.columns[key] = scran.guessFeatures(genes.column(key), { forceTaxonomy: true });\n        }\n    }\n\n    return output;\n}\n\nexport function subsetInvalidFactors(arrays) {\n    let N = arrays[0].length;\n    let output = { arrays: [], retain: null };\n\n    let invalid = new Uint8Array(N);\n    invalid.fill(0);\n    for (const x of arrays) {\n        let transformed = scran.factorize(x, { action: \"none\", placeholder: -1 });\n        output.arrays.push(transformed);\n        transformed.ids.forEach((y, i) => {\n            if (y == -1) {\n                invalid[i] = 1;\n            }\n        });\n    }\n\n    let num_invalid = 0;\n    invalid.forEach(y => { num_invalid += y; });\n    if (num_invalid == 0) {\n        return output;\n    }\n\n    let retain = new Int32Array(N - num_invalid);\n    {\n        let counter = 0;\n        for (var i = 0; i < N; i++) {\n            if (invalid[i] == 0) {\n                retain[counter] = i;\n                counter++;\n            }\n        }\n    }\n    output.retain = retain;\n\n    for (var i = 0; i < output.arrays.length; i++) {\n        let x = output.arrays[i];\n        let new_ids = scran.subsetBlock(x.ids, retain);\n        let remapping = scran.dropUnusedBlock(new_ids);\n        let new_levels = remapping.map(i => x.levels[i]);\n\n        scran.free(x.ids);\n        x.ids = new_ids;\n        x.levels = new_levels;\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\";\n\nexport const summaries2int = { \"min\": 0, \"mean\": 1, \"min_rank\": 4 };\n\nexport function unserializeGroupStats(handle, permuter, { no_summaries = false, compute_auc = true } = {}) {\n    let output = {};\n    for (const x of [ \"means\", \"detected\" ]) {\n        output[x] = permuter(handle.open(x, { load: true }).values);\n    }\n\n    for (const i of [ \"lfc\", \"delta_detected\", \"auc\", \"cohen\" ]) {\n        if (i == \"auc\" && !compute_auc) {\n            continue;\n        }\n\n        if (no_summaries) {\n            output[i] = handle.open(i, { load: true }).values;\n        } else {\n            let rhandle = handle.open(i);\n            let current = {};\n            for (const j of Object.keys(rhandle.children)) {\n                current[j] = permuter(rhandle.open(j, { load: true }).values);\n            }\n            output[i] = current;\n        }\n    }\n\n    return output;\n}\n\nexport function fillGroupStats(object, i, vals) {\n    object.means(i, { copy: false }).set(vals.means);\n    object.detected(i, { copy: false }).set(vals.detected);\n\n    for (const [s, v] of Object.entries(vals.cohen)) {\n        object.cohen(i, { summary: summaries2int[s], copy: false }).set(v);\n    }\n\n    for (const [s, v] of Object.entries(vals.lfc)) {\n        object.lfc(i, { summary: summaries2int[s], copy: false }).set(v);\n    }\n\n    for (const [s, v] of Object.entries(vals.delta_detected)) {\n        object.deltaDetected(i, { summary: summaries2int[s], copy: false }).set(v);\n    }\n\n    if (\"auc\" in vals) {\n        for (const [s, v] of Object.entries(vals.auc)) {\n            object.auc(i, { summary: summaries2int[s], copy: false }).set(v);\n        }\n    }\n}\n\n/**\n * Report marker results for a given group or cluster, ordered so that the strongest candidate markers appear first.\n *\n * @param {ScoreMarkersResults} results - The marker results object generated by the `scoreMarkers` function in **scran.js**.\n * @param {number} group - Integer specifying the group or cluster of interest.\n * Any number can be used if it was part of the `groups` passed to `scoreMarkers`.\n * @param {string} rankEffect - Summarized effect size to use for ranking markers.\n * This should follow the format of `<effect>-<summary>` where `<effect>` may be `lfc`, `cohen`, `auc` or `delta_detected`,\n * and `<summary>` may be `min`, `mean` or `min-rank`.\n *\n * @return An object containing the marker statistics for the selection, sorted by the specified effect and summary size from `rankEffect`.\n * This contains:\n *   - `means`: a Float64Array of length equal to the number of genes, containing the mean expression within the selection.\n *   - `detected`: a Float64Array of length equal to the number of genes, containing the proportion of cells with detected expression inside the selection.\n *   - `lfc`: a Float64Array of length equal to the number of genes, containing the log-fold changes for the comparison between cells inside and outside the selection.\n *   - `delta_detected`: a Float64Array of length equal to the number of genes, containing the difference in the detected proportions between cells inside and outside the selection.\n */\nexport function formatMarkerResults(results, group, rankEffect) {\n    if (!rankEffect || rankEffect === undefined) {\n        rankEffect = \"cohen-min-rank\";\n    }\n\n    var ordering;\n    {\n        // Choosing the ranking statistic. Do NOT do any Wasm allocations\n        // until 'ranking' is fully consumed!\n        let ranking;\n        let increasing = false;\n      \n        let index = 1;\n        if (rankEffect.match(/-min$/)) {\n            index = 0;\n        } else if (rankEffect.match(/-min-rank$/)) {\n            increasing = true;\n            index = 4;\n        }\n\n        if (rankEffect.match(/^cohen-/)) {\n            ranking = results.cohen(group, { summary: index, copy: false });\n        } else if (rankEffect.match(/^auc-/)) {\n            ranking = results.auc(group, { summary: index, copy: false });\n        } else if (rankEffect.match(/^lfc-/)) {\n            ranking = results.lfc(group, { summary: index, copy: false });\n        } else if (rankEffect.match(/^delta-d-/)) {\n            ranking = results.deltaDetected(group, { summary: index, copy: false });\n        } else {\n            throw \"unknown rank type '\" + rankEffect + \"'\";\n        }\n  \n        // Computing the ordering based on the ranking statistic.\n        ordering = new Int32Array(ranking.length);\n        for (var i = 0; i < ordering.length; i++) {\n            ordering[i] = i;\n        }\n        if (increasing) {\n            ordering.sort((f, s) => (ranking[f] - ranking[s]));\n        } else {\n            ordering.sort((f, s) => (ranking[s] - ranking[f]));\n        }\n    }\n  \n    // Apply that ordering to each statistic of interest.\n    var reorder = function(stats) {\n        var thing = new Float64Array(stats.length);\n        for (var i = 0; i < ordering.length; i++) {\n            thing[i] = stats[ordering[i]];\n        }\n        return thing;\n    };\n  \n    var stat_detected = reorder(results.detected(group, { copy: false }));\n    var stat_mean = reorder(results.means(group, { copy: false }));\n    var stat_lfc = reorder(results.lfc(group, { summary: 1, copy: false }));\n    var stat_delta_d = reorder(results.deltaDetected(group, { summary: 1, copy: false }));\n\n    return {\n        \"ordering\": ordering,\n        \"means\": stat_mean,\n        \"detected\": stat_detected,\n        \"lfc\": stat_lfc,\n        \"delta_detected\": stat_delta_d\n    };\n}\n\nexport function locateVersusCache(left, right, cache) {\n    let left_small = left < right;\n\n    let bigg = (left_small ? right : left);\n    if (!(bigg in cache)) {\n        cache[bigg] = {};\n    }\n    let biggversus = cache[bigg];\n\n    let smal = (left_small ? left : right); \n    let rerun = !(smal in biggversus);\n    if (rerun) {\n        biggversus[smal] = {};\n    }\n\n    return { \n        cached: biggversus[smal],\n        run: rerun,\n        left_small: left_small\n    };\n}\n\nexport function freeVersusResults(cache) {\n    if (cache) {\n        for (const v of Object.values(cache)) {\n            for (const v2 of Object.values(v)) {\n                for (const m of Object.values(v2)) {\n                    scran.free(m);\n                }\n            }\n        }\n        for (const k of Object.keys(cache)) {\n            delete cache[k];\n        }\n    }\n}\n\nexport function computeVersusResults(matrices, clusters, block, keep, cache, lfc_threshold, compute_auc) {\n    let new_block = null;\n    if (block !== null) {\n        new_block = scran.subsetBlock(block, keep);\n        scran.dropUnusedBlock(new_block);\n    }\n\n    for (const modality of matrices.available()) {\n        let modmat = matrices.get(modality);\n        let sub;\n        try {\n            sub = scran.subsetColumns(modmat, keep);\n            cache[modality] = scran.scoreMarkers(sub, clusters, { block: new_block, lfcThreshold: lfc_threshold, computeAuc: compute_auc });\n        } finally {\n            scran.free(sub);\n        }\n    }\n}\n","import * as utils from \"./general.js\";\n\nexport function subsetSums(qc, filter, mat, cache, name) {\n    let output = utils.allocateCachedArray(mat.numberOfColumns(), \"Float64Array\", cache, name);\n    let discards = filter.fetchDiscards();\n\n    // unsafe, so no more Wasm allocations past this point. \n    let sums = qc.fetchMetrics().sums({ copy: false }); \n\n    if (discards == null) {\n        output.set(sums);\n    } else {\n        let oarr = output.array();\n        var j = 0;\n        discards.forEach((x, i) => {\n            if (!x) {\n                if (j == output.length) {\n                    throw new Error(\"normalization and filtering are not in sync\");\n                }\n                oarr[j] = sums[i];\n                j++;\n            }\n        });\n        if (j !== output.length) {\n            throw new Error(\"normalization and filtering are not in sync\");\n        }\n    }\n\n    return output;\n}\n","import * as utils from \"./utils.js\";\nimport * as misc from \"./miscellaneous.js\";\n\n/**\n * Compute the length of a vector-like object.\n *\n * For Array and TypedArrays, this just returns the `length` property directly.\n *\n * Custom classes should provide a `_bioconductor_LENGTH` method to describe their length.\n * This method should accept no arguments. \n *\n * @param {*} x - Some vector-like object.\n * @return {number} Length of the object.\n */\nexport function LENGTH(x) {\n    if (\"_bioconductor_LENGTH\" in x) {\n        return x._bioconductor_LENGTH();\n    }\n\n    if (!utils.isArrayLike(x)) {\n        throw new Error(\"no method for 'LENGTH' in '\" + x.constructor.name + \"' instance\");\n    }\n\n    return x.length;\n}\n\n/**\n * Slice a vector-like object.\n *\n * For Array and TypedArrays, this just uses `slice()` or `subarray()`.\n *\n * Custom classes should provide a `_bioconductor_SLICE` method to create a slice.\n * This method should accept the same arguments as `SLICE` except for `x`.\n *\n * @param {*} x - Some vector-like object.\n * @param {Object|Array|TypedArray} i - An Array or TypedArray of integer indices specifying the slice of `x` to retain.\n *\n * Alternatively, an object containing `start` and `end`, where the slice is defined as the sequence of consecutive integers in `[start, end)`.\n * @param {Object} [options={}] - Optional parameters.\n * @param {boolean} [options.allowView=false] - Whether a view can be created to mimic the slice operation.\n * Whether this is actually done depends on the method, but may improve efficiency by avoiding unnecessary copies.\n *\n * @return {*} A vector-like object, typically of the same class as `x`, containing data for the specified slice.\n *\n * If `allowInPlace = true`, `x` _may_ be modified in place, and the return value _may_ be a reference to `x`. \n */\nexport function SLICE(x, i, { allowView = false } = {}) {\n    if (\"_bioconductor_SLICE\" in x) {\n        let output = new x.constructor;\n        x._bioconductor_SLICE(output, i, { allowView });\n        return output;\n    }\n\n    if (!utils.isArrayLike(x)) {\n        throw new Error(\"no method for 'SLICE' in '\" + x.constructor.name + \"' instance\");\n    }\n\n    if (i.constructor == Object) {\n        if (allowView && ArrayBuffer.isView(x)) {\n            return x.subarray(i.start, i.end);\n        } else {\n            return x.slice(i.start, i.end);\n        }\n    } else {\n        let output = new x.constructor(i.length);\n        i.forEach((y, j) => {\n            output[j] = x[y];\n        });\n        return output;\n    }\n}\n\n/**\n * Combine multiple vector-like objects.\n *\n * For Array and TypedArrays, the combined array is of a class that avoids information loss.\n *\n * Custom classes should provide a `_bioconductor_COMBINE` method to define the combining operation.\n * This method should accept the same arguments as `COMBINE`.\n *\n * @param {Array} objects - Array of vector-like objects to be combined.\n * It is assumed that the objects are of the same class, or at least compatible with each other -\n * for custom classes, the definition of \"compatibility\" depends on the `_bioconductor_COMBINE` method of the first element of `objects`.\n *\n * @return {*} A vector-like object containing the concatenated data from the input objects.\n * - If the first entry of `objects` is an instance of a custom class, the return value should be of the same class.\n * - If all `objects` are TypedArrays of the same class, the return value will be a TypedArray of that class.\n * - If any of the `objects` are Arrays, the return value will be an Array.\n * - If any of the `objects` are 64-bit TypedArrays of different classes, the return value will be an Array.\n * - Otherwise, for any other classes of TypedArrays in `objects`, the return value will be a Float64Array.\n */\nexport function COMBINE(objects) {\n    let x = objects[0];\n    if (\"_bioconductor_COMBINE\" in x) {\n        let output = new x.constructor;\n        x._bioconductor_COMBINE(output, objects);\n        return output;\n    }\n\n    if (!utils.isArrayLike(x)) {\n        throw new Error(\"no method for 'COMBINE' in '\" + x.constructor.name + \"' instance\");\n    }\n\n    // It is assumed that every 'y' is of some compatible Array-like type as well.\n    let total_LENGTH = 0;\n    let constructor = x.constructor;\n\n    for (const obj of objects) {\n        total_LENGTH += obj.length;\n        constructor = utils.chooseArrayConstructors(constructor, obj.constructor);\n    }\n\n    let output = new constructor(total_LENGTH);\n    let position = 0;\n    for (const obj of objects) {\n        if (\"set\" in output) {\n            output.set(obj, position);\n            position += obj.length;\n        } else {\n            obj.forEach(x => {\n                output[position] = x;\n                position++;\n            });\n        }\n    }\n\n    return output;\n}\n\n/**\n * Clone a vector-like object.\n * \n * For TypedArrays, this just uses `slice()`.\n * For Arrays, this creates a copy and runs `CLONE` on each element in the copy.\n *\n * Custom classes should provide a `_bioconductor_CLONE` method to define the cloning operation.\n * This method should accept the same arguments as `COMBINE` except for `x`.\n *\n * @param {*} x - Some vector-like object.\n * @param {Object} [options={}] - Optional parameters.\n * @param {boolean} [options.deepCopy=true] - Whether to create a deep copy.\n * The exact interpretation of `deepCopy=false` is left to each method, but generally speaking, \n * any setter (`$`-marked) functions operating on the copy should not alter `x`.\n *\n * @return {*} A clone of `x`, i.e., the return value and `x` should not compare equal.\n * If `deepCopy=true`, all internal components are also cloned.\n */\nexport function CLONE(x, { deepCopy = true } = {}) {\n    if (x instanceof Object) {\n        let options = { deepCopy };\n        if (\"_bioconductor_CLONE\" in x) {\n            let output = new x.constructor;\n            x._bioconductor_CLONE(output, options);\n            return output;\n        }\n\n        if (utils.isArrayLike(x)) {\n            if (x.constructor == Array) {\n                return x.map(y => CLONE(y, options));\n            } else if (deepCopy) {\n                return x.slice();\n            } else {\n                return x.subarray();\n            }\n        }\n\n        if (x.constructor == Object) {\n            if (deepCopy) {\n                let output = {};\n                for (const [k, v] of Object.entries(x)) {\n                    output[k] = CLONE(v);\n                }\n                return output;\n            } else {\n                return { ...x };\n            }\n        }\n\n        if (x.constructor == Map) {\n            let output = new Map;\n            for (const [k, v] of x) {\n                output.set(k, deepCopy ? CLONE(v) : v);\n            }\n            return output;\n        }\n\n        if (x.constructor == Set) {\n            let output = new Set;\n            for (const k of x) {\n                output.add(deepCopy ? CLONE(k) : k);\n            }\n            return output;\n        }\n\n\n        throw new Error(\"unknown CLONE operation for instance of class '\" + x.constructor.name + \"'\");\n    }\n\n    // Immutable atomics should be all that's left.\n    return x;\n}\n\n/**\n * Split a vector-like object along its length according to the levels of a factor of the same length.\n * This works automatically for all classes for which there is a {@linkcode SLICE} method,\n * but custom classes may also choose to define their own `_bioconductor_SPLIT` method. \n *\n * @param {*} x - Some vector-like object.\n * @param {Array|TypedArray} factor - Array containing the factor to use for splitting.\n * This should have the same length as `x`.\n *\n * Alternatively, the output of {@linkcode presplitFactor} can be supplied.\n *\n * @return {Object} An object containing one key per level of `factor`,\n * where the value is the slice of `x` corresponding to the indices of that level in `factor`.\n */\nexport function SPLIT(x, factor) {\n    if (factor.constructor != Object) {\n        factor = misc.presplitFactor(factor);\n    }\n\n    if (\"_bioconductor_SPLIT\" in x) {\n        return x._bioconductor_SPLIT(factor);\n    }\n\n    let output = {};\n    for (const [k, v] of Object.entries(factor)) {\n        output[k] = SLICE(x, v);\n    }\n\n    return output;\n}\n\n/**\n * Return the number of rows for a two-dimensional object.\n * Custom classes should provide a `_bioconductor_NUMBER_OF_ROWS` method, accepting no arguments.\n *\n * @param {*} x - Some two-dimensional object.\n * @return {number} Number of rows.\n */\nexport function NUMBER_OF_ROWS(x) {\n    if (!(\"_bioconductor_NUMBER_OF_ROWS\" in x)) {\n        throw new Error(\"no 'NUMBER_OF_ROWS' method available for '\" + x.constructor.name + \"' instance\");\n    }\n    return x._bioconductor_NUMBER_OF_ROWS();\n}\n\n/**\n * Return the number of columns for a two-dimensional object.\n * Custom classes should provide a `_bioconductor_NUMBER_OF_COLUMNS` method, accepting no arguments.\n *\n * @param {*} x - Some two-dimensional object.\n * @return {number} Number of columns.\n */\nexport function NUMBER_OF_COLUMNS(x) {\n    if (!(\"_bioconductor_NUMBER_OF_COLUMNS\" in x)) {\n        throw new Error(\"no 'NUMBER_OF_COLUMNS' method available for '\" + x.constructor.name + \"' instance\");\n    }\n    return x._bioconductor_NUMBER_OF_COLUMNS();\n}\n\n/**\n * Slice a two-dimensional object by its rows and/or columns.\n *\n * Custom classes should provide a `_bioconductor_SLICE_2D` method, accepting the same arguments as this generic but with `x` replaced by an \"empty\" instance of the same class.\n * Each method should then fill the empty instance with the sliced contents of `x`.\n *\n * @param {*} x - Some two-dimensional object.\n * @param {?(Object|Array|TypedArray)} rows - An Array or TypedArray of integer indices specifying the row-wise slice of `x` to retain.\n *\n * Alternatively, an object containing `start` and `end`, where the slice is defined as the sequence of consecutive integers in `[start, end)`.\n * \n * Alternatively `null`, to indicate that no slicing is to be performed on the rows.\n * @param {?(Object|Array|TypedArray)} columns - An Array or TypedArray of integer indices specifying the column-wise slice of `x` to retain.\n *\n * Alternatively, an object containing `start` and `end`, where the slice is defined as the sequence of consecutive integers in `[start, end)`.\n *\n * Alternatively `null`, to indicate that no slicing is to be performed on the columns.\n * @param {Object} [options={}] - Optional parameters.\n * @param {boolean} [options.allowView=false] - Whether a view can be created to mimic the slice operation.\n * Whether this is actually done depends on the method, but may improve efficiency by avoiding unnecessary copies.\n *\n * @return {*} A two-dimensional object, typically of the same class as `x`, containing data for the specified slice.\n */\nexport function SLICE_2D(x, rows, columns, { allowView = false } = {}) {\n    if (!(\"_bioconductor_SLICE_2D\" in x)) {\n        throw new Error(\"no 'SLICE_2D' method available for '\" + x.constructor.name + \"' instance\");\n    }\n    let output = new x.constructor;\n    x._bioconductor_SLICE_2D(output, rows, columns, { allowView });\n    return output;\n}\n\n/**\n * Combine multiple two-dimensional objects by row.\n * Custom classes should provide a `_bioconductor_COMBINE_ROWS` method to define the combining operation.\n * This method should accept:\n * - an \"empty\" instance of the class of the first object, to be populated with data.\n * - an array of objects to be combined, like `objects`.\n *\n * @param {Array} objects - Array of two-dimensional objects to be combined by row.\n * It is assumed that the objects are of the same class, or at least compatible with each other -\n * for custom classes, the definition of \"compatibility\" depends on the `_bioconductor_COMBINE_ROWS` method of the first element of `objects`.\n *\n * @return {*} A two-dimensional object containing the row-wise concatenated data from the input objects, typically of the same class as the first entry of `objects`.\n */\nexport function COMBINE_ROWS(objects) {\n    let x = objects[0];\n    if (!(\"_bioconductor_COMBINE_ROWS\" in x)) {\n        throw new Error(\"no 'COMBINE_ROWS' method available for '\" + x.constructor.name + \"' instance\");\n    }\n    let output = new x.constructor;\n    x._bioconductor_COMBINE_ROWS(output, objects);\n    return output;\n}\n\n/**\n * Combine multiple two-dimensional objects by column.\n * Custom classes should provide a `_bioconductor_COMBINE_COLUMNS` method to define the combining operation.\n * This method should accept:\n * - an \"empty\" instance of the class of the first object, to be populated with data.\n * - an array of objects to be combined, like `objects`.\n *\n * @param {Array} objects - Array of two-dimensional objects to be combined by column.\n * It is assumed that the objects are of the same class, or at least compatible with each other -\n * for custom classes, the definition of \"compatibility\" depends on the `_bioconductor_COMBINE_COLUMNS` method of the first element of `objects`.\n *\n * @return {*} A two-dimensional object containing the column-wise concatenated data from the input objects, typically of the same class as the first entry of `objects`.\n */\nexport function COMBINE_COLUMNS(objects) {\n    let x = objects[0];\n    if (!(\"_bioconductor_COMBINE_COLUMNS\" in x)) {\n        throw new Error(\"no 'COMBINE_COLUMNS' method available for '\" + x.constructor.name + \"' instance\");\n    }\n    let output = new x.constructor;\n    x._bioconductor_COMBINE_COLUMNS(output, objects);\n    return output;\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as utils from \"./utils.js\";\n\n/**\n * The Annotated class provides a store for arbitrary object-wide metadata.\n * It is intended as a base class for other structures and should not be constructed directly.\n */\nexport class Annotated {\n    /**\n     * @param {Object|Map} metadata - Object or Map containing arbitrary metadata as key-value pairs.\n     */\n    constructor(metadata) {\n        if (arguments.length == 0) {\n            return;\n        }\n\n        this._metadata = utils.object2map(metadata);\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {Map} Map containing arbitrary metadata.\n     */\n    metadata() {\n        return this._metadata;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {Object|Map} value - Object containing the metadata.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this Annotated instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {Annotated} The Annotated object after replacing the metadata.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setMetadata(value, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        target._metadata = utils.object2map(value);\n        return target;\n    }\n\n    /**\n     * @param {Object} value - Object containing the metadata.\n     * @return {Annotated} A reference to this Annotated object.\n     */\n    $setMetadata(value) {\n        return this.setMetadata(value, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        output._metadata = cutils.cloneField(this._metadata, deepCopy);\n        return;\n    }\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as ann from \"./Annotated.js\";\nimport * as il from \"./InternalList.js\";\n\n/**\n * A DataFrame is a collection of equilength vector-like objects as \"columns\".\n * The number of rows in the DataFrame is equal to the length of the columns, where the i-th row consists of the i-th element from each column.\n *\n * This class supports optional row names, which are either `null` or an array of strings of length equal to the number of rows.\n *\n * This class supports empty instances with a non-zero number of rows, which may be useful for piece-wise construction.\n *\n * The vector-like object for each column is expected to have methods for the following generics:\n *\n * - {@linkcode LENGTH}\n * - {@linkcode SLICE}\n * - {@linkcode COMBINE}\n * - {@linkcode CLONE}\n *\n * The DataFrame itself defines methods for the following generics:\n *\n * - {@linkcode LENGTH}\n * - {@linkcode SLICE}\n * - {@linkcode COMBINE}\n * - {@linkcode CLONE}\n *\n * @augments Annotated\n */\nexport class DataFrame extends ann.Annotated {\n    /**\n     * @param {Object|Map} columns - Object or Map where keys are the column names and the values are equilength vector-like objects.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?number} [options.numberOfRows=null] - Non-negative value specifying the number of rows in the DataFrame.\n     * If `null`, this is automatically determined from the length of the vectors in `columns`, or from the length of `rowNames`.\n     * If non-`null`, this should not conflict with the inferred lengths from `columns` or `rowNames`.\n     * @param {?Array} [options.rowNames=null] - Array of strings containing the names for each row.\n     * If non-`null`, this should have the same length as the vectors inside `columns`, if any exist.\n     * If `null`, no row names are used.\n     * @param {?Array} [options.columnOrder=null] - Array of strings specifying the ordering of the columns.\n     * If non-`null`, this should have the same values as the keys of `columns`.\n     * If `null`, an arbitrary ordering is obtained from `columns`.\n     * @param {Object} [options.metadata={}] - Object containing arbitrary metadata as key-value pairs.\n     */\n    constructor(columns, { numberOfRows = null, rowNames = null, columnOrder = null, metadata = {} } = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        super(metadata);\n        this._numberOfRows = numberOfRows;\n        this._rowNames = rowNames;\n        \n        try {\n            this._columns = new il.InternalList(columns, columnOrder);\n        } catch (e) {\n            throw new Error(\"failed to initialize columns for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n\n        for (const k of this._columns.names()) {\n            let n = generics.LENGTH(this._columns.entry(k));\n            if (this._numberOfRows == null) {\n                this._numberOfRows = n;\n            } else if (n != this._numberOfRows) {\n                throw new Error(\"expected all arrays in 'columns' to have equal length\");\n            }\n        }\n\n        if (rowNames != null) {\n            if (this._numberOfRows == null) {\n                this._numberOfRows = rowNames.length;\n            }\n            utils.checkNamesArray(rowNames, \"'rowNames'\", this._numberOfRows, \"'numberOfRows' or the length of arrays in 'columns'\");\n        }\n\n        if (this._numberOfRows == null) {\n            this._numberOfRows = 0;\n        }\n    }\n\n    static className = \"DataFrame\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {?Array} Array of strings containing row names, or `null` if no row names are available.\n     */\n    rowNames() {\n        return this._rowNames;\n    }\n\n    /**\n     * @return {Array} Array of strings containing the column names in the specified order.\n     */\n    columnNames() {\n        return this._columns.names();\n    }\n\n    /**\n     * @param {string} name - Name of a column.\n     * @return {boolean} Whether the column exists in this DataFrame.\n     */\n    hasColumn(name) {\n        return this._columns.has(name);\n    }\n\n    /**\n     * @return {number} Number of rows in this DataFrame.\n     */\n    numberOfRows() {\n        return this._numberOfRows;\n    }\n\n    /**\n     * @return {number} Number of columns in this DataFrame.\n     */\n    numberOfColumns() {\n        return this._columns.numberOfEntries();\n    }\n\n    /**\n     * @param {string|number} i - Column to retrieve, either by name or index.\n     * @return {*} The contents of column `i` as a vector-like object.\n     */\n    column(i) {\n        return this._columns.entry(i);\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {string|number} i - Column to remove, either by name or index.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DataFrame instance in place.\n     * If `false`, a new instance is returned.\n     * \n     * @return {DataFrame} The DataFrame after removing the specified column.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    removeColumn(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        target._columns = this._columns.delete(i, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Column to remove, either by name or index.\n     * @return {DataFrame} A reference to this DataFrame after removing the specified column.\n     */\n    $removeColumn(i) {\n        return this.removeColumn(i, { inPlace: true });\n    }\n\n    /**\n     * @param {string|number} i - Identity of the column to add, either by name or index.\n     * - If `i` is a number, the column at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of columns.\n     * - If `i` is a string, any column with the same name is replaced.\n     *   If no such column exists, a new column is appended to the DataFrame.\n     * @param {*} value - Array-like column to set/add as the column.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DataFrame instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DataFrame} The DataFrame after adding/replacing the specified column.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setColumn(i, value, { inPlace = false } = {}) {\n        if (generics.LENGTH(value) != this._numberOfRows) {\n            throw new Error(\"expected 'value' to have the same length as the number of rows in 'x'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._columns = this._columns.set(i, value, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the column to add, either by name or index.\n     * - If `i` is a number, the column at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of columns.\n     * - If `i` is a string, any column with the same name is replaced.\n     *   If no such column exists, a new column is appended to the DataFrame.\n     * @param {*} value - Array-like column to set/add as the column.\n     *\n     * @return {DataFrame} A reference to this DataFrame after adding/replacing the specified column.\n     */\n    $setColumn(i, value) {\n        return this.setColumn(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of unique strings containing the new name for each column.\n     * This should have the same length as {@linkcode DataFrame#columnNames DataFrame.columnNames}.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DataFrame instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DataFrame} The DataFrame with modified column names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setColumnNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        target._columns = target._columns.setNames(names, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {Array} names - Array of unique strings containing the new name for each column.\n     * This should have the same length as {@linkcode DataFrame#columnNames DataFrame.columnNames}.\n     * @return {DataFrame} A reference to this DataFrame with modified column names.\n     */\n    $setColumnNames(names) {\n        return this.setColumnNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {?Array} names - Array of unique strings containing the new name for each row.\n     * This should have the same length as {@linkcode DataFrame#numberOfRows DataFrame.numberOfRows}.\n     *\n     * Alternatively, this may be `null` to remove any existing column names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DataFrame instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DataFrame} The DataFrame with modified row names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRowNames(names, { inPlace = false } = {}) {\n        if (names != null) {\n            utils.checkNamesArray(names, \"replacement 'names'\", this._numberOfRows, \"'numberOfRows()'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._rowNames = names;\n        return target;\n    }\n\n    /**\n     * @param {?Array} names - Array of unique strings containing the new name for each row.\n     * This should have the same length as {@linkcode DataFrame#numberOfRows DataFrame.numberOfRows}.\n     *\n     * Alternatively, this may be `null` to remove any existing column names.\n     * @return {DataFrame} A reference to this DataFrame with modified row names.\n     */\n    $setRowNames(names) {\n        return this.setRowNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the columns to retain in the slice.\n     * This should refer to unique column names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DataFrame instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DataFrame} Reference to this DataFrame after slicing to the specified columns.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceColumns(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        target._columns = this._columns.slice(i, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the columns to retain in the slice.\n     * This should refer to unique column names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DataFrame instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DataFrame} Reference to this DataFrame after slicing to the specified columns.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    $sliceColumns(i) {\n        return this.sliceColumns(i, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_LENGTH() {\n        return this.numberOfRows();\n    }\n\n    _bioconductor_SLICE(output, i, { allowView = false }) {\n        let options = { allowView };\n\n        let new_columns = this._columns.apply(v => generics.SLICE(v, i, options));\n        let new_rowNames = (this._rowNames == null ? null : generics.SLICE(this._rowNames, i, options));\n\n        let new_numberOfRows;\n        if (i.constructor == Object) {\n            new_numberOfRows = i.end - i.start;\n        } else {\n            new_numberOfRows = i.length;\n        }\n\n        output._rowNames = new_rowNames;\n        output._columns = new_columns;\n        output._numberOfRows = new_numberOfRows;\n        output._metadata = this._metadata;\n        return; \n    }\n\n    _bioconductor_COMBINE(output, objects) {\n        let new_columns = il.InternalList.parallelCombine(objects.map(x => x._columns), generics.COMBINE);\n\n        let all_n = [];\n        let all_l = [];\n        for (const yi of objects) {\n            all_n.push(yi.rowNames());\n            all_l.push(yi.numberOfRows());\n        }\n\n        let new_numberOfRows = utils.sum(all_l);\n        let new_rowNames = utils.combineNames(all_n, all_l, new_numberOfRows);\n\n        output._rowNames = new_rowNames;\n        output._columns = new_columns;\n        output._numberOfRows = new_numberOfRows;\n        output._metadata = this._metadata;\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n        output._columns = cutils.cloneField(this._columns, deepCopy);\n        output._rowNames = cutils.cloneField(this._rowNames, deepCopy);\n        output._numberOfRows = this._numberOfRows;\n        return;\n    }\n};\n\n/**\n * Flexibly combine multiple DataFrames by row by filling in missing columns with an array of `null`s.\n * This is equivalent to calling {@linkcode COMBINE} on an array of DataFrames that may have mismatching columns.\n *\n * @param {Array} objects - Array of {@linkplain DataFrame}s to be combined.\n *\n * @return {DataFrame} The combined DataFrame, where the number of rows is equal to sum of rows across `objects`,\n * and the columns is equal to the union of columns across `objects`.\n */\nexport function flexibleCombineRows(objects) {\n    let ckeys = new Set();\n    let corder = [];\n    for (const current of objects) {\n        let cnames = current.columnNames();\n        for (const a of cnames) {\n            if (!ckeys.has(a)) {\n                ckeys.add(a);\n                corder.push(a);\n            }\n        }\n    }\n\n    let copies = [];\n    for (const current of objects) {\n        let dummy = new Array(current.numberOfRows());\n        dummy.fill(null);\n        let copy = generics.CLONE(current, { deepCopy: false });\n\n        for (const a of corder) {\n            if (!current.hasColumn(a)) {\n                copy.$setColumn(a, dummy);\n            }\n        }\n\n        copy._columns = copy._columns.reorder(corder);\n        copies.push(copy);\n    }\n\n    return generics.COMBINE(copies);\n}\n","import * as cutils from \"./clone-utils.js\";\n\n/**\n * Dense matrix of numbers.\n * Not really a Bioconductor-exclusive data structure, but we need this at a minimum for the {@linkplain SummarizedExperiment} to be useful.\n *\n * - {@linkcode NUMBER_OF_ROWS}\n * - {@linkcode NUMBER_OF_COLUMNS}\n * - {@linkcode SLICE_2D}\n * - {@linkcode COMBINE_ROWS}\n * - {@linkcode COMBINE_COLUMNS}\n * - {@linkcode CLONE}\n */\nexport class DenseMatrix {\n    /**\n     * @param {number} numberOfRows - Number of rows, duh.\n     * @param {number} numberOfColumns - Number of columns.\n     * @param {TypedArray} values - 1-dimensional array of the matrix contents.\n     * This should have length equal to the product of `numberOfRows` and `numberOfColumns`.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.columnMajor=true] - Whether `values` represents a column-major layout.\n     */\n    constructor(numberOfRows, numberOfColumns, values, { columnMajor = true } = {}) {\n        if (arguments.length == 0) {\n            return;\n        }\n\n        this._numberOfRows = numberOfRows;\n        this._numberOfColumns = numberOfColumns;\n        this._values = values;\n        this._columnMajor = columnMajor;\n        if (numberOfRows * numberOfColumns != values.length) {\n            throw new Error(\"length of 'values' should be equal to the product of 'dimensions'\");\n        }\n    }\n\n    static name = \"DenseMatrix\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {number} Number of rows.\n     */\n    numberOfRows() {\n        return this._numberOfRows;\n    }\n\n    /**\n     * @return {number} Number of columns.\n     */\n    numberOfColumns() {\n        return this._numberOfColumns;\n    }\n\n    /**\n     * @return {boolean} Whether the matrix is column-major.\n     */\n    isColumnMajor() {\n        return this._columnMajor;\n    }\n\n    /**\n     * @return {TypedArray} Matrix contents as a 1-dimensional array.\n     */\n    values() {\n        return this._values;\n    }\n\n    #extractor(i, nprimary, nsecondary, allowView, primaryMajor) {\n        if (!primaryMajor) {\n            let output = new this._values.constructor(nsecondary);\n            let offset = i;\n            for (var s = 0; s < nsecondary; s++) {\n                output[s] = this._values[offset];\n                offset += nprimary;\n            }\n            return output;\n\n        } else {\n            let start = i * nsecondary;\n            let end = start + nsecondary;\n            if (allowView) {\n                return this._values.subarray(start, end);\n            } else {\n                return this._values.slice(start, end);\n            }\n        }\n    }\n\n    /**\n     * Retrieve the contents of a particular row.\n     *\n     * @param {number} i - Index of the row of interest.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.allowView=false] - Whether to allow a view to be returned, if possible.\n     *\n     * @return {TypedArray} Contents of the row `i`.\n     * This may be a view on the array returned by {@linkcode DenseMatrix#values values}, if permitted by the layout.\n     */\n    row(i, { allowView = false } = {}) {\n        return this.#extractor(i, this._numberOfRows, this._numberOfColumns, allowView, !this._columnMajor);\n    }\n\n    /**\n     * Retrieve the contents of a particular column.\n     *\n     * @param {number} i - Index of the column of interest.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.allowView=false] - Whether to allow a view to be returned, if possible.\n     *\n     * @return {TypedArray} Contents of the column `i`.\n     * This may be a view on the array returned by {@linkcode DenseMatrix#values values}, if permitted by the layout.\n     */\n    column(i, { allowView = false } = {}) {\n        return this.#extractor(i, this._numberOfColumns, this._numberOfRows, allowView, this._columnMajor);\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {TypedArray} values - 1-dimensional array of matrix contents,\n     * of the same length as the array returned by {@linkcode DenseMatrix#values values}.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DenseMatrix instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DenseMatrix} The DenseMatrix after modifying the matrix contents.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setValues(values, { inPlace = false } = {}) {\n        if (values.length !== this._values.length) {\n            throw new Error(\"replacement 'values' should have length equal to 'values()'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._values = values;\n        return target;\n    }\n\n    /**\n     * @param {TypedArray} values - 1-dimensional array of matrix contents,\n     * of the same length as the array returned by {@linkcode DenseMatrix#values values}.\n     * @return {DenseMatrix} A reference to this DenseMatrix after modifying the matrix contents.\n     */\n    $setValues(values) {\n        return this.setValues(values, { inPlace: true });\n    }\n\n    #inserter(i, nprimary, nsecondary, primaryMajor, replacement) {\n        if (!primaryMajor) {\n            let output = new this._values.constructor(nsecondary);\n            let offset = i;\n            for (var s = 0; s < nsecondary; s++) {\n                this._values[offset] = replacement[s];\n                offset += nprimary;\n            }\n        } else {\n            let start = i * nsecondary;\n            this._values.set(replacement, start);\n        }\n    }\n\n    /**\n     * @param {number} i - Row index to set.\n     * @param {TypedArray} values - Row contents, of length equal to the number of columns in this DenseMatrix.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DenseMatrix instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DenseMatrix} The DenseMatrix after modifying the matrix contents.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRow(i, values, { inPlace = false } = {}) {\n        if (values.length !== this._numberOfColumns) {\n            throw new Error(\"replacement row should have length equal to 'numberOfColumns()'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._values = target._values.slice();\n        }\n\n        target.#inserter(i, target._numberOfRows, target._numberOfColumns, !target._columnMajor, values);\n        return target;\n    }\n\n    /**\n     * @param {number} i - Row index to set.\n     * @param {TypedArray} values - Row contents, of length equal to the number of columns in this DenseMatrix.\n     * @return {DenseMatrix} A reference to this DenseMatrix after modifying the matrix contents.\n     */\n    $setRow(i, value) {\n        return this.setRow(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {number} i - Column index to set.\n     * @param {TypedArray} values - Column contents, of length equal to the number of rows in this DenseMatrix.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DenseMatrix instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DenseMatrix} The DenseMatrix after modifying the matrix contents.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setColumn(i, values, { inPlace = false } = {}) {\n        if (values.length !== this._numberOfRows) {\n            throw new Error(\"replacement column should have length equal to 'numberOfRows()'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._values = target._values.slice();\n        }\n\n        target.#inserter(i, target._numberOfColumns, target._numberOfRows, target._columnMajor, values);\n        return target;\n    }\n\n    /**\n     * @param {number} i - Column index to set.\n     * @param {TypedArray} values - Column contents, of length equal to the number of columns in this DenseMatrix.\n     * @return {DenseMatrix} A reference to this DenseMatrix after modifying the matrix contents.\n     */\n    $setColumn(i, value) {\n        return this.setColumn(i, value, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_NUMBER_OF_ROWS() {\n        return this.numberOfRows();\n    }\n\n    _bioconductor_NUMBER_OF_COLUMNS() {\n        return this.numberOfColumns();\n    }\n\n    _bioconductor_SLICE_2D(output, rows, columns, {}) {\n        let full_rows = (rows === null);\n        let is_row_range = (!full_rows && rows.constructor == Object);\n        let new_rows = full_rows ? this._numberOfRows : (is_row_range ? rows.end - rows.start : rows.length);\n        output._numberOfRows = new_rows;\n\n        let full_columns = (columns === null);\n        let is_column_range = (!full_columns && columns.constructor == Object);\n        let new_columns = full_columns ? this._numberOfColumns : (is_column_range ? columns.end - columns.start : columns.length);\n        output._numberOfColumns = new_columns;\n\n        let new_values = new this._values.constructor(new_rows * new_columns);\n        output._values = new_values;\n\n        if (this._columnMajor) {\n            this.#primarySlicer(columns, full_columns, is_column_range, this._numberOfColumns, rows, full_rows, is_row_range, this._numberOfRows, new_rows, new_values);\n        } else {\n            this.#primarySlicer(rows, full_rows, is_row_range, this._numberOfRows, columns, full_columns, is_column_range, this._numberOfColumns, new_columns, new_values);\n        }\n        output._columnMajor = this._columnMajor;\n        return;\n    }\n\n    #primarySlicer(primarySlice, fullPrimary, isPrimaryRange, primaryDim, secondarySlice, fullSecondary, isSecondaryRange, inSecondaryDim, outSecondaryDim, outputValues) {\n        if (fullPrimary) {\n            for (var p = 0; p < primaryDim; p++) {\n                this.#secondarySlicer(secondarySlice, fullSecondary, isSecondaryRange, inSecondaryDim, outSecondaryDim, outputValues, p, p);\n            }\n        } else if (isPrimaryRange) {\n            for (var p = primarySlice.start; p < primarySlice.end; p++) {\n                this.#secondarySlicer(secondarySlice, fullSecondary, isSecondaryRange, inSecondaryDim, outSecondaryDim, outputValues, p, p - primarySlice.start);\n            }\n        } else {\n            for (var pi = 0; pi < primarySlice.length; pi++) {\n                this.#secondarySlicer(secondarySlice, fullSecondary, isSecondaryRange, inSecondaryDim, outSecondaryDim, outputValues, primarySlice[pi], pi);\n            }\n        }\n    }\n\n    #secondarySlicer(secondarySlice, fullSecondary, isSecondaryRange, inSecondaryDim, outSecondaryDim, outputValues, inPrimary, outPrimary) {\n        let in_offset = inPrimary * inSecondaryDim;\n        let out_offset = outPrimary * outSecondaryDim;\n\n        if (fullSecondary) {\n            let view = this._values.subarray(in_offset, in_offset + inSecondaryDim);\n            outputValues.set(view, out_offset);\n        } else if (isSecondaryRange) {\n            for (var s = secondarySlice.start; s < secondarySlice.end; s++) {\n                outputValues[out_offset + s - secondarySlice.start] = this._values[in_offset + s];\n            }\n        } else {\n            for (var si = 0; si < secondarySlice.length; si++) {\n                outputValues[out_offset + si] = this._values[in_offset + secondarySlice[si]];\n            }\n        }\n    }\n\n    _combiner(objects, primaryFun, secondaryFun, isPrimaryMajor, secondaryName) {\n        let num_primary = primaryFun(objects[0]);\n        let num_secondary = secondaryFun(objects[0]);\n        for (var i = 1; i < objects.length; i++) {\n            if (secondaryFun(objects[i]) !== num_secondary) {\n                throw new Error(\"all objects must have the same number of \" + secondaryName);\n            }\n            num_primary += primaryFun(objects[i]);\n        }\n\n        let primary_major = isPrimaryMajor(objects[0]);\n        let values = new objects[0]._values.constructor(num_primary * num_secondary);\n\n        if (primary_major) {\n            let used_primary = 0;\n            for (var i = 0; i < objects.length; i++) {\n                let current = objects[i];\n                let cur_primary = primaryFun(current);\n                let out_offset = used_primary * num_secondary;\n\n                if (isPrimaryMajor(current)) {\n                    values.set(current._values, out_offset);\n                } else {\n                    for (var s = 0; s < num_secondary; s++) {\n                        let in_offset = s * cur_primary;\n                        let out_offset2 = out_offset + s;\n                        for (var p = 0; p < cur_primary; p++) {\n                            values[out_offset2 + p * num_secondary] = current._values[in_offset + p];\n                        }\n                    }\n                }\n\n                used_primary += cur_primary;\n            }\n        } else {\n            let used_primary = 0;\n            for (var i = 0; i < objects.length; i++) {\n                let current = objects[i];\n                let cur_primary = primaryFun(current);\n\n                if (!isPrimaryMajor(current)) {\n                    for (var s = 0; s < num_secondary; s++) {\n                        let view_offset = s * cur_primary;\n                        let view = current._values.subarray(view_offset, view_offset + cur_primary);\n                        values.set(view, used_primary + s * num_primary);\n                    }\n                } else {\n                    for (var p = 0; p < cur_primary; p++) {\n                        let in_offset = p * num_secondary;\n                        let out_offset = used_primary + p;\n                        for (var s = 0; s < num_secondary; s++) {\n                            values[out_offset + s * num_primary] = current._values[in_offset + s];\n                        }\n                    }\n                }\n\n                used_primary += cur_primary;\n            }\n        }\n\n        return { num_primary, num_secondary, values, primary_major };\n    }\n\n    _bioconductor_COMBINE_ROWS(output, objects) {\n        let combined = this._combiner(objects,\n            x => x._numberOfRows,\n            x => x._numberOfColumns,\n            x => !(x._columnMajor),\n            \"columns\"\n        );\n\n        output._numberOfRows = combined.num_primary;\n        output._numberOfColumns = combined.num_secondary;\n        output._values = combined.values;\n        output._columnMajor = !(combined.primary_major);\n        return;\n    }\n\n    _bioconductor_COMBINE_COLUMNS(output, objects) {\n        let combined = this._combiner(objects,\n            x => x._numberOfColumns,\n            x => x._numberOfRows,\n            x => x._columnMajor,\n            \"rows\"\n        );\n\n        output._numberOfColumns = combined.num_primary;\n        output._numberOfRows = combined.num_secondary;\n        output._values = combined.values;\n        output._columnMajor = combined.primary_major;\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true } = {}) {\n        output._values = (deepCopy ? this._values.slice() : this._values);\n        output._numberOfRows = this._numberOfRows;\n        output._numberOfColumns = this._numberOfColumns;\n        output._columnMajor = this._columnMajor;\n        return;\n    }\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as ir from \"./IRanges.js\";\nimport * as vec from \"./Vector.js\";\nimport * as olap from \"./overlap-utils.js\";\n\n/**\n * A GRanges object is a collection of genomic ranges, inspired by the class of the same name from the Bioconductor ecosystem.\n * Each range consists of a sequence name, a start position on that sequence, and a width.\n * Each range may also be associated with arbitrary range-level metadata in a {@linkplain DataFrame}.\n * The GRanges defines methods for the following generics:\n *\n * - {@linkcode LENGTH}\n * - {@linkcode SLICE}\n * - {@linkcode COMBINE}\n * - {@linkcode CLONE}\n *\n * @extends Vector\n */\nexport class GRanges extends vec.Vector {\n    static #convertToInt8Array(x) {\n        if (x instanceof Int8Array) {\n            return x;\n        } else {\n            return new Int8Array(x);\n        }\n    }\n\n    static #checkStrandedness(strand) {\n        for (const y of strand) {\n            if (y < -1 || y > 1) {\n                throw new Error(\"'strand' must be -1, 0 or 1\");\n            }\n        }\n    }\n\n    /**\n     * @param {Array} seqnames - Array of strings containing the sequence names for each genomic range.\n     * @param {IRanges} ranges - Position and width of the range on its specified sequence.\n     * This should have the same length as `seqnames`.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?(Array|TypedArray)} [options.strand=null] - Array containing the strandedness of each genomic range.\n     * This should be 0 (any strand), 1 (forward strand) or -1 (reverse strand).\n     * If `null`, this is assumed to be 0 for all genomic ranges.\n     * @param {?Array} [options.names=null] - Array of strings of length equal to `start`, containing names for each genomic range.\n     * Alternatively `null`, in which case the ranges are assumed to be unnamed.\n     * @param {?DataFrame} [options.elementMetadata=null] - A {@linkplain DataFrame} with number of rows equal to the length of `start`, containing arbitrary per-range annotations.\n     * Alternatively `null`, in which case a zero-column DataFrame is automatically constructed.\n     * @param {Object} [options.metadata={}] - Object containing arbitrary metadata as key-value pairs.\n     */\n    constructor(seqnames, ranges, { strand = null, names = null, elementMetadata = null, metadata = {} } = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        super(seqnames.length, { names, elementMetadata, metadata });\n\n        utils.checkStringArray(seqnames, \"seqnames\");\n        this._seqnames = seqnames;\n\n        let n = seqnames.length;\n        if (n !== generics.LENGTH(ranges)) {\n            throw utils.formatLengthError(\"'ranges'\", \"'seqnames'\");\n        }\n        this._ranges = ranges;\n\n        if (strand !== null) {\n            if (n !== strand.length) {\n                throw utils.formatLengthError(\"'strand'\", \"'seqnames'\");\n            }\n            strand = GRanges.#convertToInt8Array(strand);\n            GRanges.#checkStrandedness(strand);\n        } else {\n            strand = new Int8Array(n);\n            strand.fill(0);\n        }\n        this._strand = strand;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {Int32Array} Array of integers containing the start position for each genomic range.\n     */\n    start() {\n        return this._ranges.start();\n    }\n\n    /**\n     * @return {Int32Array} Array of integers containing the end position (specifically, one-past-the-end) for each genomic range.\n     */\n    end() {\n        return this._ranges.end();\n    }\n\n    /**\n     * @return {Int32Array} Array of integers containing the width of each genomic range.\n     */\n    width() {\n        return this._ranges.width();\n    }\n\n    /**\n     * @return {Array} Array of strings containing the sequence name for each genomic range.\n     */\n    seqnames() {\n        return this._seqnames;\n    }\n\n    /**\n     * @return {IRanges} Start positions and widths for all ranges on their specified sequence names.\n     */\n    ranges() {\n        return this._ranges;\n    }\n\n    /**\n     * @return {Int8Array} Array containing the strandedness for each genomic range - 0 (any strand), 1 (forward strand) or -1 (reverse strand).\n     */\n    strand() {\n        return this._strand;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {Array} seqnames - Array of strings containing the sequence names for each genomic range.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this GRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {GRanges} The GRanges object after setting the sequence names to `seqnames`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setSeqnames(seqnames, { inPlace = false } = {}) {\n        utils.checkNamesArray(seqnames, \"replacement 'seqnames'\", generics.LENGTH(this), \"'LENGTH(<GRanges>)'\");\n        let target = cutils.setterTarget(this, inPlace); \n        target._seqnames = seqnames;\n        return target;\n    }\n\n    /**\n     * @param {Array} seqnames - Array of strings containing the sequence names for each genomic range.\n     * @return {GRanges} A reference to this GRanges object after setting the sequence names to `seqnames`.\n     */\n    $setSeqnames(seqnames) {\n        return this.setSeqnames(seqnames, { inPlace: true });\n    }\n\n    /**\n     * @param {IRanges} ranges - Start positions and widths for each genomic range.\n     * This should have length equal to the number of ranges. \n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this GRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {GRanges} The GRanges object after setting the ranges to `ranges`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRanges(ranges, { inPlace = false } = {}) {\n        if (!(ranges instanceof ir.IRanges)) {\n            throw new Error(\"'ranges' should be an IRanges object\");\n        }\n\n        if (generics.LENGTH(ranges) !== generics.LENGTH(this._ranges)) {\n            throw utils.formatLengthError(\"replacement 'ranges'\", \"'LENGTH(<GRanges>)'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace); \n        target._ranges = ranges;\n        return target;\n    }\n\n    /**\n     * @param {IRanges} ranges - Start positions and widths for each genomic range.\n     * This should have length equal to the number of ranges. \n     * @return {GRanges} A reference to this GRanges object after setting the ranges to `ranges`.\n     */\n    $setRanges(ranges) {\n        return this.setRanges(ranges, { inPlace: true });\n    }\n\n    /**\n     * @param {Array|TypedArray} strand - Array of strands for each genomic range.\n     * This should have length equal to the number of ranges. \n     * Entries may be 0 (any strand), 1 (forward strand) or -1 (reverse strand).\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this GRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {GRanges} The GRanges object after setting the strands to `strand`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setStrand(strand, { inPlace = false } = {}) {\n        if (this._strand.length !== strand.length) {\n            throw utils.formatLengthError(\"'strand'\", \"'seqnames'\");\n        }\n        strand = GRanges.#convertToInt8Array(strand);\n        GRanges.#checkStrandedness(strand);\n\n        let target = cutils.setterTarget(this, inPlace); \n        target._strand = strand;\n        return target;\n    }\n\n    /**\n     * @param {Array|TypedArray} strand - Array of strands for each genomic range.\n     * This should have length equal to the number of ranges. \n     * Entries may be 0 (any strand), 1 (forward strand) or -1 (reverse strand).\n     *\n     * @return {GRanges} A reference to this GRanges object after setting the strands to `strand`.\n     */\n    $setStrand(strand) {\n        return this.setStrand(strand, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?(Array|Set)} [options.restrictToSeqnames=null] - Array or Set containing the sequence names to use in the index.\n     * If `null`, all available sequence names are used.\n     * @param {?(Array|Set)} [options.restrictToStrand=null] - Array or Set containing the strands to use in the index.\n     * If `null`, all available strands are used.\n     *\n     * @return {GRangesOverlapIndex} A pre-built index for computing overlaps with other {@linkplain GRanges} instances.\n     */\n    buildOverlapIndex({ restrictToSeqnames = null, restrictToStrand = null } = {}) {\n        let indices = utils.createSequence(generics.LENGTH(this));\n        let by_seqname = generics.SPLIT(indices, this._seqnames);\n        let starts = this.start();\n        let ends = this.end();\n\n        if (restrictToSeqnames !== null && restrictToSeqnames instanceof Array) {\n            restrictToSeqnames = new Set(restrictToSeqnames);\n        }\n        if (restrictToStrand !== null && restrictToStrand instanceof Array) {\n            restrictToStrand = new Set(restrictToStrand);\n        }\n\n        for (const name of Object.keys(by_seqname)) {\n            if (restrictToSeqnames !== null && !restrictToSeqnames.has(name)) {\n                delete by_seqname[name];\n                continue;\n            }\n            let seqname_indices = by_seqname[name];\n            let seqname_strand = generics.SLICE(this._strand, seqname_indices);\n            let by_strand = generics.SPLIT(seqname_indices, seqname_strand);\n\n            for (const str of Object.keys(by_strand)) {\n                if (restrictToStrand !== null && !restrictToStrand.has(Number(str))) {\n                    delete by_strand[str];\n                    continue;\n                }\n                let str_indices = by_strand[str];\n                by_strand[str] = olap.buildIntervalTree(starts, ends, { slice: str_indices });\n            }\n            by_seqname[name] = by_strand;\n        }\n\n        return new GRangesOverlapIndex(by_seqname);\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_LENGTH() {\n        return this._seqnames.length;\n    }\n\n    _bioconductor_SLICE(output, i, { allowView = false }) {\n        super._bioconductor_SLICE(output, i, { allowView });\n        output._seqnames = generics.SLICE(this._seqnames, i, { allowView });\n        output._ranges = generics.SLICE(this._ranges, i, { allowView });\n        output._strand = generics.SLICE(this._strand, i, { allowView });\n        return;\n    }\n\n    _bioconductor_COMBINE(output, objects) {\n        super._bioconductor_COMBINE(output, objects);\n\n        let all_sn = [];\n        let all_rr = [];\n        let all_st = [];\n        for (const x of objects) {\n            all_sn.push(x._seqnames);\n            all_rr.push(x._ranges);\n            all_st.push(x._strand);\n        }\n\n        output._seqnames = generics.COMBINE(all_sn);\n        output._ranges = generics.COMBINE(all_rr);\n        output._strand = generics.COMBINE(all_st);\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n        output._seqnames = cutils.cloneField(this._seqnames, deepCopy);\n        output._ranges = cutils.cloneField(this._ranges, deepCopy);\n        output._strand = cutils.cloneField(this._strand, deepCopy);\n        return;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {GRanges} A zero-length GRanges object.\n     */\n    static empty() {\n        return new GRanges([], ir.IRanges.empty());\n    }\n}\n\n/**\n * Pre-built index for overlapping {@linkplain GRanges} objects.\n * This is typically constructed using the {@linkcode GRanges#buildOverlapIndex GRanges.buildOverlapIndex} method for a \"reference\" object,\n * and can be applied to different query GRanges to identify overlaps with the reference.\n *\n * @hideconstructor\n */\nexport class GRangesOverlapIndex {\n    constructor(index) {\n        this._index = index;\n    }\n\n    /**\n     * @param {GRanges} query - The query object, containing ranges to be overlapped with those in the reference GRanges (that was used to construct this GRangesOverlapIndex object).\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.ignoreStrand=true] - Whether to ignore differences in strandedness between the ranges in `query` and the reference object.\n     *\n     * @return {Array} An array of length equal to the number of ranges in `query`,\n     * where each element is an array containing the indices of the overlapping ranges in the reference {@linkplain GRanges} object.\n     */\n    overlap(query, { ignoreStrand = true } = {}) {\n        let n = generics.LENGTH(query);\n        let results = new Array(n);\n        let starts = query.start();\n        let ends = query.end();\n\n        for (var i = 0; i < n; i++) {\n            results[i] = [];\n            let my_results = results[i];\n\n            let name = query._seqnames[i];\n            if (!(name in this._index)) {\n                continue;\n            }\n            let seq_index = this._index[name];\n\n            let strand = query._strand[i];\n            let allowed_strands;\n            if (ignoreStrand || strand == 0) {\n                allowed_strands = Object.keys(seq_index);\n            } else {\n                let sstr = String(strand);\n                if (!(sstr in seq_index)) {\n                    continue;\n                }\n                allowed_strands = [ sstr ];\n            }\n\n            let start = starts[i];\n            let end = ends[i];\n            for (const str of allowed_strands) {\n                let str_results = olap.queryIntervalTree(start, end, seq_index[str]);\n                str_results.forEach(x => my_results.push(x));\n            }\n        }\n\n        return results;\n    }\n}\n","import * as vec from \"./Vector.js\";\nimport * as gr from \"./GRanges.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as generics from \"./AllGenerics.js\";\n\n/**\n * A GroupedGRanges object is a collection of groups of genomic ranges, inspired by the `GRangesList` class from the Bioconductor ecosystem.\n * Each group consists of a {@linkplain GRanges} object of arbitrary length, which is most often used to represent a multi-exon gene.\n * The GroupedGRanges can be considered a vector of groups, and defines methods for the following generics:\n *\n * - {@linkcode LENGTH}\n * - {@linkcode SLICE}\n * - {@linkcode COMBINE}\n * - {@linkcode CLONE}\n *\n * Our implementation re-uses Bioconductor's strategy of storing the groups in a single concatenated GRanges.\n * This improves efficiency for large numbers of small GRanges, especially in placeholder objects where all the GRanges are zero-length.\n * \n * @extends Vector\n */\nexport class GroupedGRanges extends vec.Vector {\n    static #computeStarts(lengths) {\n        let starts = new Int32Array(lengths.length);\n        let last = 0;\n        for (var i = 0; i < lengths.length; i++) {\n            starts[i] = last;\n            last += lengths[i];\n        }\n        return { starts: starts, total: last };\n    }\n\n    #staged_setGroup = null;\n\n    /**\n     * @param {Array|GRanges} ranges - An array of {@linkplain GRanges} objects, where each element represents a group of genomic ranges.\n     * All objects should have compatible columns in their {@linkplain Vector#elementMetadata elementMetadata}.\n     * \n     * Alternatively, a single GRanges containing a concatenation of ranges from all groups.\n     * In this case, `rangeLengths` must be supplied.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?(TypedArray|Array)} [options.rangeLengths=null] - Length of the ranges within each group.\n     * This should be coercible to an Int32Array, contain non-negative values, and have a sum equal to the length of `ranges`.\n     * Only used if `ranges` is a single {@linkplain GRanges} object, where each group's ranges are assumed to form contiguous intervals along `ranges`.\n     * @param {?Array} [options.names=null] - Array of strings of length equal to `start`, containing names for each genomic range.\n     * Alternatively `null`, in which case the ranges are assumed to be unnamed.\n     * @param {?DataFrame} [options.elementMetadata=null] - A {@linkplain DataFrame} with number of rows equal to the length of `start`, containing arbitrary per-range annotations.\n     * Alternatively `null`, in which case a zero-column DataFrame is automatically constructed.\n     * @param {Object} [options.metadata={}] - Object containing arbitrary metadata as key-value pairs.\n     */\n    constructor(ranges, { rangeLengths = null, names = null, elementMetadata = null, metadata = {} } = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        if (ranges.constructor == Array) {\n            super(ranges.length, { names, elementMetadata, metadata });\n            rangeLengths = new Int32Array(ranges.length);\n            for (var i = 0; i < rangeLengths.length; i++) {\n                if (!(ranges[i] instanceof gr.GRanges)) {\n                    throw new Error(\"'ranges' must either be a 'GRanges' or an array of 'GRanges'\");\n                }\n                rangeLengths[i] = generics.LENGTH(ranges[i]);\n            }\n            ranges = generics.COMBINE(ranges);\n\n        } else {\n            if (!(ranges instanceof gr.GRanges)) {\n                throw new Error(\"'ranges' must either be a 'GRanges' or an array of 'GRanges'\");\n            }\n            if (rangeLengths == null) {\n                throw new Error(\"'rangeLengths' must be specified when 'ranges' is a 'GRanges'\");\n            }\n            super(rangeLengths.length, { names, elementMetadata, metadata });\n            rangeLengths = utils.convertToInt32Array(rangeLengths);\n            utils.checkNonNegative(rangeLengths);\n        }\n\n        this._ranges = ranges;\n        this._rangeLengths = rangeLengths;\n\n        let accumulated = GroupedGRanges.#computeStarts(rangeLengths);\n        this._rangeStarts = accumulated.starts;\n\n        if (accumulated.total !== generics.LENGTH(ranges)) {\n            throw new Error(\"sum of 'rangeLengths' must be equal to the length of 'ranges'\");\n        }\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {GRanges} The concatenated set of ranges across all groups. \n     */\n    ranges() {\n        this.#flush_staged_setGroup();\n        return this._ranges;\n    }\n\n    /**\n     * @return {Int32Array} The start indices for each group's ranges along the concatenated set of ranges returned by {@linkcode GroupedGRanges#ranges ranges}.\n     */\n    rangeStarts() {\n        this.#flush_staged_setGroup();\n        return this._rangeStarts;\n    }\n\n    /**\n     * @return {Int32Array} The length of each group's ranges along the concatenated set of ranges returned by {@linkcode GroupedGRanges#ranges ranges}.\n     */\n    rangeLengths() {\n        this.#flush_staged_setGroup();\n        return this._rangeLengths;\n    }\n\n    /**\n     * @param {number} i - Index of the group of interest.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.allowView=false] - Whether a view can be created in any internal slicing operations.\n     *\n     * @return {GRanges} The genomic ranges for group `i`.\n     */\n    group(i, { allowView = false } = {}) {\n        this.#flush_staged_setGroup();\n        let s = this._rangeStarts[i];\n        return generics.SLICE(this._ranges, { start: s, end: s + this._rangeLengths[i] }, { allowView });\n    }\n\n    /**\n     * @return {number} Number of groups in this object.\n     */\n    numberOfGroups() {\n        return this._rangeStarts.length;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {GRanges} ranges - Genomic ranges of length equal to the concatenated set of ranges returned by {@linkcode GroupedGRanges#ranges ranges}.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this GroupedGRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {GroupedGRanges} The GroupedGRanges object after modifying the internal ranges.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRanges(ranges, { inPlace = false } = {}) {\n        if (!(ranges instanceof gr.GRanges)) {\n            throw new Error(\"'ranges' must be a 'GRanges'\");\n        }\n\n        this.#flush_staged_setGroup();\n        if (generics.LENGTH(ranges) !== generics.LENGTH(this._ranges)) {\n            throw utils.formatLengthError(\"'ranges'\", \"number of ranges\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._ranges = ranges;\n        return target;\n    }\n\n    /**\n     * @param {GRanges} ranges - Genomic ranges of length equal to the concatenated set of ranges returned by {@linkcode GroupedGRanges#ranges ranges}.\n     * @return {GroupedGRanges} A reference to this GroupedGRanges object after modifying the internal ranges.\n     */\n    $setRanges(ranges) {\n        return this.setRanges(ranges, { inPlace: true });\n    }\n\n    #flush_staged_setGroup() {\n        let staged = this.#staged_setGroup;\n        if (staged === null) {\n            return;\n        }\n\n        staged.sort((a, b) => {\n            let diff = a[0] - b[0];\n            return (diff === 0 ? a[1] - b[1] : diff);\n        });\n\n        let counter = 0;\n        let accumulated = 0;\n        let last_start = 0;\n        let more_ranges = [];\n\n        let ngroups = this.numberOfGroups();\n        for (var g = 0; g < ngroups; g++) {\n            if (counter < staged.length && g == staged[counter][0]) { \n                let current_start = this._rangeStarts[g];\n                if (last_start < current_start) {\n                    more_ranges.push(generics.SLICE(this._ranges, { start: last_start, end: current_start }));\n                }\n                last_start = current_start + this._rangeLengths[g];\n\n                let replacement;\n                do {\n                    replacement = staged[counter][2];\n                    counter++;\n                } while (counter < staged.length && g == staged[counter][0]);\n\n                more_ranges.push(replacement);\n                this._rangeLengths[g] = generics.LENGTH(replacement);\n            }\n\n            this._rangeStarts[g] = accumulated;\n            accumulated += this._rangeLengths[g];\n        }\n\n        let nranges = generics.LENGTH(this._ranges);\n        if (last_start < nranges) {\n            more_ranges.push(generics.SLICE(this._ranges, { start: last_start, end: nranges }));\n        }\n\n        try {\n            this._ranges = generics.COMBINE(more_ranges);\n        } catch (e) {\n            throw new Error(\"failed to combine staged '$setGroup' operations; \" + e.message);\n        }\n\n        this.#staged_setGroup = null;\n        return;\n    }\n\n    /**\n     * Multiple consecutive calls to `$setGroup` are not executed immediately.\n     * Rather, the operations are staged and executed in batch once the modified GroupedGRanges is used in other methods.\n     * This enables efficient setting of individual groups inside a single concatenated {@linkplain GRanges}. \n     *\n     * @param {number} i - Index of the group of interest.\n     * @param {GRanges} ranges - Genomic ranges for group `i`.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this GroupedGRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {GroupedGRanges} The GroupedGRanges object after setting group `i`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setGroup(i, ranges, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (target.#staged_setGroup === null) {\n            target.#staged_setGroup = [];\n        } else if (!inPlace) {\n            target.#staged_setGroup = target.#staged_setGroup.slice();\n        }\n\n        if (!inPlace) {\n            target._rangeStarts = target._rangeStarts.slice();\n            target._rangeLengths = target._rangeLengths.slice();\n        }\n\n        let nops = target.#staged_setGroup.length;\n        target.#staged_setGroup.push([i, nops, ranges]);\n        return target;\n    }\n\n    /**\n     * See comments for {@linkcode GroupedGRanges#$setGroup $setGroup}.\n     *\n     * @param {number} i - Index of the group of interest.\n     * @param {GRanges} ranges - Genomic ranges for group `i`.\n     *\n     * @return {GroupedGRanges} A reference to this GroupedGRanges object after setting group `i`.\n     */\n    $setGroup(i, ranges) {\n        return this.setGroup(i, ranges, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?(Array|Set)} [options.restrictToSeqnames=null] - Array or Set containing the sequence names to use in the index.\n     * If `null`, all available sequence names are used.\n     * @param {?(Array|Set)} [options.restrictToStrand=null] - Array or Set containing the strands to use in the index.\n     * If `null`, all available strands are used.\n     *\n     * @return {GroupedGRangesOverlapIndex} A pre-built index for computing overlaps with other {@linkplain GRanges} instances.\n     */\n    buildOverlapIndex({ restrictToSeqnames = null, restrictToStrand = null } = {}) {\n        this.#flush_staged_setGroup();\n        return new GroupedGRangesOverlapIndex(\n            this._ranges.buildOverlapIndex({ restrictToSeqnames, restrictToStrand }),\n            generics.LENGTH(this._ranges),\n            this._rangeStarts,\n            this._rangeLengths\n        );\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_LENGTH() {\n        return this._rangeStarts.length;\n    }\n\n    _bioconductor_SLICE(output, i, { allowView = false } = {}) {\n        super._bioconductor_SLICE(output, i, { allowView });\n        this.#flush_staged_setGroup();\n\n        output._rangeLengths = generics.SLICE(this._rangeLengths, i, { allowView });\n        let accumulated = GroupedGRanges.#computeStarts(output._rangeLengths);\n        output._rangeStarts = accumulated.starts;\n\n        if (i.constructor == Object) {\n            // Handle this specially for optimizing allowView = true.\n            let s = this._rangeStarts[i.start];\n            output._ranges = generics.SLICE(this._ranges, { start: s, end: s + accumulated.total }, { allowView });\n        } else {\n            let keep = new Int32Array(accumulated.total);\n\n            let counter = 0;\n            for (const j of i) {\n                let start = this._rangeStarts[j];\n                let end = start + this._rangeLengths[j];\n                for (var k = start; k < end; k++) {\n                    keep[counter] = k;\n                    counter++;\n                }\n            }\n\n            output._ranges = generics.SLICE(this._ranges, keep, { allowView });\n        }\n\n        return;\n    }\n\n    _bioconductor_COMBINE(output, objects) {\n        super._bioconductor_COMBINE(output, objects);\n\n        // We need to flush the staged operations in each object.\n        for (const o of objects) {\n            o.#flush_staged_setGroup();\n        }\n\n        output._rangeLengths = generics.COMBINE(objects.map(x => x.rangeLengths()));\n        let accumulated = GroupedGRanges.#computeStarts(output._rangeLengths);\n        output._rangeStarts = accumulated.starts;\n        output._ranges = generics.COMBINE(objects.map(x => x._ranges));\n\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n\n        output.#staged_setGroup = cutils.cloneField(this.#staged_setGroup, deepCopy);\n        output._rangeLengths = cutils.cloneField(this._rangeLengths, deepCopy);\n        output._rangeStarts = cutils.cloneField(this._rangeStarts, deepCopy);\n        output._ranges = cutils.cloneField(this._ranges, deepCopy);\n\n        return;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {number} [numberOfGroups=0] - Numbe of empty groups to create.\n     * @return {GroupedGRanges} A GroupedGRanges object of length equal to `numberOfGroups`,\n     * where each group is of zero length.\n     */\n    static empty(numberOfGroups) {\n        let runs = new Int32Array(numberOfGroups);\n        runs.fill(0);\n        return new GroupedGRanges(gr.GRanges.empty(), { rangeLengths: runs });\n    }\n}\n\n/**\n * Pre-built index for overlapping {@linkplain GroupedGRanges} objects.\n * This is typically constructed using the {@linkcode GroupedGRanges#buildOverlapIndex GroupedGRanges.buildOverlapIndex} method for a \"reference\" object,\n * and can be applied to different query GroupedGRanges or {@linkplain GRanges} to identify overlaps with the reference.\n *\n * @hideconstructor\n */\nexport class GroupedGRangesOverlapIndex {\n    constructor(index, fullLength, rangeStarts, rangeLengths) {\n        this._index = index;\n        this._rangeStarts = rangeStarts;\n        this._rangeLengths = rangeLengths;\n\n        let rev_map = new Int32Array(fullLength);\n        for (var i = 0; i < rangeStarts.length; i++) {\n            let start = rangeStarts[i];\n            let end = start + rangeLengths[i];\n            for (var s = start; s < end; s++) {\n                rev_map[s] = i;\n            }\n        }\n        this._reverseMapping = rev_map;\n    }\n\n    /**\n     * @param {GroupedGRanges|GRanges} query - The query object, containing ranges to be overlapped with those in the reference GroupedGRanges (that was used to construct this GroupedGRangesOverlapIndex object).\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.ignoreStrand=true] - Whether to ignore differences in strandedness between the ranges in `query` and the reference object.\n     *\n     * @return {Array} An array of length equal to the number of ranges or groups in `query`,\n     * where each element is an array containing the indices of the overlapping ranges in the reference {@linkplain GRanges} object.\n     */\n    overlap(query, { ignoreStrand = true } = {}) {\n        let output = new Array(this._rangeStarts.length);\n        let rev_map = this._reverseMapping;\n\n        if (query instanceof GroupedGRanges) {\n            let overlaps = this._index.overlap(query._ranges);\n            for (var i = 0; i < query._rangeStarts.length; i++) {\n                let start = query._rangeStarts[i];\n                let end = start + query._rangeLengths[i];\n\n                let results = new Set;\n                for (var s = start; s < end; s++) {\n                    overlaps[s].forEach(x => results.add(rev_map[x]));\n                }\n                output[i] = Array.from(results);\n            }\n\n        } else {\n            let overlaps = this._index.overlap(query);\n            for (var i = 0; i < overlaps.length; i++) {\n                let results = new Set;\n                overlaps[i].forEach(x => results.add(rev_map[x]));\n                output[i] = Array.from(results);\n            }\n        }\n\n        return output;\n    }\n\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as df from \"./DataFrame.js\";\nimport * as vec from \"./Vector.js\";\nimport * as olap from \"./overlap-utils.js\";\n\n/**\n * An IRanges object is a collection of integer ranges, inspired by the class of the same name from the Bioconductor ecosystem.\n * Each range consists of a start position and a width, and may be associated with arbitrary range-level metadata in a {@linkplain DataFrame}.\n * The IRanges defines methods for the following generics:\n *\n * - {@linkcode LENGTH}\n * - {@linkcode SLICE}\n * - {@linkcode COMBINE}\n * - {@linkcode CLONE}\n *\n * @extends Vector\n */\nexport class IRanges extends vec.Vector {\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {Array|TypedArray} start - Array of start positions for each range.\n     * This should be coercible into an Int32Array.\n     * @param {Array|TypedArray} width - Array of widths for each range.\n     * This should be coercible into an Int32Array.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?Array} [options.names=null] - Array of strings of length equal to `start`, containing names for each range.\n     * Alternatively `null`, in which case the ranges are assumed to be unnamed.\n     * @param {?DataFrame} [options.elementMetadata=null] - A {@linkplain DataFrame} with number of rows equal to the length of `start`, containing arbitrary per-range annotations.\n     * Alternatively `null`, in which case a zero-column DataFrame is automatically constructed.\n     * @param {Object} [options.metadata={}] - Object containing arbitrary metadata as key-value pairs.\n     */\n    constructor(start, width, { names = null, elementMetadata = null, metadata = {} } = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        super(start.length, { names, elementMetadata, metadata });\n\n        this._start = utils.convertToInt32Array(start);\n        utils.checkNonNegative(this._start, \"start\");\n\n        this._width = utils.convertToInt32Array(width);\n        utils.checkNonNegative(this._width, \"width\");\n\n        let n = this._start.length;\n        if (n !== this._width.length) {\n            throw new Error(\"'start' and 'width' should have the same length\");\n        }\n    }\n\n    static className = \"IRanges\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {Int32Array} Array of integers containing the start position for each range.\n     */\n    start() {\n        return this._start;\n    }\n\n    /**\n     * @return {Int32Array} Array of integers containing the end position (specifically, one-past-the-end) for each range.\n     */\n    end() {\n        return this._start.map((x, i) => x + this._width[i]);\n    }\n\n    /**\n     * @return {Int32Array} Array of integers containing the width of each range.\n     */\n    width() {\n        return this._width;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {Array|TypedArray} value - Array of start positions for each range.\n     * This should have length equal to the number of ranges and be coercible into an Int32Array.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this IRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {IRanges} The IRanges object after setting the start positions to `value`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setStart(value, { inPlace = false } = {}) {\n        let candidate = utils.convertToInt32Array(value);\n        if (candidate.length !== generics.LENGTH(this)) {\n            throw new Error(\"'start' should be replaced by array of the same length\");\n        }\n        utils.checkNonNegative(candidate, \"start\");\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._start = candidate;\n        return target;\n    }\n\n    /**\n     * @param {Array|TypedArray} value - Array of start positions for each range.\n     * This should have length equal to the number of ranges and be coercible into an Int32Array.\n     * @return {IRanges} A reference to this IRanges object after setting the start positions to `value`.\n     */\n    $setStart(value) {\n        return this.setStart(value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array|TypedArray} value - Array of widths for each range.\n     * This should have length equal to the number of ranges and be coercible into an Int32Array.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this IRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {IRanges} The IRanges object after setting the widths to `value`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setWidth(value, { inPlace = false } = {}) {\n        let candidate = utils.convertToInt32Array(value);\n        if (candidate.length !== generics.LENGTH(this)) {\n            throw new Error(\"'width' should be replaced by array of the same length\");\n        }\n        utils.checkNonNegative(candidate, \"width\");\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._width = candidate;\n        return target;\n    }\n\n    /**\n     * @param {Array|TypedArray} value - Array of widths for each range.\n     * This should have length equal to the number of ranges and be coercible into an Int32Array.\n     * @return {IRanges} A reference to this IRanges object after setting the widths to `value`.\n     */\n    $setWidth(value) {\n        return this.setWidth(value, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {IRangesOverlapIndex} A pre-built index for computing overlaps with other {@linkplain IRanges} instances.\n     */\n    buildOverlapIndex() {\n        let tree = olap.buildIntervalTree(this._start, this.end());\n        return new IRangesOverlapIndex(tree);\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_LENGTH() {\n        return this._start.length;\n    }\n\n    _bioconductor_SLICE(output, i, { allowView = false }) {\n        super._bioconductor_SLICE(output, i, { allowView });\n        output._start = generics.SLICE(this._start, i, { allowView });\n        output._width = generics.SLICE(this._width, i, { allowView });\n        return;\n    }\n\n    _bioconductor_COMBINE(output, objects) {\n        super._bioconductor_COMBINE(output, objects);\n\n        let all_s = [];\n        let all_w = [];\n        for (const x of objects) {\n            all_s.push(x._start);\n            all_w.push(x._width);\n        }\n\n        output._start = generics.COMBINE(all_s);\n        output._width = generics.COMBINE(all_w);\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n        output._start = cutils.cloneField(this._start, deepCopy);\n        output._width = cutils.cloneField(this._width, deepCopy);\n        return;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {IRanges} A zero-length IRanges object.\n     */\n    static empty() {\n        return new IRanges(new Int32Array, new Int32Array);\n    }\n}\n\n/**\n * Pre-built index for overlapping {@linkplain IRanges} objects.\n * This is typically constructed using the {@linkcode IRanges#buildOverlapIndex IRanges.buildOverlapIndex} method for a \"reference\" object,\n * and can be applied to different query IRanges to identify overlaps with the reference.\n *\n * @hideconstructor\n */\nexport class IRangesOverlapIndex {\n    constructor(tree) {\n        this._tree = tree;\n    }\n\n    /**\n     * @param {IRanges} query - The query object, containing ranges to be overlapped with those in the reference IRanges (that was used to construct this IRangesOverlapIndex object).\n     * @return {Array} An array of length equal to the number of ranges in `query`,\n     * where each element is an array containing the indices of the overlapping ranges in the reference {@linkplain IRanges} object.\n     */\n    overlap(query) {\n        let n = generics.LENGTH(query);\n        let output = new Array(n);\n        for (var i = 0; i < n; i++) {\n            output[i] = olap.queryIntervalTree(query._start[i], query._start[i] + query._width[i], this._tree);\n        }\n        return output;\n    }\n}\n","import * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as generics from \"./AllGenerics.js\";\n\nexport class InternalList {\n    constructor(entries, order) {\n        if (arguments.length == 0){\n            return;\n        }\n\n        entries = utils.object2map(entries);\n\n        let expected = Array.from(entries.keys());\n        if (order !== null) {\n            utils.checkNamesArray(order, \"'order'\", expected.length, \"the length of 'entries'\");\n            let observed = order.slice().sort();\n            expected.sort();\n\n            if (!utils.areArraysEqual(observed, expected)) {\n                throw new Error(\"values of 'order' should be the same as the keys of 'entries'\");\n            }\n        } else {\n            order = expected;\n        }\n\n        this._entries = entries;\n        this._order = order;\n    }\n\n    static className = \"InternalList\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    names() {\n        return this._order;\n    }\n\n    numberOfEntries() {\n        return this._order.length;\n    }\n\n    #check_entry_index(i) {\n        if (i < 0 || i >= this._order.length) {\n            throw new Error(\" index '\" + String(i) + \"' out of range for this \" + this.constructor.className);\n        }\n    }\n\n    entry(i) {\n        if (typeof i == \"string\") {\n            if (!this._entries.has(i)) {\n                throw new Error(\"no entry '\" + i + \"' present in this \" + this.constructor.className);\n            }\n            return this._entries.get(i);\n        } else {\n            this.#check_entry_index(i);\n            return this._entries.get(this._order[i]);\n        }\n    }\n\n    has(name) {\n        return this._entries.has(name);\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n    \n    delete(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            // Shallow copies so that we can do our setting.\n            target._order = target._order.slice();\n            target._entries = new Map(target._entries); \n        }\n\n        if (typeof i == \"string\") {\n            let ii = target._order.indexOf(i);\n            if (ii < 0) {\n                throw new Error(\"no entry '\" + i + \"' present in this \" + this.constructor.className);\n            }\n            target._order.splice(ii, 1); \n            target._entries.delete(i);\n        } else {\n            this.#check_entry_index(i);\n            let n = target._order[i];\n            target._order.splice(i, 1);\n            target._entries.delete(n);\n        }\n\n        return target;\n    }\n\n    set(i, value, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            // Shallow copy so that we can do our setting.\n            target._entries = new Map(target._entries);\n        }\n\n        if (typeof i == \"string\") {\n            if (!target._entries.has(i)) {\n                if (!inPlace) {\n                    target._order = target._order.slice();\n                }\n                target._order.push(i);\n            }\n            target._entries.set(i, value);\n        } else {\n            this.#check_entry_index(i);\n            target._entries.set(target._order[i], value);\n        }\n\n        return target;\n    }\n\n    setNames(names, { inPlace = false } = {}) {\n        utils.checkNamesArray(names, \"replacement 'names'\", this._order.length, \"length of 'names()'\");\n\n        let new_entries = new Map;\n        for (var i = 0; i < names.length; i++) {\n            if (new_entries.has(names[i])) {\n                throw new Error(\"detected duplicate value '\" + names[i] + \"' in replacement 'names'\");\n            }\n            new_entries.set(names[i], this._entries.get(this._order[i]));\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._entries = new_entries;\n        target._order = names;\n        return target;\n    }\n\n    slice(indices, { inPlace = false } = {}) {\n        let new_entries = new Map;\n        let new_order = [];\n\n        for (var ii of indices) {\n            if (typeof ii != \"string\") {\n                this.#check_entry_index(ii);\n                ii = this._order[ii];\n            }\n            if (new_entries.has(ii)) {\n                throw new Error(\"duplicate entries detected in slice request\");\n            } else if (!this._entries.has(ii)) {\n                throw new Error(\"slice contains missing entry '\" + ii + \"' \");\n            }\n\n            new_entries.set(ii, this._entries.get(ii));\n            new_order.push(ii);\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._entries = new_entries;\n        target._order = new_order;\n        return target;\n    }\n\n    reorder(indices, { inPlace = false } = {}) {\n        // Reorder can be slightly more efficient than slice because we just\n        // need to change the ordering vector rather than creating a new Map.\n        if (indices.length !== this._order.length) {\n            throw utils.formatLengthError(\"reordered indices\", \"the number of existing entries\");\n        }\n\n        let new_order = [];\n        for (var ii of indices) {\n            if (typeof ii != \"string\") {\n                this.#check_entry_index(ii);\n                ii = this._order[ii];\n            }\n            if (!this._entries.has(ii)) {\n                throw new Error(\"missing entry '\" + ii + \"' among the reordered indices\");\n            }\n            new_order.push(ii);\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._order = new_order;\n        return target;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_CLONE(output, { deepCopy = true } = {}) {\n        output._entries = (deepCopy ? generics.CLONE(this._entries) : this._entries);\n        output._order = (deepCopy ? generics.CLONE(this._order) : this._order);\n        return;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    apply(FUN, { inPlace = false } = {}) {\n        let new_entries = (inPlace ? this._entries : new Map);\n        for (const [k, v] of this._entries) {\n            new_entries.set(k, FUN(v));\n        }\n        return (inPlace ? this : new InternalList(new_entries, this._order));\n    }\n\n    static parallelCombine(objects, combiner) {\n        let first_order = objects[0]._order;\n        for (var i = 1; i < objects.length; i++) {\n            if (!utils.areArraysEqual(first_order, objects[i]._order)) {\n                throw new Error(\"detected differences in names between first object and object \" + String(i) + \" to be combined\");\n            }\n        }\n\n        let new_entries = new Map;\n        for (const k of first_order) {\n            let found = objects.map(x => x._entries.get(k));\n            new_entries.set(k, combiner(found));\n        }\n\n        return new InternalList(new_entries, first_order);\n    }\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as gr from \"./GRanges.js\";\nimport * as ggr from \"./GroupedGRanges.js\";\nimport * as se from \"./SummarizedExperiment.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\n\n/**\n * A RangedSummarizedExperiment is a {@linkplain SummarizedExperiment} subclass where each row represents a genomic interval.\n * As such, it stores an additional {@linkplain GRanges} or {@linkplain GroupedGRanges} of length equal to the number of rows,\n * where each element represents the genomic range(s) for the corresponding row of the SummarizedExperiment.\n *\n * The RangedSummarizedExperiment supports the same set of generics as the {@linkplain SummarizedExperiment}.\n * Each method will call the base method, with the following extensions:\n *\n * - {@linkcode SLICE_2D} will additionally slice the supplied genomic ranges by the desired `rows`.\n * - {@linkcode COMBINE_ROWS} will combine genomic ranges across objects.\n *   If some objects contain a GroupedGRanges and other objects contain GRanges, the latter will be coerced to a GroupedGRanges (where each group contains one range) before combining.\n *   If any object is a base SummarizedExperiment, a GroupedGRanges containing zero-length groups will be automatically constructed to attempt combining.\n * - {@linkcode COMBINE_COLUMNS} will use the genomic ranges from the first object.\n *\n * @extends SummarizedExperiment\n */\nexport class RangedSummarizedExperiment extends se.SummarizedExperiment {\n    #check_rowRanges(x) {\n        if (!(x instanceof gr.GRanges) && !(x instanceof ggr.GroupedGRanges)) {\n            throw new Error(\"'rowRanges' should be a 'GRanges' or 'GroupedGRanges' instance\");\n        }\n        if (generics.LENGTH(x) !== this._rowData.numberOfRows()) {\n            throw utils.formatLengthError(\"'rowRanges'\", \"the number of rows\");\n        }\n    }\n\n    /**\n     * @param {Object} assays - Object where keys are the assay names and values are multi-dimensional arrays of experimental data.\n     * All arrays should have the same number of rows and columns.\n     * @param {?(GRanges|GroupedGRanges)} rowRanges - Genomic ranges corresponding to each row.\n     *\n     * Alternatively, each row may correspond to a group of genomic ranges.\n     *\n     * If `null`, a {@linkplain GroupedGRanges} is constructed where each row corresponds to one group of ranges of zero length.\n     * @param {Object} [options={}] - Optional parameters, including those used in the {@linkplain SummarizedExperiment} constructor.\n     */\n    constructor(assays, rowRanges, options = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        super(assays, options);\n\n        if (rowRanges === null) {\n            rowRanges = ggr.GroupedGRanges.empty(this.numberOfRows());\n        } else {\n            this.#check_rowRanges(rowRanges);\n        }\n        this._rowRanges = rowRanges;\n\n        return;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {GRanges} Genomic ranges corresponding to each row.\n     */\n    rowRanges() {\n        return this._rowRanges;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {GRanges} value - Genomic ranges corresponding to each row.\n     * This should have length equal to the number of rows in this RangedSummarizedExperiment.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this Annotated instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {RangedSummarizedExperiment} The RangedSummarizedExperiment after modifying its `rowRanges`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRowRanges(value, { inPlace = false } = {}) {\n        this.#check_rowRanges(value);\n        let target = cutils.setterTarget(this, inPlace);\n        target._rowRanges = value;\n        return target;\n    }\n\n    /**\n     * @param {GRanges} value - Genomic ranges corresponding to each row.\n     * This should have length equal to the number of rows in this RangedSummarizedExperiment.\n     * @return {RangedSummarizedExperiment} A reference to this RangedSummarizedExperiment after modifying its `rowRanges`.\n     */\n    $setRowRanges(value) {\n        return this.setRowRanges(value, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_SLICE_2D(output, rows, columns, { allowView = false }) {\n        super._bioconductor_SLICE_2D(output, rows, columns, { allowView });\n        if (rows !== null) {\n            output._rowRanges = generics.SLICE(this._rowRanges, rows);\n        } else {\n            output._rowRanges = this._rowRanges;\n        }\n    }\n\n    _bioconductor_COMBINE_ROWS(output, objects) {\n        super._bioconductor_COMBINE_ROWS(output, objects);\n\n        let collected = [];\n        let has_empty = false;\n        let has_ggr = false;\n\n        for (var i = 0; i < objects.length; i++) {\n            let x = objects[i];\n            if (x instanceof RangedSummarizedExperiment) {\n                let y = x._rowRanges;\n                if (y instanceof ggr.GroupedGRanges) {\n                    has_ggr = true;\n                }\n                collected.push(y);\n            } else if (x instanceof se.SummarizedExperiment) {\n                has_empty = true;\n                collected.push(null);\n            } else {\n                throw new Error(\"objects to be combined must be SummarizedExperiments (failing for object \" + String(i) + \")\");\n            }\n        }\n\n        // Promoting nulls and GRanges to GroupedGRanges, if necessary.\n        if (has_empty || has_ggr) {\n            for (var i = 0; i < collected.length; i++) {\n                let current = collected[i];\n\n                if (current instanceof gr.GRanges) {\n                    let widths = new Int32Array(generics.LENGTH(current));\n                    widths.fill(1);\n\n                    let options = { \n                        rangeLengths: widths,\n                        names: current.names(),\n                        elementMetadata: current.elementMetadata(),\n                        metadata: current.metadata()\n                    };\n\n                    if (options.names !== null) {\n                        current = current.setNames(null);\n                    } \n\n                    if (options.elementMetadata.metadata().size > 0 || options.elementMetadata.numberOfColumns() > 0) {\n                        current = current.setElementMetadata(null);\n                    }\n\n                    if (options.metadata.size > 0) {\n                        current = current.setMetadata(new Map);\n                    }\n\n                    collected[i] = new ggr.GroupedGRanges(current, options);\n\n                } else if (current === null){\n                    collected[i] = ggr.GroupedGRanges.empty(objects[i].numberOfRows());\n                }\n            }\n        }\n\n        output._rowRanges = generics.COMBINE(collected);\n\n        return;\n    }\n\n    _bioconductor_COMBINE_COLUMNS(output, objects) {\n        super._bioconductor_COMBINE_COLUMNS(output, objects);\n\n        output._rowRanges = objects[0]._rowRanges;\n\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n\n        output._rowRanges = cutils.cloneField(this._rowRanges, deepCopy);\n\n        return;\n    }\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as rse from \"./RangedSummarizedExperiment.js\";\nimport * as se from \"./SummarizedExperiment.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as il from \"./InternalList.js\";\n\n/**\n * A SingleCellExperiment is a {@linkplain RangedSummarizedExperiment} subclass that contains additional fields for storing reduced dimensions and alternative experiments.\n * It supports the same set of generics as the {@linkplain SummarizedExperiment}.\n *\n * Each reduced dimension instance should have number of rows equal to the number of columns of the SingleCellExperiment.\n * Each instance is expected to provide methods for the following generics:\n *\n * - {@linkcode NUMBER_OF_ROWS}\n * - {@linkcode SLICE_2D}\n * - {@linkcode COMBINE_ROWS}\n * - {@linkcode CLONE}\n *\n * Each alternative experiment should be a {@linkplain SummarizedExperiment} with number of columns equal to that of the SingleCellExperiment.\n *\n * @extends RangedSummarizedExperiment\n */\nexport class SingleCellExperiment extends rse.RangedSummarizedExperiment {\n    /**\n     * @param {Object} assays - Object where keys are the assay names and values are multi-dimensional arrays of experimental data.\n     * @param {Object} [options={}] - Optional parameters, including those used in the {@linkplain RangedSummarizedExperiment} constructor.\n     * @param {?(GRanges|GroupedGRanges)} [options.rowRanges=null] - Genomic ranges corresponding to each row, see the {@linkplain RangedSummarizedExperiment} constructor.\n     * @param {Object|Map} [options.reducedDimensions={}] - Object containing named reduced dimensions.\n     * Each value should be a 2-dimensional object with number of rows equal to the number of columns of the assays.\n     * @param {?Array} [options.reducedDimensionOrder=null] - Array containing the order of the reduced dimensions.\n     * This should have the same values as the keys of `reducedDimensions`, and defaults to those keys if `null`.\n     * @param {Object|Map} [options.alternativeExperiments={}] - Object containing named alternative experiments.\n     * Each value should be a 2-dimensional object with number of columns equal to that of the assays.\n     * @param {?Array} [options.alternativeExperimentOrder=null] - Array containing the order of the alternative experiments.\n     * This should have the same values as the keys of `alternativeExperiments`, and defaults to those keys if `null`.\n     */\n    constructor(assays, options={}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        let { reducedDimensions = {}, reducedDimensionOrder = null, alternativeExperiments = {}, alternativeExperimentOrder = null, rowRanges = null } = options;\n        super(assays, rowRanges, options);\n        let ncols = this.numberOfColumns();\n\n        try {\n            this._reducedDimensions = new il.InternalList(reducedDimensions, reducedDimensionOrder);\n        } catch (e) {\n            throw new Error(\"failed to initialize reduced dimension list for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        for (const k of this._reducedDimensions.names()) {\n            let v = this._reducedDimensions.entry(k);\n            if (generics.NUMBER_OF_ROWS(v) !== ncols) {\n                throw new Error(\"number of rows for reduced dimension '\" + k + \"' is not equal to number of columns for this \" + this.constructor.className);\n            }\n        }\n\n        try {\n            this._alternativeExperiments = new il.InternalList(alternativeExperiments, alternativeExperimentOrder);\n        } catch (e) {\n            throw new Error(\"failed to initialize alternative experiment list for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        for (const k of this._alternativeExperiments.names()) {\n            let v = this._alternativeExperiments.entry(k);\n            if (!(v instanceof se.SummarizedExperiment)) {\n                throw new Error(\"alternative experiment '\" + k + \"' is not a SummarizedExperiment\");\n            }\n            if (v.numberOfColumns(v) !== ncols) {\n                throw new Error(\"number of columns for alternative experiment '\" + k + \"' is not equal to number of columns for this \" + this.constructor.className);\n            }\n        }\n\n        return;\n    }\n\n    static className = \"SingleCellExperiment\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {Array} Array of strings containing the (ordered) names of the reduced dimensions.\n     */\n    reducedDimensionNames() {\n        return this._reducedDimensions.names();\n    }\n\n    /**\n     * @param {string|number} i - Reduced dimension to retrieve, either by name or index.\n     * @return {*} The contents of reduced dimension `i` as an multi-dimensional array-like object.\n     */\n    reducedDimension(i) {\n        let output;\n        try {\n            output = this._reducedDimensions.entry(i);\n        } catch (e) {\n            throw new Error(\"failed to retrieve the specified reduced dimension from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return output;\n    }\n\n    /**\n     * @return {Array} Array of strings containing the (ordered) names of the alternative experiments.\n     */\n    alternativeExperimentNames() {\n        return this._alternativeExperiments.names();\n    }\n\n    /**\n     * @param {string|number} i - Alternative experiment to retrieve, either by name or index.\n     * @return {SummarizedExperiment} The specified alternative experiment `i`. \n     */\n    alternativeExperiment(i) {\n        let output;\n        try {\n            output = this._alternativeExperiments.entry(i);\n        } catch (e) {\n            throw new Error(\"failed to retrieve the specified alternative experiment from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return output;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to remove, either by name or index.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment after removing the specified assay.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    removeReducedDimension(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._reducedDimensions = target._reducedDimensions.delete(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to remove the specified reduced dimension from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to remove, either by name or index.\n     * @return {SingleCellExperiment} A reference to this SingleCellExperiment after removing the specified assay.\n     */\n    $removeReducedDimension(i) {\n        return this.removeReducedDimension(i, { inPlace: true });\n    }\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to add, either by name or index.\n     * - If `i` is a number, the reduced dimension at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of reduced dimensions.\n     * - If `i` is a string, any reduced dimension with the same name is replaced.\n     *   If no such reduced dimension exists, a new reduced dimension is appended to the list of reduced dimensions.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the reduced dimension.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with modified reduced dimensions.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setReducedDimension(i, value, { inPlace = false } = {}) {\n        if (generics.NUMBER_OF_ROWS(value) != this.numberOfColumns()) {\n            throw new Error(\"number of rows of 'value' should be the same as the number of columns of this SingleCellExperiment\");\n        }\n        let target = cutils.setterTarget(this, inPlace);\n        target._reducedDimensions = target._reducedDimensions.set(i, value, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to add, either by name or index.\n     * - If `i` is a number, the reduced dimension at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of reduced dimensions.\n     * - If `i` is a string, any reduced dimension with the same name is replaced.\n     *   If no such reduced dimension exists, a new reduced dimension is appended to the list of reduced dimensions.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the reduced dimension.\n     *\n     * @return {SingleCellExperiment} A reference to this SingleCellExperiment with modified reduced dimensions.\n     */\n    $setReducedDimension(i, value) {\n        return this.setReducedDimension(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the reduced dimension names.\n     * This should be of the same length as the number of reduced dimensions and contain unique values.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified reduced dimension names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setReducedDimensionNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._reducedDimensions = target._reducedDimensions.setNames(names, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to set the reduced dimension names for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the reduced dimension names.\n     * This should be of the same length as the number of reduced dimensions and contain unique values.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified reduced dimension names.\n     */\n    $setReducedDimensionNames(names) {\n        return this.setReducedDimensionNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the reduced dimensions to retain in the slice.\n     * This should refer to unique reduced dimension names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with sliced reduced dimensions.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceReducedDimensions(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._reducedDimensions = this._reducedDimensions.slice(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to slice the reduced dimensions for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the reduced dimensions to retain in the slice.\n     * This should refer to unique reduced dimension names.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with sliced reduced dimensions.\n     */\n    $sliceReducedDimensions(i) {\n        return this.sliceReducedDimensions(i, { inPlace: true });\n    }\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to remove, either by name or index.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment after removing the specified assay.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    removeAlternativeExperiment(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._alternativeExperiments = target._alternativeExperiments.delete(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to remove the specified alternative experiment from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to remove, either by name or index.\n     * @return {SingleCellExperiment} A reference to this SingleCellExperiment after removing the specified assay.\n     */\n    $removeAlternativeExperiment(i) {\n        return this.removeAlternativeExperiment(i, { inPlace: true });;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the alternative experiment to add, either by name or index.\n     * - If `i` is a number, the alternative experiment at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of alternative experiments.\n     * - If `i` is a string, any alternative experiment with the same name is replaced.\n     *   If no such alternative experiment exists, a new alternative experiment is appended to the list of alternative experiments.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the alternative experiment.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with modified alternative experiments.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAlternativeExperiment(i, value, { inPlace = false } = {}) {\n        if (!(value instanceof se.SummarizedExperiment) || generics.NUMBER_OF_COLUMNS(value) != this.numberOfColumns()) {\n            throw new Error(\"'value' should be a SummarizedExperiment with the same number of columns as this SingleCellExperiment\");\n        }\n        let target = cutils.setterTarget(this, inPlace);\n        target._alternativeExperiments = target._alternativeExperiments.set(i, value, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the alternative experiment to add, either by name or index.\n     * - If `i` is a number, the alternative experiment at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of alternative experiments.\n     * - If `i` is a string, any alternative experiment with the same name is replaced.\n     *   If no such alternative experiment exists, a new alternative experiment is appended to the list of alternative experiments.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the alternative experiment.\n     *\n     * @return {SingleCellExperiment} A reference to this SingleCellExperiment with modified alternative experiments.\n     */\n    $setAlternativeExperiment(i, value) {\n        return this.setAlternativeExperiment(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the alternative experiment names.\n     * This should be of the same length as the number of alternative experiments and contain unique values.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified alternative experiment names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAlternativeExperimentNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._alternativeExperiments = target._alternativeExperiments.setNames(names, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to set the alternative experiment names for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the alternative experiment names.\n     * This should be of the same length as the number of alternative experiments and contain unique values.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified alternative experiment names.\n     */\n    $setAlternativeExperimentNames(names) {\n        return this.setAlternativeExperimentNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the alternative experiments to retain in the slice.\n     * This should refer to unique alternative experiment names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with sliced alternative experiments.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceAlternativeExperiments(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._alternativeExperiments = this._alternativeExperiments.slice(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to slice the alternative experiments for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the alternative experiments to retain in the slice.\n     * This should refer to unique alternative experiment names.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with sliced alternative experiments.\n     */\n    $sliceAlternativeExperiments(i) {\n        return this.sliceAlternativeExperiments(i, { inPlace: true });\n    }\n\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_SLICE_2D(output, rows, columns, { allowView = false }) {\n        super._bioconductor_SLICE_2D(output, rows, columns, { allowView });\n\n        if (columns !== null) {\n            output._reducedDimensions = this._reducedDimensions.apply(v => generics.SLICE_2D(v, columns, null, { allowView }));\n            output._alternativeExperiments = this._alternativeExperiments.apply(v => generics.SLICE_2D(v, null, columns, { allowView }));\n        } else {\n            output._reducedDimensions = this._reducedDimensions;\n            output._alternativeExperiments = this._alternativeExperiments;\n        }\n    }\n\n    _bioconductor_COMBINE_ROWS(output, objects) {\n        super._bioconductor_COMBINE_ROWS(output, objects);\n\n        output._reducedDimensions = this._reducedDimensions;\n        output._alternativeExperiments = this._alternativeExperiments;\n\n        return;\n    }\n\n    _bioconductor_COMBINE_COLUMNS(output, objects) {\n        super._bioconductor_COMBINE_COLUMNS(output, objects);\n\n        try {\n            output._reducedDimensions = il.InternalList.parallelCombine(objects.map(x => x._reducedDimensions), generics.COMBINE_ROWS);\n        } catch (e) {\n            throw new Error(\"failed to combine reduced dimensions for \" + this.constructor.className + \" objects; \" + e.message, { cause: e });\n        }\n\n        try {\n            output._alternativeExperiments = il.InternalList.parallelCombine(objects.map(x => x._alternativeExperiments), generics.COMBINE_COLUMNS);\n        } catch (e) {\n            throw new Error(\"failed to combine alternative experiments for \" + this.constructor.className + \" objects; \" + e.message, { cause: e });\n        }\n\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n\n        output._reducedDimensions = cutils.cloneField(this._reducedDimensions, deepCopy);\n        output._alternativeExperiments = cutils.cloneField(this._alternativeExperiments, deepCopy);\n\n        return;\n    }\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as ann from \"./Annotated.js\";\nimport * as df from \"./DataFrame.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as il from \"./InternalList.js\";\n\n/**\n * A SummarizedExperiment contains zero or more assays, consisting of multi-dimensional arrays (usually matrices) of experimental data,\n * as well as {@linkplain DataFrame}s containing further annotations on the rows or columns of those arrays.\n * The SummarizedExperiment class defines methods for the following generics:\n * \n * - {@linkcode NUMBER_OF_ROWS}\n * - {@linkcode NUMBER_OF_COLUMNS}\n * - {@linkcode SLICE_2D}\n * - {@linkcode COMBINE_ROWS}\n * - {@linkcode COMBINE_COLUMNS}\n * - {@linkcode CLONE}\n *\n * Assays are expected to provide methods for the following generics:\n *\n * - {@linkcode NUMBER_OF_ROWS}\n * - {@linkcode NUMBER_OF_COLUMNS}\n * - {@linkcode SLICE_2D}\n * - {@linkcode COMBINE_ROWS}\n * - {@linkcode COMBINE_COLUMNS}\n * - {@linkcode CLONE}\n *\n * @extends Annotated\n */\nexport class SummarizedExperiment extends ann.Annotated {\n    /**\n     * @param {Object|Map} assays - Object or Map where keys are the assay names and values are multi-dimensional arrays of experimental data.\n     * All arrays should have the same number of rows and columns.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?Array} [options.assayOrder=null] - Array of strings specifying the ordering of the assays.\n     * If non-`null`, this should have the same values as the keys of `assays`.\n     * If `null`, an arbitrary ordering is obtained from `assays`.\n     * @param {?DataFrame} [options.rowData=null] - Data frame of row annotations.\n     * If non-`null`, this should have a number of rows equal to the number of rows in each entry of `assays`.\n     * If `null`, an empty {@linkplain DataFrame} is automatically created.\n     * @param {?DataFrame} [options.columnData=null] - Data frame of column annotations.\n     * If non-`null`, this should have a number of columns equal to the number of columns in each entry of `assays`.\n     * If `null`, an empty {@linkplain DataFrame} is automatically created.\n     * @param {?Array} [options.rowNames=null] - Array of strings of length equal to the number of rows in the `assays`, containing row names.\n     * Alternatively `null`, if no row names are present.\n     * @param {?Array} [options.columnNames=null] - Array of strings of length equal to the number of columns in the `assays`, containing column names.\n     * Alternatively `null`, if no column names are present.\n     * @param {Object|Map} [options.metadata={}] - Object or Map containing arbitrary metadata as key-value pairs.\n     */\n    constructor(assays, { assayOrder = null, rowData = null, columnData = null, rowNames = null, columnNames = null, metadata = {} } = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        super(metadata);\n\n        // Check the assays.\n        try {\n            this._assays = new il.InternalList(assays, assayOrder);\n        } catch (e) {\n            throw new Error(\"failed to initialize assay list for this SummarizedExperiment; \" + e.message, { cause: e });\n        }\n\n        let nrows = null;\n        let ncols = null;\n        for (const k of this._assays.names()) {\n            let current = this._assays.entry(k);\n            let nr = generics.NUMBER_OF_ROWS(current);\n            let nc = generics.NUMBER_OF_COLUMNS(current);\n            if (nrows == null) {\n                nrows = nr;\n                ncols = nc;\n            } else if (nrows !== nr || ncols !== nc) {\n                throw new Error(\"expected all assays in 'assays' to have the same number of rows and columns\");\n            }\n        }\n\n        // Check the rowData.\n        if (rowData === null) {\n            if (nrows == null){\n                throw new Error(\"'rowData' must be specified if 'assays' is empty\");\n            }\n            rowData = new df.DataFrame({}, { numberOfRows: nrows });\n        } else {\n            if (nrows !== null && nrows !== generics.LENGTH(rowData)) {\n                throw new Error(\"'rowData' should be equal to the number of rows in each 'assays'\");\n            }\n        }\n        this._rowData = rowData;\n\n        // Check the columnData.\n        if (columnData === null) {\n            if (ncols == null){\n                throw new Error(\"'columnData' must be specified if 'assays' is empty\");\n            }\n            columnData = new df.DataFrame({}, { numberOfRows: ncols });\n        } else {\n            if (ncols !== null && ncols !== generics.LENGTH(columnData)) {\n                throw new Error(\"'columnData' should be equal to the number of columns in each 'assays'\");\n            }\n        }\n        this._columnData = columnData;\n\n        // Checking the names.\n        if (rowNames != null) {\n            utils.checkNamesArray(rowNames, \"'rowNames'\", this._rowData.numberOfRows(), \"the number of rows in each 'assays'\");\n        }\n        this._rowNames = rowNames;\n\n        if (columnNames != null) {\n            utils.checkNamesArray(columnNames, \"'columnNames'\", this._columnData.numberOfRows(), \"the number of columns in each 'assays'\");\n        }\n        this._columnNames = columnNames;\n    }\n\n    static className = \"SummarizedExperiment\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {Array} Array of assay names.\n     */\n    assayNames() {\n        return this._assays.names();\n    }\n\n    /**\n     * @return {number} Number of assays.\n     */\n    numberOfAssays() {\n        return this._assays.numberOfEntries();\n    }\n\n    /**\n     * @param {string|number} i - Assay to retrieve, either by name or index.\n     * @return {*} The contents of assay `i` as an multi-dimensional array-like object.\n     */\n    assay(i) {\n        let output;\n        try {\n            output = this._assays.entry(i);\n        } catch (e) {\n            throw new Error(\"failed to retrieve the specified assay from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return output;\n    }\n\n    /**\n     * @return {DataFrame} Data frame of row data, with one row per row in this SummarizedExperiment.\n     */\n    rowData() {\n        return this._rowData;\n    }\n\n    /**\n     * @return {number} Number of rows in this SummarizedExperiment.\n     */\n    numberOfRows() {\n        return this._rowData.numberOfRows();\n    }\n\n    /**\n     * @return {?Array} Array of strings containing row names, or `null` if no row names are available.\n     */\n    rowNames() {\n        return this._rowNames;\n    }\n\n    /**\n     * @return {DataFrame} Data frame of column data, with one row per column in this SummarizedExperiment.\n     */\n    columnData() {\n        return this._columnData;\n    }\n\n    /**\n     * @return {number} Number of columns in this SummarizedExperiment.\n     */\n    numberOfColumns() {\n        return this._columnData.numberOfRows();\n    }\n\n    /**\n     * @return {?Array} Array of strings containing column names, or `null` if no column names are available.\n     */\n    columnNames() {\n        return this._columnNames;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {string|number} i - Identity of the assay to add, either by name or index.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment after removing the specified assay.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    removeAssay(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._assays = target._assays.delete(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to remove assay \" + (typeof i == \"string\" ? \"'\" + i + \"'\" : String(i)) + \" from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the assay to add, either by name or index.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment after removing the specified assay.\n     */\n    $removeAssay(i) {\n        return this.removeAssay(i, { inPlace: true });\n    }\n\n    /**\n     * @param {string|number} i - Identity of the assay to add, either by name or index.\n     * - If `i` is a number, the assay at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of assays.\n     * - If `i` is a string, any assay with the same name is replaced.\n     *   If no such assay exists, a new assay is appended to the list of assays.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the assay.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} A SummarizedExperiment with modified assays.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAssay(i, value, { inPlace = false } = {}) {\n        if (generics.NUMBER_OF_ROWS(value) !== this.numberOfRows() || generics.NUMBER_OF_COLUMNS(value) !== this.numberOfColumns()) {\n            throw new Error(\"expected 'value' to have the same dimensions as this 'SummarizedExperiment'\");\n        }\n        let target = cutils.setterTarget(this, inPlace);\n        target._assays = target._assays.set(i, value, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the assay to add, either by name or index.\n     * - If `i` is a number, the assay at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of assays.\n     * - If `i` is a string, any assay with the same name is replaced.\n     *   If no such assay exists, a new assay is appended to the list of assays.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the assay.\n     *\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified assays.\n     */\n    $setAssay(i, value) {\n        return this.setAssay(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the assay names.\n     * This should be of the same length as the number of assays and contain unique values.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified assay names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAssayNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._assays = target._assays.setNames(names, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to set the assay names for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the assay names.\n     * This should be of the same length as the number of assays and contain unique values.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified assay names.\n     */\n    $setAssayNames(names) {\n        return this.setAssayNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the assays to retain in the slice.\n     * This should refer to unique assay names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with sliced assays.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceAssays(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._assays = this._assays.slice(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to slice the assays for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the assays to retain in the slice.\n     * This should refer to unique assay names.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with sliced assays.\n     */\n    $sliceAssays(i) {\n        return this.sliceAssays(i, { inPlace: true });\n    }\n\n    /**\n     * @param {DataFrame} value - Data frame containing the row annotations.\n     * This should have one row for each row of this SummarizedExperiment.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified row data.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRowData(value, { inPlace = false } = {}) {\n        if (!(value instanceof df.DataFrame)) {\n            throw new Error(\"'value' should be a DataFrame\");\n        }\n\n        if (value.numberOfRows() !== this.numberOfRows()) {\n            throw new Error(\"expected 'value' to have the same number of rows as this 'SummarizedExperiment'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._rowData = value;\n        return target;\n    }\n\n    /**\n     * @param {DataFrame} value - Data frame containing the row annotations.\n     * This should have one row for each row of this SummarizedExperiment.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified row data.\n     */\n    $setRowData(value) {\n        return this.setRowData(value, { inPlace: true });\n    }\n\n    /**\n     * @param {DataFrame} value - Data frame containing the column annotations.\n     * This should have one row for each columns of this SummarizedExperiment.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified column data.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setColumnData(value, { inPlace = false } = {}) {\n        if (!(value instanceof df.DataFrame)) {\n            throw new Error(\"'value' should be a DataFrame\");\n        }\n\n        if (value.numberOfRows() !== this.numberOfColumns()) {\n            throw new Error(\"expected 'value' to have the same number of rows as the number of columns of this 'SummarizedExperiment'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._columnData = value;\n        return target;\n    }\n\n    /**\n     * @param {DataFrame} value - Data frame containing the column annotations.\n     * This should have one row for each columns of this SummarizedExperiment.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified column data.\n     */\n    $setColumnData(value) {\n        return this.setColumnData(value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings of length equal to the number of rows in this SummarizedExperiment, containing row names.\n     * Alternatively `null`, to remove all row names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified row names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRowNames(names, { inPlace = false } = {}) {\n        if (names !== null) {\n            utils.checkNamesArray(names, \"replacement 'names'\", this.numberOfRows(), \"'numberOfRows()'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._rowNames = names;\n        return target;\n    }\n\n    /**\n     * @param {Array} names - Array of strings of length equal to the number of rows in this SummarizedExperiment, containing row names.\n     * Alternatively `null`, to remove all row names.\n     *\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified row names.\n     */\n    $setRowNames(names) {\n        return this.setRowNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings of length equal to the number of columns in this SummarizedExperiment, containing column names.\n     * Alternatively `null`, to remove all column names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified column names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setColumnNames(names, { inPlace = false } = {}) {\n        if (names !== null) {\n            utils.checkNamesArray(names, \"replacement 'names'\", this.numberOfColumns(), \"'numberOfColumns()'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._columnNames = names;\n        return target;\n    }\n\n    /**\n     * @param {Array} names - Array of strings of length equal to the number of columns in this SummarizedExperiment, containing column names.\n     * Alternatively `null`, to remove all column names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified column names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    $setColumnNames(names) {\n        return this.setColumnNames(names, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_NUMBER_OF_ROWS() {\n        return this.numberOfRows();\n    }\n\n    _bioconductor_NUMBER_OF_COLUMNS() {\n        return this.numberOfColumns();\n    }\n\n    _bioconductor_SLICE_2D(output, rows, columns, { allowView = false }) {\n        output._assays = this._assays.apply(v => generics.SLICE_2D(v, rows, columns, { allowView }));\n\n        if (rows !== null) {\n            output._rowData = generics.SLICE(this._rowData, rows, { allowView });\n            output._rowNames = (this._rowNames == null ? null : generics.SLICE(this._rowNames, rows, { allowView }));\n        } else {\n            output._rowData = this._rowData;\n            output._rowNames = this._rowNames;\n        }\n\n        if (columns !== null) {\n            output._columnData = generics.SLICE(this._columnData, columns, { allowView });\n            output._columnNames = (this._columnNames == null ? null : generics.SLICE(this._columnNames, columns, { allowView }));\n        } else {\n            output._columnData = this._columnData;\n            output._columnNames = this._columnNames;\n        }\n\n        output._metadata = this._metadata;\n        return;\n    }\n\n    _bioconductor_COMBINE_ROWS(output, objects) {\n        output._assays = il.InternalList.parallelCombine(objects.map(x => x._assays), generics.COMBINE_ROWS);\n\n        let all_dfs = objects.map(x => x._rowData);\n        output._rowData = generics.COMBINE(all_dfs);\n\n        let all_n = objects.map(x => x._rowNames);\n        let all_l = objects.map(x => x.numberOfRows());\n        output._rowNames = utils.combineNames(all_n, all_l);\n\n        output._columnData = this._columnData;\n        output._columnNames = this._columnNames;\n        output._metadata = this._metadata;\n    }\n\n    _bioconductor_COMBINE_COLUMNS(output, objects) {\n        output._assays = il.InternalList.parallelCombine(objects.map(x => x._assays), generics.COMBINE_COLUMNS);\n\n        let all_dfs = objects.map(x => x._columnData);\n        output._columnData = generics.COMBINE(all_dfs);\n\n        let all_n = objects.map(x => x._columnNames);\n        let all_l = objects.map(x => x.numberOfColumns());\n        output._columnNames = utils.combineNames(all_n, all_l);\n\n        output._rowData = this._rowData;\n        output._rowNames = this._rowNames;\n        output._metadata = this._metadata;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n\n        output._assays = cutils.cloneField(this._assays, deepCopy);\n        output._rowData = cutils.cloneField(this._rowData, deepCopy);\n        output._rowNames = cutils.cloneField(this._rowNames, deepCopy);\n\n        output._columnData = cutils.cloneField(this._columnData, deepCopy);\n        output._columnNames = cutils.cloneField(this._columnNames, deepCopy);\n        return;\n    }\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as df from \"./DataFrame.js\";\nimport * as ann from \"./Annotated.js\";\n\nfunction verifyElementMetadata(elementMetadata, numExpected, className) {\n    if (elementMetadata !== null) {\n        if (!(elementMetadata instanceof df.DataFrame)) {\n            throw new Error(\"'elementMetadata' should be a DataFrame\");\n        }\n        if (generics.LENGTH(elementMetadata) !== numExpected) {\n            throw new Error(\"'elementMetadata' should have the same number of rows as 'LENGTH(<\" + className + \">)'\");\n        }\n    } else {\n        elementMetadata = new df.DataFrame({}, { numberOfRows: numExpected });\n    }\n    return elementMetadata;\n}\n\n/**\n * The Vector class implements a store for arbitrary per-element metadata and per-element names.\n * It is intended as a base class for other structures that have a concept of \"vector-ness\".\n * It should not be constructed directly.\n *\n * @augments Annotated\n */\nexport class Vector extends ann.Annotated {\n    /**\n     * @param {number} length - Number of elements in this vector-like object.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?DataFrame} [options.elementMetadata=null] - A {@linkplain DataFrame} with number of rows equal to the length of `start`, containing arbitrary per-element annotations.\n     * Alternatively `null`, in which case a zero-column DataFrame is automatically constructed.\n     * @param {Object} [options.metadata={}] - Object containing arbitrary metadata as key-value pairs.\n     */\n    constructor(length, { names = null, elementMetadata = null, metadata = {} } = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        super(metadata);\n\n        this._elementMetadata = verifyElementMetadata(elementMetadata, length, this.constructor.className);\n\n        if (names !== null) {\n            utils.checkNamesArray(names, \"'names'\", length, \"'LENGTH(<\" + this.constructor.className + \">)'\");\n        }\n        this._names = names;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {DataFrame} A {@linkplain DataFrame} with one row corresponding to each vector element, containing arbitrary per-element metadata.\n     */\n    elementMetadata() {\n        return this._elementMetadata;\n    }\n\n    /**\n     * @return {?Array} Array of strings containing the name of each range, or `null` if no names are available.\n     */\n    names() {\n        return this._names;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {?DataFrame} elementMetadata - Arbitrary metadata for each vector element.\n     * This should have number of rows equal to the vector length.\n     * Alternatively `null`, in which case all existing per-element metadata is removed.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this Vector instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {Vector} The Vector object after setting the element metadata to `value`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setElementMetadata(elementMetadata, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        target._elementMetadata = verifyElementMetadata(elementMetadata, generics.LENGTH(target), target.constructor.className);\n        return target;\n    }\n\n    /**\n     * @param {?DataFrame} elementMetadata - Arbitrary metadata for each vector element.\n     * This should have number of rows equal to the vector length.\n     * Alternatively `null`, in which case all existing per-element metadata is removed.\n     *\n     * @return {Vector} A reference to this Vector object after setting the element metadata to `value`.\n     */\n    $setElementMetadata(elementMetadata) {\n        return this.setElementMetadata(elementMetadata, { inPlace: true });\n    }\n\n    /**\n     * @param {?Array} names - Array of strings containing a name for each range.\n     * This should have length equal to the number of ranges.\n     * Alternatively `null`, if no names are present.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this Vector instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {Vector} The Vector object after setting the names to `value`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setNames(names, { inPlace = false } = {}) {\n        if (names !== null) {\n            utils.checkNamesArray(names, \"replacement 'names'\", generics.LENGTH(this), \"'LENGTH(<\" + this.constructor.className + \">)'\");\n        } \n        let target = cutils.setterTarget(this, inPlace);\n        target._names = names;\n        return target;\n    }\n\n    /**\n     * @param {?Array} names - Array of strings containing a name for each range.\n     * This should have length equal to the number of ranges.\n     * Alternatively `null`, if no names are present.\n     *\n     * @return {Vector} A reference to this Vector object after setting the element metadata to `value`.\n     */\n    $setNames(names) {\n        return this.setNames(names, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_SLICE(output, i, { allowView = false }) {\n        output._elementMetadata = generics.SLICE(this._elementMetadata, i, { allowView });\n        output._names = (this._names === null ? null : generics.SLICE(this._names, i, { allowView }));\n        output._metadata = this._metadata;\n        return;\n    }\n\n    _bioconductor_COMBINE(output, objects) {\n        let all_em = [];\n        let all_n = [];\n        let all_l = [];\n\n        for (const x of objects) {\n            all_em.push(x._elementMetadata);\n            all_n.push(x._names);\n            all_l.push(generics.LENGTH(x));\n        }\n\n        output._elementMetadata = generics.COMBINE(all_em);\n        output._names = utils.combineNames(all_n, all_l);\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n        output._elementMetadata = cutils.cloneField(this._elementMetadata, deepCopy);\n        output._names = cutils.cloneField(this._names, deepCopy);\n        return;\n    }\n}\n","import * as generics from \"./AllGenerics.js\";\n\nexport function setterTarget(object, inPlace) {\n    return (inPlace ? object : generics.CLONE(object, { deepCopy: false }));\n}\n\nexport function cloneField(value, deepCopy) {\n    return (deepCopy ? generics.CLONE(value) : value);\n}\n","/**\n * @param {Array|TypedArray} x - Array of values to be interpreted as truthy or falsey.\n * @param {Object} [options={}] - Optional parameters.\n * @param {boolean} [options.not=false] - Whether to select the entries of `x` that are falsey.\n *\n * @return {Array} Array of indices of the entries of `x` that are truthy (if `not=false`) or falsey (if `not=true`).\n * This array is guaranteed to be sorted in ascending order.\n */\nexport function which(x, { not = false } = {}) {\n    let output = [];\n    x.forEach((y, i) => {\n        if ((!y) == not) {\n            output.push(i);\n        }\n    });\n    return output;\n}\n\n/**\n * Given a factor, return the indices corresponding to each level.\n * This can be used in subsequent {@linkcode splitRows} calls.\n *\n * @param {Array|TypedArray} factor - Array containing the factor of interest.\n *\n * @return {Object} Object where each key is a factor level and each value is an array containing the indices corresponding to that level in `factor`.\n */\nexport function presplitFactor(factor) {\n    let by = {};\n    factor.forEach((x, i) => {\n        if (!(x in by)) {\n            by[x] = [];\n        }\n        by[x].push(i);\n    });\n    return by;\n}\n","import * as utils from \"./utils.js\";\n\nexport function convertPositionToRank(start, end, { slice = null } = {}) {\n    let n = (slice == null ? start.length : slice.length);\n\n    let positions = new Int32Array(n * 2);\n    let add = new Uint8Array(n * 2);\n    let index = new Int32Array(n * 2);\n\n    {\n        let counter = 0;\n        let fillIndex = i => {\n            let at = counter * 2;\n            let next = at + 1;\n            positions[at] = start[i];\n            positions[next] = end[i];\n            add[at] = 1;\n            add[next] = 0;\n            index[at] = counter;\n            index[next] = counter;\n            counter++;\n        };\n\n        if (slice === null) {\n            for (var i = 0; i < n; i++) {\n                fillIndex(i);                                \n            }\n        } else {\n            for (const i of slice) {\n                fillIndex(i);\n            }\n        }\n    }\n\n    let order = utils.createSequence(positions.length);\n    order.sort((i, j) => positions[i] - positions[j]);\n\n    let rank2position = [];\n    let new_starts = new Int32Array(n);\n    let new_ends = new Int32Array(n);\n\n    let last = null;\n    for (const i of order) {\n        let pos = positions[i];\n        let idx = index[i];\n\n        if (pos !== last) {\n            rank2position.push(pos);\n            last = pos;\n        }\n\n        if (add[i]) {\n            new_starts[idx] = rank2position.length - 1;\n        } else {\n            new_ends[idx] = rank2position.length - 1;\n        }\n    }\n\n    return { rank2position, startRanks: new_starts, endRanks: new_ends };\n}\n\nexport function buildIntervalTree(start, end, { slice = null } = {}) {\n    let { rank2position, startRanks, endRanks } = convertPositionToRank(start, end, { slice });\n\n    // Now, building an nicely balanced interval tree based on the ranks.\n    let tree = [ create_node(0, rank2position.length) ];\n    if (slice === null) {\n        for (var i = 0; i < startRanks.length; i++) {\n            recursive_build_tree(startRanks[i], endRanks[i], i, tree, 0);\n        }\n    } else {\n        for (var i = 0; i < startRanks.length; i++) {\n            recursive_build_tree(startRanks[i], endRanks[i], slice[i], tree, 0);\n        }\n    }\n\n    // Running a clean-up operation to convert ranks back to positions.\n    let one_past_the_end = (rank2position.length > 0 ? rank2position[rank2position.length - 1] + 1 : 1);\n    rank2position.push(one_past_the_end);\n\n    for (const x of tree) {\n        x.left_bound = rank2position[x.left_bound];\n        x.right_bound = rank2position[x.right_bound];\n        x.center = rank2position[x.center];\n\n        // Also sorting ranges by increasing start and DECREASING end positions.\n        let start_overlaps_sorted = x.overlaps.slice().sort((a, b) => start[a] - start[b]);\n        let end_overlaps_sorted = x.overlaps.sort((a, b) => end[b] - end[a]) // reversed order - deliberate!\n        x.overlaps = {\n            start: start_overlaps_sorted.map(i => [start[i], i]),\n            end: end_overlaps_sorted.map(i => [end[i], i])\n        };\n    }\n\n    return tree;\n}\n\nfunction create_node(left_bound, right_bound) {\n    return { \n        left_bound: left_bound,\n        right_bound: right_bound,\n        center: left_bound + Math.floor((right_bound - left_bound) / 2),\n        left_node: null,\n        right_node: null,\n        overlaps: []\n    };\n}\n\nfunction recursive_build_tree(start, end, index, tree, node) {\n    let current = tree[node];\n\n    if (start > current.center) {\n        if (current.right_node === null) {\n            current.right_node = tree.length;\n            tree.push(create_node(current.center, current.right_bound));\n        }\n        recursive_build_tree(start, end, index, tree, current.right_node);\n\n    } else if (end < current.center || (end == current.center && end > start)) { // Let 0-length ranges fall through to the next clause if they lie exactly on the center.\n        if (current.left_node === null) {\n            current.left_node = tree.length;\n            tree.push(create_node(current.left_bound, current.center));\n        }\n        recursive_build_tree(start, end, index, tree, current.left_node);\n\n    } else {\n        // At some point, every range ends up here. This is because left_bound\n        // == center upon successive halving to create new nodes, so every\n        // range will eventually overlap a center at its own start position.\n        current.overlaps.push(index);\n    }\n}\n\nexport function queryIntervalTree(start, end, tree) {\n    let results = [];\n    if (start > tree.right_bound) {\n        return results;\n    }\n\n    if (end < tree.left_bound || (end == tree.left_bound && end > start)) { // Still allow 0-length ranges to fall through for search.\n        return results;\n    }\n\n    recursive_query_tree(start, end, tree, 0, results); \n    return results;\n}\n\nfunction recursive_query_tree(start, end, tree, node, results) {\n    let current = tree[node];\n\n    if (start > current.center) {\n        for (const overlap of current.overlaps.end) {\n            if (overlap[0] > start) {\n                results.push(overlap[1]);\n            } else {\n                break;\n            }\n        }\n        if (current.right_node !== null) {\n            recursive_query_tree(start, end, tree, current.right_node, results);\n        }\n\n    } else if (end < current.center || (end == current.center && end > start)) { // Again, let zero-length ranges fall through if they lie directly on the center.\n        for (const overlap of current.overlaps.start) {\n            if (overlap[0] < end || (overlap[0] == end && start == end)) { // handle zero-length ranges directly on the start position of the center-overlapping range.\n                results.push(overlap[1]);\n            } else {\n                break;\n            }\n        }\n        if (current.left_node !== null) {\n            recursive_query_tree(start, end, tree, current.left_node, results);\n        }\n\n    } else {\n        for (const overlap of current.overlaps.start) {\n            results.push(overlap[1]);\n        }\n\n        if (end > current.center) {\n            if (current.right_node !== null) {\n                recursive_query_tree(start, end, tree, current.right_node, results);\n            }\n        }\n        if (start < current.center) {\n            if (current.left_node !== null) {\n                recursive_query_tree(start, end, tree, current.left_node, results);\n            }\n        }\n    }\n}\n","export function areArraysEqual(x, y) {\n    if (x.length !== y.length) {\n        return false;\n    }\n\n    for (var i = 0; i < x.length; i++) {\n        if (x[i] != y[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function isArrayLike(x) {\n    return x.constructor == Array || ArrayBuffer.isView(x);\n}\n\nexport function chooseArrayConstructors(con1, con2) {\n    if (con1 == con2) {\n        return con1;\n    }\n\n    if (con1 == Array || con2 == Array) {\n        return Array;\n    }\n\n    if (con1 == BigInt64Array || con2 == BigInt64Array || con1 == BigUint64Array || con2 == BigUint64Array) {\n        return Array;\n    }\n\n    return Float64Array;\n}\n\nexport function formatLengthError(left, right) {\n    return new Error(left + \" should have length equal to \" + right);\n}\n\nexport function checkStringArray(names, typeMessage) {\n    for (const x of names) {\n        if (typeof x !== \"string\") {\n            throw new Error(typeMessage + \" array should only contain strings\");\n        }\n    }\n}\n\nexport function checkNamesArray(names, typeMessage, numExpected, lengthMessage) {\n    checkStringArray(names, typeMessage);\n    if (names.length != numExpected) {\n        throw formatLengthError(typeMessage + \" array\", lengthMessage);\n    }\n}\n\nexport function sum(y) {\n    let total = 0;\n    y.forEach(x => { total += x; });\n    return total;\n}\n\nexport function combineNames(all_names, all_lengths, total_n = null) {\n    let all_null = true;\n    for (var i = 0; i < all_names.length; i++) {\n        if (all_names[i] !== null) {\n            all_null = false;\n        }\n    }\n\n    if (all_null) {\n        return null;\n    }\n\n    if (total_n === null) {\n        total_n = sum(all_lengths);\n    }\n\n    let output = new Array(total_n);\n    let counter = 0;\n    for (var i = 0; i < all_names.length; i++) {\n        let n = all_names[i];\n        if (n === null) {\n            output.fill(\"\", counter, counter + all_lengths[i]);\n            counter += all_lengths[i];\n        } else {\n            n.forEach(x => {\n                output[counter] = x;\n                counter++;\n            });\n        }\n    }\n\n    return output;\n}\n\nexport function createSequence(n) {\n    let output = new Int32Array(n);\n    for (var i = 0; i < n; i++) {\n        output[i] = i;\n    }\n    return output;\n}\n\nexport function isSorted(n, cmp) {\n    for (var i = 1; i < n; ++i) {\n        if (cmp(i-1, i) > 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function convertToInt32Array(x) {\n    if (x instanceof Int32Array) {\n        return x;\n    } else {\n        return new Int32Array(x);\n    }\n}\n\nexport function checkNonNegative(x, msg) {\n    for (const y of x) {\n        if (y < 0) {\n            throw new Error(\"detected a negative entry in '\" + msg + \"'\");\n        }\n    }\n}\n\nexport function object2map(x) {\n    if (x.constructor == Object) {\n        let replacement = new Map;\n        for (const [k, v] of Object.entries(x)) {\n            replacement.set(k, v);\n        }\n        return replacement;\n    } \n\n    if (!(x instanceof Map)) {\n        throw new Error(\"'x' should be either an object or Map\");\n    }\n    return x;\n}\n","import { reference_download, decompressLines } from \"./utils.js\";\n\nvar _collections = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.download=true] - Whether to download the collection details if they are not already available.\n * If `false`, `null` is returned if the collection details have not already been loaded into memory.\n *\n * @return {?Array} Array of objects where each entry corresponds to a set collection and contains details about that collection.\n * Each object can be expected to contain:\n * \n * - `title`, the title for the collection.\n * - `description`, the description for the collection.\n * - `species`, the species for all gene identifiers in the collection.\n *   This should contain the full scientific name, e.g., `\"Homo sapiens\"`, `\"Mus musculus\"`.\n * - `maintainer`, the maintainer of this collection.\n * - `source`, the source of this set, usually a link to some external resource.\n * - `start`, the index for the first set in the collection in the output of {@linkcode sets}.\n *   All sets from the same collection are stored contiguously.\n * - `size`, the number of sets in the collection.\n *\n * In a **gesel** context, the identifier for a collection (i.e., the \"collection ID\") is defined as the index of the collection in this array.\n *\n * If the collection details have not already been loaded and `download = false`, `null` is returned.\n * @async\n */\nexport async function fetchAllCollections(species, { download = true } = {}) {\n    let target = _collections.get(species);\n    if (typeof target !== \"undefined\") {\n        return target;\n    } else if (!download) {\n        return null;\n    }\n\n    target = [];\n    _collections.set(species, target);\n\n    var cres = await reference_download(species + \"_collections.tsv.gz\");\n    if (!cres.ok) {\n        throw new Error(\"failed to fetch collection information for species '\" + species + \"'\");\n    }\n    var coll_data = decompressLines(await cres.arrayBuffer());\n\n    var start = 0;\n    for (var i = 0; i < coll_data.length; i++) {\n        let x = coll_data[i];\n        var details = x.split(\"\\t\");\n        var len = Number(details[5]);\n        target.push({\n            \"title\": details[0],\n            \"description\": details[1],\n            \"species\": details[2],\n            \"maintainer\": details[3],\n            \"source\": details[4],\n            \"start\": start,\n            \"size\": len\n        });\n        start += len;\n    }\n\n    return target;\n}\n","import { gene_download, decompressLines } from \"./utils.js\";\n\nvar _genes = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {object} [options={}] - Optional parameters.\n * @param {?Array} [options.types=null] - Array of strings specifying the identifier types to be retrieved.\n * The exact choice of strings depends on how the references were constructed.\n * If `null`, it defaults to an array containing `\"symbol\"`, `\"entrez\"` and `\"ensembl\"`.\n *\n * @return {Map} Object where each key is named after an identifier type in `types`.\n * Each value is an array where each element corresponds to a gene and is itself an array of strings containing all identifiers of the current type for that gene.\n *\n * The arrays for different identifier types are all of the same length, and corresponding elements across these arrays describe the same gene.\n * **gesel**'s identifier for each gene (i.e., the \"gene ID\") is defined as the index of that gene in any of these arrays.\n *\n * @async\n */\nexport async function fetchAllGenes(species, { types = null } = {}) {\n    if (types == null) {\n        types = [ \"symbol\", \"entrez\", \"ensembl\" ];\n    }\n\n    let target = _genes.get(species);\n    if (typeof target == \"undefined\") {\n        target = new Map;\n        _genes.set(species, target);\n    }\n\n    let output = new Map;\n    let promises = [];\n    let processing = [];\n\n    for (const t of types) {\n        let found = target.get(t);\n        if (typeof found == \"undefined\") {\n            promises.push(gene_download(species + \"_\" + t + \".tsv.gz\"));\n            processing.push(t);\n        } else {\n            output.set(t, found);\n        }\n    }\n\n    if (promises.length > 0) {\n        let resolved = await Promise.all(promises);\n        for (var i = 0; i < resolved.length; i++) {\n            let res = resolved[i];\n            if (!res.ok) {\n                throw \"failed to fetch symbol information for genes\";\n            }\n            var buffer = await res.arrayBuffer();\n\n            let gene_data = decompressLines(buffer);\n            let processed = [];\n            for (const x of gene_data) {\n                if (x == \"\") {\n                    processed.push([]);\n                } else {\n                    processed.push(x.split(\"\\t\"));\n                }\n            }\n\n            let t = processing[i];\n            target.set(t, processed);\n            output.set(t, processed);\n        }\n    }\n\n    return output;\n}\n","import { reference_download, decompressLines } from \"./utils.js\";\nimport { fetchAllCollections } from \"./fetchAllCollections.js\";\n\nvar _sets = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.download=true] - Whether to download the set details if they are not already available.\n * If `false`, `null` is returned if the set details have not already been loaded into memory.\n *\n * @return {Array} Array of objects where each entry corresponds to a set and contains the details about that set.\n * Each object can be expected to contain:\n * \n * - `name`, the name of the set.\n * - `description`, the description of the set.\n * - `size`, the number of genes in the set.\n * - `collection`, the index of the collection containing the set.\n * - `number`, the number of the set within the collection.\n *\n * In a **gesel** context, the identifier for a set (i.e., the \"set ID\") is defined as the index of the set in this array.\n *\n * If the set details have not already been loaded and `download = false`, `null` is returned.\n * @async\n */\nexport async function fetchAllSets(species, { download = true } = {}) {\n    let found = _sets.get(species);\n    if (typeof found !== \"undefined\") {\n        return found;\n    } else if (!download) {\n        return null;\n    }\n\n    found = [];\n    _sets.set(species, found);\n\n    var [ sres, _collections ] = await Promise.all([reference_download(species + \"_sets.tsv.gz\"), fetchAllCollections(species)]);\n    if (!sres.ok) {\n        throw new Error(\"failed to fetch set information for species '\" + species + \"'\");\n    }\n    var set_data = decompressLines(await sres.arrayBuffer());\n\n    for (var i = 0; i < set_data.length; i++) {\n        let x = set_data[i];\n        var details = x.split(\"\\t\");\n        found.push({\n            \"name\": details[0],\n            \"description\": details[1],\n            \"size\": Number(details[2])\n        });\n    }\n\n    let start = 0;\n    for (var i = 0; i < _collections.length; i++) {\n        let len = _collections[i].size;\n\n        // For easier access going the other way.\n        for (var j = 0; j < len; j++) {\n            found[j + start].collection = i;\n            found[j + start].number = j;\n        }\n\n        start += len;\n    }\n\n    return found;\n}\n","import * as utils from \"./utils.js\";\n\nconst _cache = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.download=true] - Whether to download the set-to-gene mappings if they are not already available.\n * If `false`, `null` is returned if the set-to-gene mappings have not already been loaded into memory.\n *\n * @return {?Array} Array of length equal to the total number of sets for this `species`.\n * Each element corresponds to an entry in {@linkcode fetchAllSets} and is an array of integers containing the IDs for all genes belonging to that set.\n * Gene IDs refer to indices in {@linkcode fetchAllGenes}.\n *\n * If the set-to-gene mappings have not already been loaded and `download = false`, `null` is returned.\n * @async\n */\nexport async function fetchGenesForAllSets(species, { download = true } = {}) {\n    let found = _cache.get(species);\n    if (typeof found !== \"undefined\") {\n        return found;\n    } else if (!download) {\n        return null;\n    }\n\n    let res = await utils.reference_download(species + \"_set2gene.tsv.gz\");\n    if (!res.ok) {\n        throw new Error(\"failed to fetch full set-to-gene information for species '\" + species + \"'\");\n    }\n\n    var set_data = utils.decompressLines(await res.arrayBuffer());\n    let loaded = set_data.map(utils.convertToUint32Array);\n    _cache.set(species, loaded);\n    return loaded;\n}\n","import * as utils from \"./utils.js\";\nimport * as full from \"./fetchGenesForAllSets.js\";\n\nconst _ranges = new Map;\nconst _cache = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {?number} set - Set ID, see {@linkcode fetchAllSets} for details.\n *\n * If `null`, no request is performed, but various internal caches are initialized for subsequent calls to this function.\n * This is useful for guaranteeing that caches are available in concurrent calls.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceRequest=false] - Whether to force a range request to the server.\n * By default, the return value is extracted from the full set-to-gene mappings if {@linkcode fetchGenesForAllSets} was called before this function.\n * Setting this to `true` is only useful for testing.\n * @param {boolean} [options.forceDownload=false] - Whether to forcibly download all set-to-gene information up-front to avoid range requests.\n * This is done by calling {@linkcode fetchGenesForAllSets}.\n * Ignored if `forceRequest = true`.\n *\n * @return {Uint32Array} Array of integers containing the IDs for all genes belonging to the set.\n * Gene IDs refer to indices in {@linkcode fetchAllGenes}.\n *\n * If `set = null`, no return value is provided.\n * @async\n */\nexport async function fetchGenesForSet(species, set, { forceRequest = false, forceDownload = false } = {}) {\n    if (!forceRequest) {\n        let ffound = await full.fetchGenesForAllSets(species, { download: forceDownload });\n        if (ffound !== null) {\n            if (set !== null) {\n                return ffound[set];\n            } else {\n                return;\n            }\n        }\n    }\n\n    let spfound = _cache.get(species);\n    if (typeof spfound == \"undefined\") {\n        spfound = new Map;\n        _cache.set(species, spfound);\n        _ranges.set(species, await utils.retrieveRanges(species + \"_set2gene.tsv\"));\n    }\n\n    if (set == null) {\n        return;\n    }\n\n    let sefound = spfound.get(set);\n    if (typeof sefound !== \"undefined\") {\n        return sefound;\n    }\n\n    let ranges = _ranges.get(species);\n    let text = await utils.retrieveBytesByIndex(species + \"_set2gene.tsv\", ranges, set);\n    let output = utils.convertToUint32Array(text);\n    spfound.set(set, output);\n    return output;\n}\n","import * as utils from \"./utils.js\";\n\nconst _cache = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.download=true] - Whether to download the gene-to-set mappings if they are not already available.\n * If `false`, `null` is returned if the gene-to-set mappings have not already been loaded into memory.\n *\n * @return {?Array} Array of length equal to the total number of genes for this `species`.\n * Each element corresponds to an entry in {@linkcode fetchAllGenes} and is an array of integers containing the IDs for all sets containing that gene.\n * Set IDs refer to indices in {@linkcode fetchAllSets}.\n *\n * If the gene-to-set mappings have not already been loaded and `download = false`, `null` is returned.\n * @async\n */\nexport async function fetchSetsForAllGenes(species, { download = true } = {}) {\n    let found = _cache.get(species);\n    if (typeof found !== \"undefined\") {\n        return found;\n    } else if (!download) {\n        return null;\n    }\n\n    let res = await utils.reference_download(species + \"_gene2set.tsv.gz\");\n    if (!res.ok) {\n        throw new Error(\"failed to fetch full gene-to-set information for species '\" + species + \"'\");\n    }\n\n    var gene_data = utils.decompressLines(await res.arrayBuffer());\n    let loaded = gene_data.map(utils.convertToUint32Array);\n    _cache.set(species, loaded);\n    return loaded;\n}\n","import * as utils from \"./utils.js\";\nimport * as full from \"./fetchSetsForAllGenes.js\";\n\nconst _ranges = new Map;\nconst _cache = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n *\n * @return {number} Number of genes that belong to at least one set for `species`.\n * This can be used as a more appropriate universe size in {@linkcode testEnrichment}.\n */\nexport async function effectiveNumberOfGenes(species) {\n    let ffound = await full.fetchSetsForAllGenes(species, { download: false });\n    if (ffound !== null) {\n        let okay = 0;\n        for (const x of ffound) {\n            okay += x.length > 0;\n        }\n        return okay;\n    }\n\n    let ranged = _ranges.get(species);\n    if (typeof ranged === \"undefined\") {\n        _cache.set(species, new Map);\n        ranged = await utils.retrieveRanges(species + \"_gene2set.tsv\")\n        _ranges.set(species, ranged);\n    }\n\n    let okay = 0;\n    for (var i = 1; i < ranged.length; i++) {\n        if (ranged[i] > ranged[i-1] + 1) {\n            okay++;\n        }\n    }\n\n    return okay;\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {?number} gene - Gene ID, see {@linkcode fetchAllGenes} for details.\n *\n * If `null`, no request is performed, but various internal caches are initialized for subsequent calls to this function.\n * This is useful for guaranteeing that caches are available in concurrent calls.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceRequest=false] - Whether to force a range request to the server.\n * By default, the return value is extracted from the full gene-to-set mappings if {@linkcode fetchSetsForAllGenes} was called before this function. \n * Setting this to `true` is only useful for testing.\n * @param {boolean} [options.forceDownload=false] - Whether to forcibly download all gene-to-set mappings up-front to avoid range requests.\n * This is done by calling {@linkcode fetchSetsForAllGenes}\n * Ignored if `forceRequest = true`.\n *\n * @return {Uint32Array} Array of integers containing the IDs of all sets containing the gene.\n * IDs are treated as indices into the return value of {@linkcode fetchAllSets} or as input to {@linkcode fetchSingleSet}.\n *\n * If `gene = null`, no return value is provided.\n * \n * @async\n */\nexport async function fetchSetsForGene(species, gene, { forceRequest = false, forceDownload = false } = {}) {\n    if (!forceRequest) {\n        let ffound = await full.fetchSetsForAllGenes(species, { download: forceDownload });\n        if (ffound !== null) {\n            if (gene !== null) {\n                return ffound[gene];\n            } else {\n                return;\n            }\n        }\n    }\n\n    let spfound = _cache.get(species);\n    if (typeof spfound === \"undefined\") {\n        spfound = new Map;\n        _cache.set(species, spfound);\n        _ranges.set(species, await utils.retrieveRanges(species + \"_gene2set.tsv\"));\n    }\n    if (gene == null) {\n        return;\n    }\n\n    let gfound = spfound.get(gene);\n    if (typeof gfound !== \"undefined\") {\n        return gfound;\n    }\n\n    let text = await utils.retrieveBytesByIndex(species + \"_gene2set.tsv\", _ranges.get(species), gene);\n    let output = utils.convertToUint32Array(text);\n    spfound.set(gene, output);\n    return output;\n}\n","import * as utils from \"./utils.js\";\nimport * as full from \"./fetchAllCollections.js\";\n\nconst _cache = new Map;\nconst _ranges = new Map;\nconst _sizes = new Map;\nconst _starts = new Map;\n\nasync function initialize(species) {\n    let res = await utils.retrieveRangesWithExtras(species + \"_collections.tsv\");\n    _ranges.set(species, res.ranges);\n    _sizes.set(species, res.extra);\n\n    let first = 0;\n    let starts = [];\n    for (const s of res.extra) {\n        starts.push(first);\n        first += s;\n    }\n    _starts.set(species, starts);\n\n    _cache.set(species, new Map);\n    return;\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @return {Array} Number of sets in each collection.\n * Each value corresponds to a collection in {@linkcode fetchAllCollections}.\n * @async\n */\nexport async function fetchCollectionSizes(species) {\n    return utils.fetchSizes(species, _sizes, full.fetchAllCollections, initialize);\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @return {number} Total number of collections for this species.\n * @async\n */\nexport async function numberOfCollections(species) {\n    return utils.fetchNumber(species, _sizes, full.fetchAllCollections, initialize);\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {?number} collection - Collection ID, see {@linkcode fetchAllCollections} for details.\n * \n * If `null`, no request is performed, but various internal caches are initialized for subsequent calls to this function.\n * This is useful for guaranteeing that caches are available in concurrent calls.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceRequest=false] - Whether to force a request to the server.\n * By default, the return value is extracted from the full collection details if {@linkcode fetchAllCollections} was called before this function.\n * Setting this to `true` is only useful for testing.\n * @param {boolean} [options.forceDownload=false] - Whether to forcibly download all collection details up-front to avoid range requests.\n * This is done by calling {@linkcode fetchAllCollections}.\n * Ignored if `forceRequest = true`.\n *\n * @return {object} Object containing the details of the collection.\n * This should be identical to the corresponding entry of the array returned by {@linkcode fetchAllCollections}.\n *\n * If `collection = null`, no return value is provided.\n * @async\n */\nexport async function fetchSingleCollection(species, collection, { forceRequest = false, forceDownload = false } = {}) {\n    if (!forceRequest) {\n        let ffound = await full.fetchAllCollections(species, { download: forceDownload });\n        if (ffound !== null) {\n            if (collection !== null) {\n                return ffound[collection];\n            } else {\n                return;\n            }\n        }\n    }\n\n    let cached = _cache.get(species);\n    if (typeof cached === \"undefined\") {\n        await initialize(species);\n        cached = _cache.get(species);\n    }\n\n    if (collection == null) {\n        return;\n    }\n\n    let cfound = cached.get(collection);\n    if (typeof cfound !== \"undefined\") {\n        return cfound;\n    }\n\n    let text = await utils.retrieveBytesByIndex(species + \"_collections.tsv\", _ranges.get(species), collection);\n    let split = text.split(\"\\t\");\n    let output = {\n        title: split[0],\n        description: split[1],\n        species: split[2],\n        maintainer: split[3],\n        source: split[4],\n        start: _starts.get(species)[collection],\n        size: _sizes.get(species)[collection]\n    };\n\n    cached.set(collection, output);\n    return output;\n}\n\n\n","import * as utils from \"./utils.js\";\nimport * as full from \"./fetchAllSets.js\";\nimport { fetchCollectionSizes } from \"./fetchSingleCollection.js\";\n\nconst _cache = new Map;\nconst _ranges = new Map;\nconst _sizes = new Map;\nconst _starts = new Map;\nconst _parents = new Map;\nconst _internal_number = new Map;\n\nasync function initialize(species) {\n    const [ sres, csizes ] = await Promise.all([ \n        utils.retrieveRangesWithExtras(species + \"_sets.tsv\"), \n        fetchCollectionSizes(species) \n    ]);\n    _ranges.set(species, sres.ranges);\n    _sizes.set(species, sres.extra);\n\n    let parents = [];\n    let internal_number = [];\n    var totals = 0;\n    for (var i = 0; i < csizes.length; i++) {\n        let colsize = csizes[i];\n        for (var j = 0; j < colsize; j++) {\n            parents.push(i);\n            internal_number.push(j);\n        }\n        totals += colsize;\n    }\n\n    if (totals != sres.extra.length) {\n        throw new Error(\"discrepancy between number of sets and sum of collection sizes\");\n    }\n\n    _parents.set(species, parents);\n    _internal_number.set(species, internal_number);\n    _cache.set(species, new Map);\n    return;\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @return {Array} Number of genes in each set.\n * Each value corresponds to a set in {@linkcode fetchAllSets}.\n * @async\n */\nexport async function fetchSetSizes(species) {\n    return utils.fetchSizes(species, _sizes, full.fetchAllSets, initialize);\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @return {number} Total number of sets for this species.\n * @async\n */\nexport async function numberOfSets(species) {\n    return utils.fetchNumber(species, _sizes, full.fetchAllSets, initialize);\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {?number} set - Set ID, see {@linkcode fetchAllSets} for details.\n *\n * If `null`, no request is performed, but various internal caches are initialized for subsequent calls to this function.\n * This is useful for guaranteeing that caches are available in concurrent calls.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceRequest=false] - Whether to force a request to the server.\n * By default, the return value is extracted from the full set details if {@linkcode fetchAllSets} was called before this function.\n * Setting this to `true` is only useful for testing.\n * @param {boolean} [options.forceDownload=false] - Whether to forcibly download all set details up-front to avoid range requests.\n * This is done by calling {@linkcode fetchAllSets}.\n * Ignored if `forceRequest = true`.\n *\n * @return {object} Object containing the details of the set.\n * This should be identical to the corresponding entry of the array returned by {@linkcode fetchAllSets}.\n *\n * If `set = null`, no return value is provided.\n * @async\n */\nexport async function fetchSingleSet(species, set, { forceRequest = false, forceDownload = false } = {}) {\n    if (!forceRequest) {\n        let ffound = await full.fetchAllSets(species, { download: forceDownload });\n        if (ffound !== null) {\n            if (set !== null) {\n                return ffound[set];\n            } else {\n                console.log(set);\n                return;\n            }\n        }\n    }\n\n    let cached = _cache.get(species);\n    if (typeof cached === \"undefined\") {\n        await initialize(species);\n        cached = _cache.get(species);\n    }\n\n    if (set == null) {\n        return;\n    }\n\n    let sfound = cached.get(set);\n    if (typeof sfound !== \"undefined\") {\n        return sfound;\n    }\n\n    let text = await utils.retrieveBytesByIndex(species + \"_sets.tsv\", _ranges.get(species), set);\n    let split = text.split(\"\\t\");\n    let output = {\n        name: split[0],\n        description: split[1],\n        size: _sizes.get(species)[set],\n        collection: _parents.get(species)[set],\n        number: _internal_number.get(species)[set]\n    };\n\n    cached.set(set, output);\n    return output;\n}\n\n\n","import { fetchAllGenes } from \"./fetchAllGenes.js\";\n\nvar by_symbol = new Map;\nvar by_symbol_lower = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {string} type - Type of the identifier to use as the key of the map, e.g., `\"ensembl\"`.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.lowerCase=false] - Whether to use lower-case keys in the map.\n *\n * @return {Map} Map where each key is a string containing a (possibly lower-cased) identifier of the specified `type` and each value is an array.\n * Each array contains the **gesel** gene IDs associated with the `type` identifier, see {@linkcode fetchAllGenes} for ore details.\n *\n * @async\n */\nexport async function mapGenesByIdentifier(species, type, { lowerCase = false } = {}) {\n    let host = (lowerCase ? by_symbol_lower : by_symbol);\n\n    let sfound = host.get(species);\n    if (typeof sfound === \"undefined\") {\n        sfound = new Map;\n        host.set(species, sfound);\n    }\n\n    let tfound = sfound.get(type);\n    if (typeof tfound === \"undefined\") {\n        tfound = new Map;\n        sfound.set(type, tfound);\n\n        let _genes = (await fetchAllGenes(species, { types: [ type ] })).get(type);\n        for (var i = 0; i < _genes.length; i++) {\n            for (let y of _genes[i]) {\n                if (lowerCase) {\n                    y = y.toLowerCase();\n                }\n\n                let current = tfound.get(y);\n                if (typeof current !== \"undefined\") {\n                    current.add(i);\n                } else {\n                    tfound.set(y, new Set([i]));\n                }\n            }\n        }\n\n        for (const [key, val] of tfound) {\n            tfound.set(key, Array.from(val));\n        }\n    }\n\n    return tfound;\n}\n","/**\n * Reindex the gene sets for a user-defined gene universe.\n * This is helpful for applications that know their own gene universe and want to convert the gesel gene IDs to indices within that universe.\n *\n * @param {Array} geneMapping - Array of length equal to the number of genes in a user-defined gene universe.\n * Each entry corresponds to one gene in the user's universe and contains the corresponding gesel gene ID(s) (see {@linkcode fetchAllGenes} for details).\n * Each entry can be either a number, for a 1:1 mapping; NaN, for a gene that has no matching gesel gene ID; or an array of gesel gene IDs, like that returned by {@linkcode searchGenes}.\n * @param {Array} genesForSets - Array of length equal to the number of reference gene sets.\n * Each entry corresponds to a set and is an array containing gesel gene IDs for all genes in that set.\n * This is typically obtained from {@linkcode fetchGenesForAllSets}.\n *\n * @return {Array} Array of length equal to `genesForSets`. \n * Each entry corresponds to a reference gene set and is a Uint32Array where the elements are indices into `geneMapping`, specifying the genes in the user's universe that belong to that set.\n * If a gene in `geneMapping` maps to multiple gesel IDs, it is considered to belong to all sets containing any of its mapped gesel gene IDs.\n */\nexport function reindexGenesForAllSets(geneMapping, genesForSets) {\n    let reverse_mapping = new Map;\n    for (var i = 0; i < geneMapping.length; i++) {\n        for (const gesel_gene of geneMapping[i]) {\n            let found = reverse_mapping.get(gesel_gene);\n            if (typeof found == \"undefined\") {\n                found = new Set;\n                reverse_mapping.set(gesel_gene, found);\n            }\n            found.add(i);\n        }\n    }\n\n    // Converting everything to an array for easier iteration. \n    for (const [k, v] of reverse_mapping) {\n        reverse_mapping[k] = new Uint32Array(v);\n    }\n\n    let new_sets = new Array(genesForSets.length);\n    for (var i = 0; i < genesForSets.length; i++) {\n        let subset = new Set;\n        for (const gesel_gene of genesForSets[i]) {\n            let found = reverse_mapping.get(gesel_gene);\n            if (typeof found !== \"undefined\") {\n                for (const gene of found) {\n                    subset.add(gene);\n                }\n            }\n        }\n        new_sets[i] = (new Uint32Array(subset)).sort();\n    }\n\n    return new_sets;\n}\n\n","/**\n * Reindex the gene-to-set mappings for a user-defined gene universe.\n * This is helpful for applications that know their own gene universe and want to create a mapping of all sets containing each of their own genes.\n *\n * @param {Array} geneMapping - Array of length equal to the number of genes in a user-defined gene universe.\n * Each entry corresponds to one gene in the user's universe and contains the corresponding gesel gene ID(s) (see {@linkcode fetchAllGenes} for details).\n * Each entry can be either a number, for a 1:1 mapping; NaN, for a gene that has no matching gesel gene ID; or an array of gesel gene IDs, like that returned by {@linkcode searchGenes}.\n * @param {Array} setsForGenes - Array of length equal to the number of gesel gene IDs.\n * Each entry corresponds to a gesel gene ID and is an array containing the set IDs for all sets containing that gene.\n * This is typically obtained from {@linkcode fetchSetsForAllGenes}.\n *\n * @return {Array} Array of length equal to `geneMapping`.\n * Each entry corresponds to a gene in the user-supplied universe and is a Uint32Array where the elements are the gesel set IDs containing that gene.\n * If a gene in `geneMapping` maps to multiple gesel IDs, we report all sets containing any of its mapped gesel gene IDs.\n */\nexport function reindexSetsForAllGenes(geneMapping, setsForGenes) {\n    let remapped = new Array(geneMapping.length);\n    for (var i = 0; i < geneMapping.length; i++) {\n        let collected = new Set;\n        for (const gesel_gene of geneMapping[i]) {\n            for (const set of setsForGenes[gesel_gene]) {\n                collected.add(set);\n            }\n        }\n        remapped[i] = (new Uint32Array(collected)).sort();\n    }\n    return remapped;\n}\n","import * as utils from \"./utils.js\";\n\nexport function binarySearch(query, vector) {\n    let left = 0;\n    let right = vector.length;\n\n    while (left < right) {\n        let mid = Math.trunc((left + right) / 2);\n        if (vector[mid] < query) {\n            left = mid + 1;\n        } else if (vector[mid] > query) {\n            right = mid;\n        } else {\n            return mid;\n        }\n    }\n\n    return left;\n}\n\nasync function fetchSetsByToken(species, token, file, all_ranges, all_ordered, all_cache) {\n    let actual_file = species + \"_\" + file;\n\n    let cached = all_cache.get(species);\n    if (typeof cached === \"undefined\") {\n        const { ranges, order } = await utils.retrieveNamedRanges(actual_file);\n        all_ranges.set(species, ranges);\n        all_ordered.set(species, order);\n        cached = new Map;\n        all_cache.set(species, cached);\n    }\n\n    if (token == null) {\n        return;\n    }\n\n    let tfound = cached.get(token);\n    if (typeof tfound !== \"undefined\") {\n        return tfound;\n    }\n\n    let ranges = all_ranges.get(species);\n    let output;\n    if (token.includes(\"*\") || token.includes(\"?\")) {\n        let ordered = all_ordered.get(species);\n\n        // Wildcard handling.\n        let initstub = token.replace(/[*?].*/, \"\")\n        let pos = (initstub == \"\" ? 0 : binarySearch(initstub, ordered));\n        let regex = new RegExp(token.replace(/[*]/g, \".*\").replace(/[?]/g, \".\"));\n\n        let collected = [];\n        let to_cache = [];\n        let union = new Set;\n\n        while (pos < ordered.length) {\n            let candidate = ordered[pos];\n            if (initstub != \"\" && !candidate.startsWith(initstub)) {\n                break;\n            }\n\n            let cfound = cached.get(candidate);\n            if (typeof cfound === \"undefined\") {\n                let rr = ranges.get(candidate);\n                collected.push(utils.retrieveBytes(actual_file, rr[0], rr[1]).then(utils.convertToUint32Array));\n                to_cache.push(candidate);\n            } else {\n                for (const y of cfound) {\n                    union.add(y);\n                }\n            }\n\n            pos++;\n        }\n\n        let resolved = await Promise.all(collected);\n        for (var i = 0; i < resolved.length; i++) {\n            let x = resolved[i];\n            cached.set(to_cache[i], x);\n            for (const y of x) {\n                union.add(y);\n            }\n        }\n\n        output = new Uint32Array(union);\n\n    } else {\n        // Direct handling.\n        let rr = ranges.get(token);\n        if (typeof rr === \"undefined\") {\n            return new Uint32Array;\n        }\n        let text = await utils.retrieveBytes(actual_file, rr[0], rr[1]);\n        output = utils.convertToUint32Array(text);\n    }\n\n    cached.set(token, output);\n    return output;\n}\n\nconst n_cache = new Map;\nconst n_ranges = new Map;\nconst n_ordered = new Map;\n\nasync function fetchSetsByNameToken(species, token) {\n    return fetchSetsByToken(species, token, \"tokens-names.tsv\", n_ranges, n_ordered, n_cache);\n}\n\nconst d_cache = new Map;\nconst d_ranges = new Map;\nconst d_ordered = new Map;\n\nasync function fetchSetsByDescriptionToken(species, token) {\n    return fetchSetsByToken(species, token, \"tokens-descriptions.tsv\", d_ranges, d_ordered, d_cache);\n}\n\nexport async function preloadTokens(species, resp, ordered, cache, msg) {\n    if (!resp.ok) {\n        throw new Error(\"failed to fetch full set of \" + msg + \" tokens for species '\" + species + \"'\");\n    }\n\n    let lines = utils.decompressLines(await resp.arrayBuffer());\n    if (lines.length !== ordered.length) {\n        throw new Error(\"mismatch in lengths between token names and set indices for species '\" + species + \"'\");\n    }\n\n    for (var i = 0; i < lines.length; i++) {\n        cache.set(ordered[i], utils.convertToUint32Array(lines[i]));\n    }\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n *\n * @return Preloads the search indices for use in {@linkcode searchSetText}.\n * This performs a one-off download of the indices such that further calls to {@linkcode searchSetText} do not need to perform HTTP range requests.\n */\nexport async function preloadSearchSetText(species) {\n    let full = await Promise.all([ \n        utils.reference_download(species + \"_tokens-names.tsv.gz\"),\n        utils.reference_download(species + \"_tokens-descriptions.tsv.gz\"),\n        fetchSetsByNameToken(species, null),\n        fetchSetsByDescriptionToken(species, null)\n    ]);\n    await preloadTokens(species, full[0], n_ordered.get(species), n_cache.get(species), \"name\");\n    await preloadTokens(species, full[1], d_ordered.get(species), d_cache.get(species), \"description\");\n    return;\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {string} query - Query string containing multiple words to search in the names and/or descriptions of each set.\n *\n * Each stretch of alphanumeric characters and dashes is treated as a single word.\n * All other characters are treated as punctuation between words, except for the following wildcards:\n *\n * - `*`: match zero or more alphanumeric or dash characters.\n * - `?`: match exactly one alphanumeric or dash character.\n *\n * A set's name and/or description must contain all words in `query` to be considered a match.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.inName=true] - Whether to search the name of the set for matching words.\n * @param {boolean} [options.inDescription=true] - Whether to search the description of the set for matching words.\n *\n * @return {Array} Array of indices of the sets with names and/or descriptions that match `query`.\n * @async\n */\nexport async function searchSetText(species, query, { inName = true, inDescription = true } = {}) {\n    // Tokenizing the query using the same logic as in the feedstock repository,\n    // but preserving our wildcards for special handling later.\n    let processed = query.toLowerCase().replace(/[^a-zA-Z0-9-?*]/g, \" \");\n    let tokens = processed.split(/\\s+/);\n    tokens = tokens.filter(x => x !== \"\" || x !== \"-\");\n\n    let init = [];\n    if (inName) {\n        init.push(fetchSetsByNameToken(species, null));\n    }\n    if (inDescription) {\n        init.push(fetchSetsByDescriptionToken(species, null));\n    }\n    await Promise.all(init); // force initialization of all caches.\n\n    let gathered_names = [];\n    if (inName) {\n        let already_queried = new Set;\n        for (const tok of tokens) {\n            if (!already_queried.has(tok)) {\n                gathered_names.push(fetchSetsByNameToken(species, tok));\n                already_queried.add(tok);\n            }\n        }\n    }\n\n    let gathered_descriptions = [];\n    if (inDescription) {\n        let already_queried = new Set;\n        for (const tok of tokens) {\n            if (!already_queried.has(tok)) {\n                gathered_descriptions.push(fetchSetsByDescriptionToken(species, tok));\n                already_queried.add(tok);\n            }\n        }\n    }\n\n    let resolved_names = await Promise.all(gathered_names);\n    let resolved_descriptions = await Promise.all(gathered_descriptions);\n\n    let gathered = [];\n    for (var i = 0; i < tokens.length; i++) {\n        let n = (inName ? resolved_names[i] : []);\n        let d = (inDescription ? resolved_descriptions[i] : []);\n\n        let combined = new Uint32Array(n.length + d.length);\n        combined.set(n);\n        combined.set(d, n.length);\n        gathered.push(combined);\n    }\n\n    return utils.intersect(gathered);\n}\n","import * as utils from \"./utils.js\";\n\n/**\n * Helper class for handling matrix data from multiple modalities.\n * In particular, it simplifies memory management of the assorted {@linkplain ScranMatrix} instances containing data for different features in the same set of cells.\n */\nexport class MultiMatrix {\n    #store;\n    #ncols;\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {object} [options.store={}] - Existing store of {@linkplain ScranMatrix} objects.\n     * Each matrix should correspond to a different modality, named according to its key.\n     * All matrices should have data for the same set of cells, i.e., same number of columns.\n     */\n    constructor({ store = {} } = {}) {\n        this.#store = store;\n        this.#ncols = null;\n\n        let keys = Object.keys(store);\n        if (keys.length) {\n            // We ignore numberOfColumns here, as everyone should have the same number of cells.\n            for (var k = 0; k < keys.length; k++) {\n                let current = store[keys[k]];\n                if (k == 0) {\n                    this.#ncols = current.numberOfColumns();\n                } else if (current.numberOfColumns() != this.#ncols) {\n                    throw new Error(\"all matrices should have the same number of columns\");\n                }\n            }\n        }\n    }\n\n    /**\n     * @return {?number} Number of columns in the matrices.\n     * If no matrices are available, `null` is returned.\n     */\n    numberOfColumns() {\n        return this.#ncols;\n    }\n\n    /**\n     * @return {Array} Names of the available modalities.\n     */\n    available() {\n        return Object.keys(this.#store);\n    }\n\n    /**\n     * @param {string} i - Name of a modality.\n     * @return {boolean} Whether modality `i` is available.\n     */\n    has(i) {\n        return (i in this.#store);\n    }\n\n    /**\n     * @param {string} i - Name of a modality.\n     * @return {ScranMatrix} The matrix data for modality `i`.\n     */\n    get(i) {\n        return this.#store[i];\n    }\n\n    /**\n     * @param {string} i - Name of a modality.\n     * @param {ScranMatrix} matrix - The matrix data for modality `i`.\n     *\n     * @return `matrix` is added to the MultiMatrix with name `i`.\n     */\n    add(i, matrix) {\n        if (this.#ncols === null) {\n            this.#ncols = matrix.numberOfColumns();\n        } else if (matrix.numberOfColumns() != this.#ncols) {\n            throw new Error(\"all matrices should have the same number of columns\");\n        }\n\n        if (i in this.#store) {\n            let old = this.#store[i];\n            utils.free(old);\n        }\n\n        this.#store[i] = matrix;\n    }\n\n    /**\n     * @param {string} i - Name of a modality.\n     * @return Modality `i` is removed from the MultiMatrix.\n     */\n    remove(i) {\n        utils.free(this.#store[i]);\n        delete this.#store[i];\n        if (Object.keys(this.#store).length == 0) {\n            this.#ncols = null;\n        }\n    }\n\n    /**\n     * @param {string} i - Name of a modality.\n     * @return {MultiMatrix} A deep copy of the current object. \n     */\n    clone() {\n        let new_matrix = new MultiMatrix;\n        try {\n            for (const [k, v] of Object.entries(this.#store)) {\n                new_matrix.add(k, v.clone());\n            }\n        } catch (e) {\n            new_matrix.free();\n            throw e;\n        }\n        return new_matrix;\n    }\n\n    /**\n     * @param {string} from - Old name of the modality.\n     * @param {string} to - New name for the modality.\n     *\n     * @return The modality `from` is renamed to `to`, possibly replacing any existing modality at `to`.\n     */\n    rename(from, to) {\n        if (from !== to) {\n            if (to in this.#store) {\n                utils.free(this.#store[to]);\n            }\n            this.#store[to] = this.#store[from];\n            delete this.#store[from];\n        }\n    }\n\n    /**\n     * @return Frees memory for all modalities in this MultiMatrix.\n     */\n    free() {\n        for (const [x, v] of Object.entries(this.#store)) {\n            utils.free(v);\n        }\n        return;\n    }\n}\n","import * as utils from \"./utils.js\";\nimport * as gc from \"./gc.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Wrapper around a matrix allocated on the Wasm heap.\n * @hideconstructor\n */\nexport class ScranMatrix {\n    #id;\n    #matrix;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#matrix = raw;\n        return;\n    }\n\n    /**\n     * Create a dense matrix from an existing Wasm-allocated buffer.\n     *\n     * @param {number} rows - Number of rows.\n     * @param {number} columns - Number of columns.\n     * @param {Float64WasmArray} contents - Array of matrix contents.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.columnMajor=true] - Whether the array in `contents` is column-major.\n     * @param {boolean} [options.copy=true] - Whether to copy `contents` when constructing the {@linkplain ScranMatrix}.\n     * If `false`, the returned {@linkplain ScranMatrix} will refer to the same allocation as `contents`,\n     * so callers should make sure that it does not outlive `contents`.\n     *\n     * @return A {@linkplain ScranMatrix} containing the matrix contents.\n     */\n    static createDenseMatrix(rows, columns, contents, { columnMajor = true , copy = true } = {}) {\n        if (!(contents instanceof wa.Float64WasmArray)) {\n            throw new Error(\"'contents' should be a Float64WasmArray\");\n        }\n        if (contents.length != rows * columns) {\n            throw new Error(\"length of 'contents' should equal the product of 'rows' and 'columns'\");\n        }\n        return gc.call(module => new module.NumericMatrix(rows, columns, contents.offset, columnMajor, copy), ScranMatrix);\n    }\n\n    /**\n     * @return {ScranMatrix} A clone of the current ScranMatrix instance.\n     * This can be freed independently of the current instance.\n     */\n    clone() {\n        return gc.call(\n            module => this.#matrix.clone(),\n            ScranMatrix\n        );\n    }\n\n    // Internal use only, not documented.\n    get matrix() {\n        return this.#matrix;\n    }\n\n    /**\n     * @return {number} Number of rows in the matrix.\n     */\n    numberOfRows() {\n        return this.#matrix.nrow();\n    }\n\n    /**\n     * @return {number} Number of columns in the matrix.\n     */\n    numberOfColumns() {\n        return this.#matrix.ncol();\n    }\n\n    /**\n     * @param {number} i - Index of the row to extract.\n     * This should be a non-negative integer less than {@linkcode ScranMatrix#numberOfRows numberOfRows}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?Float64WasmArray} [options.buffer=null] - Buffer for storing the extracted data.\n     * If supplied, this should have length equal to {@linkcode ScranMatrix#numberOfColumns numberOfColumns}.\n     *\n     * @return {Float64Array} An array containing the contents of row `i`.\n     *\n     * If `buffer` was supplied, the returned array is a view into it.\n     * Note that this may be invalidated on the next allocation on the Wasm heap.\n     */\n    row(i, { buffer = null } = {}) {\n        if (buffer != null) {\n            this.#matrix.row(i, buffer.offset);\n            return buffer.array();\n        } else {\n            var output;\n            buffer = utils.createFloat64WasmArray(this.#matrix.ncol());\n            try {\n                this.#matrix.row(i, buffer.offset);\n                output = buffer.slice();\n            } finally {\n                buffer.free();\n            }\n            return output;\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the column to extract.\n     * This should be a non-negative integer less than {@linkcode ScranMatrix#numberOfColumns numberOfColumns}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?Float64WasmArray} [options.buffer=null] - Buffer for storing the extracted data.\n     * If supplied, this should have length equal to {@linkcode ScranMatrix#numberOfRows numberOfRows}.\n     *\n     * @return {Float64Array} An array containing the contents of column `i`.\n     *\n     * If `buffer` was supplied, the returned array is a view into it.\n     * Note that this may be invalidated on the next allocation on the Wasm heap.\n     */\n    column(i, { buffer = null } = {}) {\n        if (buffer != null) {\n            this.#matrix.column(i, buffer.offset);\n            return buffer.array();\n        } else {\n            var output;\n            buffer = utils.createFloat64WasmArray(this.#matrix.nrow());\n            try {\n                this.#matrix.column(i, buffer.offset);\n                output = buffer.slice();\n            } finally {\n                buffer.free();\n            }\n            return output;\n        }\n    }\n\n    /** \n     * Free the memory on the Wasm heap for this.#matrix.\n     * This invalidates this object and all of its references.\n     */\n    free() {\n        if (this.#matrix !== null) {\n            gc.release(this.#id);\n            this.#matrix = null;\n        }\n        return;\n    }\n\n    /**\n     * @return {boolean} Whether the matrix is sparse.\n     */\n    isSparse() {\n        return this.#matrix.sparse();\n    }\n\n    // Internal use only, by initialize* functions.\n    isReorganized() {\n        return this.#matrix.reorganized();\n    }\n\n    // Internal use only, by initialize* functions.\n    identities({ buffer = null } = {}) {\n        if (buffer != null) {\n            this.#matrix.identities(buffer.offset);\n            return buffer.array();\n        } else {\n            var output;\n            buffer = utils.createInt32WasmArray(this.#matrix.nrow());\n            try {\n                this.#matrix.identities(buffer.offset);\n                output = buffer.slice();\n            } finally {\n                buffer.free();\n            }\n            return output;\n        }\n    }\n\n    // Internal use only, by initialize* functions.\n    wipeIdentities() {\n        this.#matrix.wipe_identities();\n        return;\n    }\n}\n","import * as methods from \"../file.js\";\n\nexport function temp(prefix, extension) {\n    let tmppath;\n    do {\n        tmppath = prefix + String(Number(new Date())) + \"_\" + String(Math.round(Math.random() * 10000)) + extension;\n    } while (methods.existsFile(tmppath));\n    return tmppath;\n}\n\nexport function handleString(file) {\n    throw new Error(\"cannot access the file system in a browser context\");\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\nimport { ScranMatrix } from \"./ScranMatrix.js\";\n\n/**\n * Wrapper for the cell aggregation results, produced by {@linkcode aggregateAcrossCells}.\n * @hideconstructor\n */\nexport class AggregateAcrossCellsResults {\n    #id;\n    #results;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#results = raw;\n        return;\n    }\n\n    /**\n     * @return {number} Number of groups.\n     */\n    numberOfGroups() {\n        return this.#results.num_groups();\n    }\n\n    /**\n     * @return {number} Number of genes.\n     */\n    numberOfGenes() {\n        return this.#results.num_genes();\n    }\n\n    /**\n     * @param {?number} group - Index of the group.\n     * If a number, it should be non-negative and less than {@linkcode AggregateAcrossCellsResults#numberOfGroups numberOfGroups}.\n     * This may also be `null` to obtain values for all groups.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {(string|boolean)} [options.copy=true] - Copying mode to use when `asMatrix = false`, see {@linkcode possibleCopy} for details.\n     *\n     * @return {Float64Array|Float64WasmArray}\n     * If `group` is a number, an array is returned where each entry corresponds to a gene and contains the summed value across all cells in the specified `group`.\n     * If {@linkcode aggregateAcrossCells} was run with `average = true`, the array contains the mean value instead of the sum.\n     *\n     * If `group = null`, an array is returned containing the concatenation of the arrays for all groups.\n     * If `copy = \"view\"`, the output can be used in {@linkcode ScranMatrix#create ScranMatrix.create} to create a {@linkcode ScranMatrix} for input into other functions.\n     */\n    sums(group, { copy = true } = {}) {\n        let vec = (group !== null ? this.#results.group_sums(group) : this.#results.all_sums());\n        return utils.possibleCopy(vec, copy);\n    }\n\n    /**\n     * @param {number} group - Index of the group.\n     * This should be non-negative and less than {@linkcode AggregateAcrossCellsResults#numberOfGroups numberOfGroups}.\n     * This may also be `null` to obtain values for all groups.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {(string|boolean)} [options.copy=true] - Copying mode to use when `asMatrix = false`, see {@linkcode possibleCopy} for details.\n     *\n     * @return {Float64Array|Float64WasmArray}\n     * If `group` is a number, an array is returned where each entry corresponds to a gene and contains the number of detected cells in the specified `group`.\n     * If {@linkcode aggregateAcrossCells} was run with `average = true`, each value is the proportion of cells with detected expression.\n     * \n     * If `group = null`, an array is returned containing the concatenation of the arrays for all groups.\n     * If `copy = \"view\"`, the output can be used in {@linkcode ScranMatrix#create ScranMatrix.create} to create a {@linkcode ScranMatrix} for input into other functions.\n     */\n    detected(group, { copy = true } = {}) {\n        let vec = (group !== null ? this.#results.group_detected(group) : this.#results.all_detected());\n        return utils.possibleCopy(vec, copy);\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Aggregate per-cell expression profiles for each group of cells.\n * This is typically used to summarize data into per-cluster expression profiles for easier inspection.\n *\n * @param {ScranMatrix} x - Some expression matrix, typically containing normalized log-expression values.\n * @param {Int32Array|Int32WasmArray} groups - Array containing group IDs for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of groups.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.average=false] - Whether to compute the average expression instead of the sum for each group.\n * Similarly, the proportion of detected expression is reported, rather than the number of detected cells in each group.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {AggregateAcrossCellsResults} Object containing the aggregation results.\n */\nexport function aggregateAcrossCells(x, groups, { average = false, numberOfThreads = null } = {}) {\n    var group_data;\n    var output;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        group_data = utils.wasmifyArray(groups, \"Int32WasmArray\");\n        if (group_data.length != x.numberOfColumns()) {\n            throw new Error(\"length of 'groups' should be equal to number of columns in 'x'\");\n        }\n\n        output = gc.call(\n            module => module.aggregate_across_cells(x.matrix, group_data.offset, average, nthreads),\n            AggregateAcrossCellsResults \n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(group_data);\n    }\n\n    return output;\n}\n","import * as utils from \"./utils.js\";\nimport * as wa from \"wasmarrays.js\";\nimport * as fac from \"./factorize.js\";\n\n/**\n * Create a blocking factor for a set of contiguous blocks, usually to accompany the output of {@linkcode cbind} on matrices representing different batches.\n * This can be used as the blocking factor in functions such as {@linkcode modelGeneVar} or {@linkcode scoreMarkers}.\n * Note that no protection is provided against empty blocks; if this is a possibility, use {@linkcode dropUnusedBlock} on the output of this function.\n *\n * @param {(Array|TypedArray)} ncells - Array of integers specifying the number of cells in each block.\n *\n * Note that TypedArray views on Wasm-allocated buffers should only be provided if `buffer` is also provided;\n * otherwise, a Wasm memory allocation may invalidate the view.\n * @param {object} [options={}] - Optional parameters.\n * @param {?Int32WasmArray} [options.buffer=null] - Array in which the output is to be stored.\n * If provided, this should be of length equal to the sum of `ncells`.\n *\n * @return {Int32WasmArray} Array containing the blocking factor.\n * Each value specifies the block of origin for each cell.\n *\n * If `buffer` was supplied, it is used as the return value. \n */\nexport function createBlock(ncells, { buffer = null } = {}) {\n    let total = 0;\n    ncells.forEach(x => { total += x; });\n\n    let local_buffer;\n    try {\n        if (buffer == null) {\n            local_buffer = utils.createInt32WasmArray(total);\n            buffer = local_buffer;\n        } else if (buffer.length !== total) {\n            throw new Error(\"'buffer' should have length equal to sum of 'ncells'\");\n        }\n\n        let barr = buffer.array();\n        let sofar = 0;\n        for (var i = 0; i < ncells.length; i++) {\n            let old = sofar;\n            sofar += ncells[i];\n            barr.fill(i, old, sofar);\n        }\n\n    } catch (e) {\n        utils.free(local_buffer);\n        throw e;\n    }\n\n    return buffer;\n}\n\n// Soft-deprecated in favor of the more general convertToFactor().\nexport function convertBlock(x, { buffer = null } = {}) {\n    let output = fac.convertToFactor(x, { buffer, action: \"warn\", placeholder: 0 });\n    output.levels = output.levels.map(String);\n    return output;\n}\n\n// Soft-deprecated in favor of the more general subsetFactor(), or wasmarrays.js's subsetWasmArray, take your choice.\nexport function subsetBlock(x, subset, { filter = null, buffer = null } = {}) {\n    return wa.subsetWasmArray(x, subset, { filter, buffer });\n}\n\n// Soft-deprecated, just use subsetFactor().\nexport function filterBlock(x, filter, { buffer = null } = {}) {\n    return subsetBlock(x, filter, { buffer: buffer, filter: true });\n}\n\n// Soft-deprecated in favor of dropUnusedLevels().\nexport function dropUnusedBlock(x) {\n    return fac.dropUnusedLevels(x);\n}\n","import * as utils from \"./utils.js\";\nimport { ScranMatrix } from \"./ScranMatrix.js\";\nimport * as gc from \"./gc.js\";\n\nfunction harvest_matrices(x) {\n    let output = utils.createBigUint64WasmArray(x.length);\n    let arr = output.array();\n    for (var i = 0; i < x.length; i++) {\n        arr[i] = BigInt(x[i].matrix.$$.ptr);\n    }\n    return output;\n}\n\n/**\n * Combine matrices by column, where all matrices contain data for the same features, in the same order.\n *\n * @param {Array} inputs - Array of one or more {@linkplain ScranMatrix} objects.\n * All of these should have the same number and order of features.\n *\n * @return {ScranMatrix} A {@linkplain ScranMatrix} containing the matrices after combining them by column.\n */\nexport function cbind(inputs) {\n    let mat_ptrs;\n    let output;\n\n    try {\n        mat_ptrs = harvest_matrices(inputs);\n        output = gc.call(\n            module => module.cbind(mat_ptrs.length, mat_ptrs.offset),\n            ScranMatrix\n        );\n    } catch (e) {\n        utils.free(output);\n        throw e;\n    } finally {\n        utils.free(mat_ptrs);\n    }\n\n    return output;\n}\n\n/**\n * Combine matrices by row, where all matrices contain data for the same cells, in the same order.\n *\n * @param {Array} inputs - Array of one or more {@linkplain ScranMatrix} objects.\n * All of these should have the same number and order of cells.\n *\n * @return {ScranMatrix} A {@linkplain ScranMatrix} containing the matrices after combining them by row.\n */\nexport function rbind(inputs) {\n    let mat_ptrs;\n    let output;\n\n    try {\n        mat_ptrs = harvest_matrices(inputs);\n        output = gc.call(\n            module => module.rbind(mat_ptrs.length, mat_ptrs.offset),\n            ScranMatrix\n        );\n    } catch (e) {\n        utils.free(output);\n        throw e;\n    } finally {\n        utils.free(mat_ptrs);\n    }\n\n    return output;\n}\n\n/**\n * Combine matrices by column, after subsetting each matrix to the intersection of common features.\n *\n * @param {Array} inputs - Array of one or more {@linkplain ScranMatrix} objects.\n * @param {Array} names - Array of length equal to `inputs`.\n * Each entry should be an Array containing the row names of the corresponding entry of `inputs`.\n * Names should correspond to the rows of that entry of `inputs`.\n *\n * @return {object} An object containing:\n * - `matrix`, a {@linkplain ScranMatrix} containing the combined matrices.\n * - `indices`, an Int32WasmArray of length equal to the number of rows in `matrix`.\n *    This contains the index of the row in the first entry of `inputs` corresponding to each row of `matrix`,\n *    i.e., the gene at the `i`-th row of `matrix` is the same as the gene at the `indices[i]`-th row of `inputs[0]`.\n * - `names`, an array of names identifying the rows of `matrix`.\n *    This is constructed by indexing the first entry of `names` with `indices`.\n */\nexport function cbindWithNames(x, names) {\n    let mat_ptrs;\n    let renamed = [];\n    let name_ptrs;\n    let indices;\n    let output = {};\n\n    try {\n        // Building a common set of rownames.\n        if (names.length !== x.length) {\n            throw new Error(\"length of 'names' should be equal to length of 'x'\");\n        }\n\n        let common = {};\n        let universe = [];\n        for (var i = 0; i < names.length; i++) {\n            if (x[i].numberOfRows() !== names[i].length) {\n                throw new Error(\"length of each 'names' must equal number of rows of its corresponding 'x'\");\n            }\n            names[i].forEach(x => {\n                if (!(x in common)) {\n                    common[x] = universe.length;\n                    universe.push(x);\n                }\n            });\n        }\n\n        name_ptrs = utils.createBigUint64WasmArray(x.length);\n        {\n            let names_arr = name_ptrs.array();\n            for (var i = 0; i < names.length; i++) {\n                let current = names[i];\n                let replacement = utils.createInt32WasmArray(current.length);\n                let replacement_arr = replacement.array();\n                current.forEach((x, i) => {\n                    replacement_arr[i] = common[x];\n                });\n                renamed.push(replacement);\n                names_arr[i] = BigInt(replacement.offset);\n            }\n        }\n\n        mat_ptrs = harvest_matrices(x);\n        indices = utils.createInt32WasmArray(x[0].numberOfRows());\n        output.matrix = gc.call(\n            module => module.cbind_with_rownames(x.length, mat_ptrs.offset, name_ptrs.offset, indices.offset),\n            ScranMatrix\n        );\n\n        output.indices = indices.slice(0, output.matrix.numberOfRows());\n        let internames = [];\n        for (const i of output.indices) {\n            internames.push(names[0][i]);\n        }\n        output.names = internames;\n\n    } catch (e) {\n        utils.free(output.matrix);\n        throw e;\n\n    } finally {\n        utils.free(mat_ptrs);\n        utils.free(name_ptrs);\n        utils.free(indices);\n        for (const x of renamed) {\n            utils.free(x);\n        }\n    }\n\n    return output;\n}\n","import * as utils from \"./utils.js\";\nimport { ModelGeneVarResults } from \"./modelGeneVar.js\";\n\n/**\n * Compute the filter threshold required to retain the top `number` values.\n *\n * @param {Array|TypedArray} x - Array of numeric values, typically per-gene statistics.\n * @param {number} number - Number of top values to retain after filtering on the returned threshold.\n * This may be approximate in the presence of ties.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.largest=true] - Whether the top values in `x` are defined as the largest numeric values.\n * If `false`, the top values are considered to be the smallest.\n * @param {boolean} [options.copy=true] - Whether to copy `x` before sorting.\n * If `false`, `x` may be modified in-place.\n *\n * @return {number} Threshold to be applied to `x` to obtain the top (approximately) `number` values.\n * If `largest = true`, filtering is performed by taking all values in `x` that are greater than or equal to the returned threshold;\n * if `false`, filtering is performed by taking all values in `x` that are less than or equal to the returned threshold.\n * If `x` is zero-length, NaN is returned.\n */\nexport function computeTopThreshold(x, number, { copy = true, largest = true } = {}) {\n    if (copy) {\n        x = x.slice();\n    }\n\n    if (x instanceof Array) {\n        x.sort((a, b) => a - b); // just in case...\n    } else {\n        x.sort();\n    }\n\n    if (x.length == 0) {\n        return Number.NaN;\n    }\n\n    if (largest) {\n        return x[Math.max(0, x.length - number)]; \n    } else {\n        return x[Math.min(number, x.length) - 1]; \n    }\n}\n\n/**\n * Choose the highly variable genes from variance modelling statistics.\n *\n * @param {(TypedArray|ModelGeneVarResults)} x -\n * A TypedArray of statistics, where larger values correspond to higher variability;\n * or a {@linkplain ModelGeneVarResults} object, in which case the residuals are used as the statistics.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.number=4000] - Number of highly variable genes to select.\n * @param {number} [options.minimum=0] - Minimum value of the residual to consider for a highly variable gene.\n * By default, a highly variable gene must have a non-negative residual.\n *\n * @return {Uint8WasmArray} Array of length equal to the total number of genes,\n * where the chosen highly variable genes are marked with a value of 1 and all other genes have values of zero.\n */\nexport function chooseHVGs(x, { number = 4000, minimum = 0 } = {}) {\n    let stat; \n    if (x instanceof ModelGeneVarResults) {\n        stat = x.residuals();\n    } else {\n        stat = x.slice();\n    }\n\n    let threshold = computeTopThreshold(stat, number, { largest: true, copy: false });\n    if (threshold < minimum) {\n        threshold = minimum;\n    }\n\n    let features = utils.createUint8WasmArray(stat.length);\n    try {\n        // Do this AFTER the features allocation, so that\n        // we can set copy = false for the input array.\n        if (x instanceof ModelGeneVarResults) {\n            stat = x.residuals({ copy: false });\n        } else {\n            stat = x;\n        }\n\n        let farr = features.array();\n        stat.forEach((x, i) => {\n            farr[i] = x >= threshold;\n        });\n\n    } catch (e) {\n        features.free();\n        throw e;\n    }\n\n    return features;\n}\n","import * as utils from \"./utils.js\";\nimport * as gc from \"./gc.js\";\nimport { RunPCAResults } from \"./runPCA.js\";\n\n/**\n * Wrapper around the k-means clustering results on the Wasm heap, produced by {@linkcode clusterKmeans}.\n * @hideconstructor\n */\nexport class ClusterKmeansResults {\n    #id;\n    #results;\n\n    #filledClusters;\n    #filledSizes;\n    #filledCenters;\n    #filledWcss;\n    #filledIterations;\n    #filledStatus;\n\n    constructor(id, raw, filled = true) {\n        this.#results = raw;\n        this.#id = id;\n\n        this.#filledClusters = filled;\n        this.#filledSizes = filled;\n        this.#filledCenters = filled;\n        this.#filledWcss = filled;\n        this.#filledIterations = filled;\n        this.#filledStatus = filled;\n\n        return;\n    }\n\n    /**\n     * @return {number} Number of cells in the results.\n     */\n    numberOfCells() {\n        return this.#results.num_obs();\n    }\n\n    /**\n     * @return {number} Number of clusters in the results.\n     */\n    numberOfClusters() {\n        return this.#results.num_clusters();\n    }\n\n    /**\n     * @param {number} iterations - Number of iterations.\n     * @return The specified number of iterations is set in this object.\n     * Typically only used after {@linkcode emptyClusterKmeansResults}.\n     */\n    setIterations(iterations) {\n        if (!this.#filledIterations) {\n            this.#filledIterations = true;\n        }\n        this.#results.set_iterations(iterations);\n        return;\n    }\n\n    /**\n     * @param {number} status - Status of the k-means clustering.\n     * @return The status is set in this object.\n     * Typically only used after {@linkcode emptyClusterKmeansResults}.\n     */\n    setStatus(status) {\n        if (!this.#filledStatus) {\n            this.#filledStatus = true;\n        }\n        this.#results.set_status(status);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the cluster assignment for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    clusters({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledClusters, \n            () => { this.#filledClusters = true }, \n            COPY => utils.possibleCopy(this.#results.clusters(), COPY),\n            \"clusters\"\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the number of cells in each cluster.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    clusterSizes({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSizes, \n            () => { this.#filledSizes = true }, \n            COPY => utils.possibleCopy(this.#results.cluster_sizes(), COPY),\n            \"clusterSizes\"\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the within-cluster sum of squares in each cluster.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    withinClusterSumSquares({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledWcss, \n            () => { this.#filledWcss = true }, \n            COPY => utils.possibleCopy(this.#results.wcss(), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the cluster centers in column-major format,\n     * where rows are dimensions and columns are the clusters.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    clusterCenters({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledCenters, \n            () => { this.#filledCenters = true }, \n            COPY => utils.possibleCopy(this.#results.centers(), COPY)\n        );\n    }\n\n    /**\n     * @return {?number} Number of refinement iterations performed by the algorithm.\n     * Alternatively `null`, if this value has not been filled by {@linkcode ClusterKmeansResults#setIterations setIterations}.\n     */\n    iterations() {\n        if (!this.#filledIterations) {\n            return null;\n        } else {\n            return this.#results.iterations();\n        }\n    }\n\n    /**\n     * @return {?number} Status of the algorithm - anything other than zero usually indicates a problem with convergence.\n     * Alternatively `null`, if this value has not been filled by {@linkcode ClusterKmeansResults#setStatus setStatus}.\n     */\n    status() {\n        if (!this.#filledStatus) {\n            return null;\n        } else {\n            return this.#results.status();\n        }\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Cluster cells using k-means.\n *\n* @param {(RunPCAResults|Float64WasmArray|Array|TypedArray)} x - Numeric coordinates of each cell in the dataset.\n * For array inputs, this is expected to be in column-major format where the rows are the variables and the columns are the cells.\n * For a {@linkplain RunPCAResults} input, we extract the principal components.\n * @param {number} clusters Number of clusters to create.\n * This should not be greater than the number of cells.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfDims=null] - Number of variables/dimensions per cell.\n * Only used (and required) for array-like `x`.\n * @param {?number} [options.numberOfCells=null] - Number of cells.\n * Only used (and required) for array-like `x`.\n * @param {string} [options.initMethod=\"pca-part\"] - Initialization method.\n * Setting `\"random\"` will randomly select `clusters` cells as centers.\n * Setting `\"kmeans++\"` will use the weighted sampling approach of Arthur and Vassilvitskii (2007).\n * Setting `\"pca-part\"` will use PCA partitioning.\n * @param {number} [options.initSeed=5768] - Seed to use for random number generation during initialization.\n * @param {number} [options.initPCASizeAdjust=1] - Adjustment factor for the cluster sizes, used when `initMethod = \"pca-part\"`.\n * Larger values (up to 1) will prioritize partitioning of clusters with more cells.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {ClusterKmeansResults} Object containing the clustering results.\n */\nexport function clusterKmeans(x, clusters, { numberOfDims = null, numberOfCells = null, initMethod = \"pca-part\", initSeed = 5768, initPCASizeAdjust = 1, numberOfThreads = null } = {}) {\n    var buffer;\n    var output;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        let pptr;\n\n        if (x instanceof RunPCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            let pcs = x.principalComponents({ copy: false });\n            pptr = pcs.byteOffset;\n\n        } else {\n            if (numberOfDims === null || numberOfCells === null) {\n                throw new Error(\"'numberOfDims' and 'numberOfCells' must be specified when 'x' is an Array\");\n            }\n\n            buffer = utils.wasmifyArray(x, \"Float64WasmArray\");\n            if (buffer.length != numberOfDims * numberOfCells) {\n                throw new Error(\"length of 'x' must be the product of 'numberOfDims' and 'numberOfCells'\");\n            }\n\n            pptr = buffer.offset;\n        }\n\n        output = gc.call(\n            module => module.cluster_kmeans(pptr, numberOfDims, numberOfCells, clusters, initMethod, initSeed, initPCASizeAdjust, nthreads),\n            ClusterKmeansResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(buffer);\n    }\n\n    return output;\n}\n\n/**\n * Create an empty {@linkplain ClusterKmeansResults} object, to be filled with custom results.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfCells - Number of cells in the dataset.\n * @param {number} numberOfClusters - Number of clusters in the dataset.\n * @param {number} numberOfDimensions - Number of dimensions of the embedding used for clustering.\n *\n * @return {ClusterKmeansResults} Object with allocated memory to store variance modelling statistics, but no actual values.\n */\nexport function emptyClusterKmeansResults(numberOfCells, numberOfClusters, numberOfDimensions) {\n    return gc.call(\n        module => new module.ClusterKmeans_Result(numberOfCells, numberOfClusters, numberOfDimensions),\n        ClusterKmeansResults,\n        /* filled = */ false\n    );\n}\n","import * as utils from \"./utils.js\";\nimport * as gc from \"./gc.js\";\nimport { FindNearestNeighborsResults, findNearestNeighbors } from \"./findNearestNeighbors.js\";\n\n/**\n * Wrapper around the SNN graph object on the Wasm heap, produced by {@linkcode buildSNNGraph}.\n * @hideconstructor\n */\nexport class BuildSNNGraphResults {\n    #id;\n    #graph;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#graph = raw;\n        return;\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#graph !== null) {\n            gc.release(this.#id);\n            this.#graph = null;\n        }\n        return;\n    }\n\n    // Not documented, internal use only.\n    get graph() {\n        return this.#graph;\n    }\n}\n\n/**\n * Build a shared nearest graph.\n *\n * @param {(BuildNeighborSearchIndexResults|FindNearestNeighborsResults)} x \n * Either a pre-built neighbor search index for the dataset (see {@linkcode buildNeighborSearchIndex}),\n * or a pre-computed set of neighbor search results for all cells (see {@linkcode findNearestNeighbors}).\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.scheme=\"rank\"] - Weighting scheme for the edges between cells.\n * This can be based on the top ranks of the shared neighbors (`\"rank\"`),\n * the number of shared neighbors (`\"number\"`) \n * or the Jaccard index of the neighbor sets between cells (`\"jaccard\"`).\n * @param {number} [options.neighbors=10] - Number of nearest neighbors to use to construct the graph.\n * Ignored if `x` is a {@linkplain FindNearestNeighborsResults} object.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {BuildSNNGraphResults} Object containing the graph.\n */\nexport function buildSNNGraph(x, { scheme = \"rank\", neighbors = 10, numberOfThreads = null } = {}) {\n    var output;\n    var my_neighbors;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    utils.matchOptions(\"scheme\", scheme, [ \"rank\", \"number\", \"jaccard\" ]);\n\n    try {\n        let ref;\n        if (x instanceof FindNearestNeighborsResults) {\n            ref = x;\n        } else {\n            my_neighbors = findNearestNeighbors(x, neighbors, { numberOfThreads: nthreads }); \n            ref = my_neighbors ; // separate assignment is necessary for only 'my_neighbors' but not 'x' to be freed.\n        }\n\n        output = gc.call(\n            module => module.build_snn_graph(ref.results, scheme, nthreads),\n            BuildSNNGraphResults\n        );\n\n    } catch(e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(my_neighbors);\n    }\n\n    return output;\n}\n\n/**\n * Wrapper around the SNN multi-level clustering results on the Wasm heap, produced by {@linkcode clusterSNNGraph}.\n * @hideconstructor\n */\nexport class ClusterSNNGraphMultiLevelResults {\n    #id;\n    #results;\n\n    #filledBest;\n    #filledModularity;\n    #filledMembership;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledBest = filled;\n        this.#filledModularity = utils.spawnArray(this.numberOfLevels(), filled);\n        this.#filledMembership = utils.spawnArray(this.numberOfLevels(), filled);\n\n        return;\n    }\n\n    /**\n     * @return {?number} The clustering level with the highest modularity.\n     * Alternatively `null`, if this has not been previously set via {@linkcode ClusterSNNGraphMultiLevelResults#setBest setBest}.\n     */\n    best() {\n        if (!this.#filledBest) {\n            return null;\n        } else {\n            return this.#results.best();\n        }\n    }\n\n    #chooseLevel(level) {\n        if (level === null) {\n            level = this.best();\n            if (level == null) {\n                throw new Error(\"'best' has not yet been set via 'setBest'\");\n            }\n        }\n        return level;\n    }\n\n    /**\n     * @param {number} best - Clustering level with the highest modularity.\n     * @return `best` is set as the best clustering level.\n     * This is typically only used after {@linkcode emptyClusterSNNGraphResults}.\n     */\n    setBest(best) {\n        if (!this.#filledBest) {\n            this.#filledBest = true;\n        }\n        this.#results.set_best(best);\n        return;\n    }\n\n    /**\n     * @return {number} Number of levels in the results.\n     */\n    numberOfLevels() {\n        return this.#results.number();\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.level=null] - The clustering level for which to obtain the modularity.\n     * Defaults to the best clustering level from {@linkcode ClusterSNNGraphMultiLevelResults#best best}.\n     *\n     * @return {?number} The modularity at the specified level.\n     * Alternatively `null`, if this has not been set by {@linkcode ClusterSNNGraphMultiLevelResults#setModularity setModularity}.\n     */\n    modularity({ level = null } = {}) {\n        level = this.#chooseLevel(level);\n        if (!this.#filledModularity[level]) {\n            return null;\n        } else {\n            return this.#results.modularity(level);\n        }\n    }\n\n    /**\n     * @param {number} level - The clustering level at which to set the modularity.\n     * @param {number} modularity - Modularity value.\n     *\n     * @return `modularity` is set as the modularity at the specified level.\n     * This is typically only used after {@linkcode emptyClusterSNNGraphResults}.\n     */\n    setModularity(level, modularity) {\n        if (!this.#filledModularity[level]) {\n            this.#filledModularity[level] = true;\n        }\n        this.#results.set_modularity(level, modularity);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.level=null] - The clustering level for which to obtain the cluster membership.\n     * Defaults to the best clustering level from {@linkcode ClusterSNNGraphMultiLevelResults#best best}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the cluster membership for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    membership({ level = null, copy = true, fillable = false } = {}) {\n        level = this.#chooseLevel(level);\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledMembership[level], \n            () => { this.#filledMembership[level] = true; }, \n            COPY => utils.possibleCopy(this.#results.membership(level), COPY)\n        );\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Wrapper around the SNN walktrap clustering results on the Wasm heap, produced by {@linkcode clusterSNNGraph}.\n * @hideconstructor\n */\nexport class ClusterSNNGraphWalktrapResults {\n    #id;\n    #results;\n\n    #filledModularity;\n    #filledModularityDetails;\n    #filledMembership;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledModularity = filled;\n        this.#filledMembership = filled;\n        if (!filled) {\n            let n = this.numberOfMergeSteps() + 1;\n            this.#filledModularityDetails = { which: utils.spawnArray(n, false), remaining: n };\n        }\n\n        return;\n    }\n\n    /**\n     * @return {number} Number of merge steps used by the Walktrap algorithm.\n     */\n    numberOfMergeSteps() {\n        return this.#results.num_merge_steps();\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.at=null] - Index at which to extract the modularity.\n     * This can be any value from 0 to {@linkcode ClusterSNNGraphWalktrapResults#numberOfMergeSteps numberOfMergeSteps} plus 1.\n     * Set to `null` to obtain the largest modularity across all merge steps.\n     *\n     * @return {?number} The modularity at the specified merge step, or the maximum modularity across all merge steps.\n     * Alternatively `null`, if this has not been set by {@linkcode ClusterSNNGraphWalktrapResults#setModularity setModularity}.\n     */\n    modularity({ at = null } = {}) {\n        let fail = false;\n        if (at === null) {\n            if (!this.#filledModularity) {\n                return null;\n            }\n            at = -1;\n        } else if (!this.#filledModularity && !this.#filledModularityDetails[at]) {\n            return null;\n        }\n\n        return this.#results.modularity(at);\n    }\n\n    /**\n     * @param {number} at - Index at which to set the modularity.\n     * This can be any value from 0 to {@linkcode ClusterSNNGraphWalktrapResults#numberOfMergeSteps numberOfMergeSteps} plus 1.\n     * @param {number} modularity - Modularity value.\n     *\n     * @return Modularity value is set in this object.\n     * This is typically used after calling {@linkcode emptyClusterSNNGraphResults}.\n     */\n    setModularity(at, modularity) {\n        if (!this.#filledModularity) {\n            this.#filledModularityDetails.which[at] = true;\n            this.#filledModularityDetails.remaining--;\n            if (this.#filledModularityDetails.remaining == 0) {\n                this.#filledModularity = true;\n            }\n        }\n        this.#results.set_modularity(at, modularity);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the cluster membership for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    membership({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledMembership, \n            () => { this.#filledMembership = true; }, \n            COPY => utils.possibleCopy(this.#results.membership(), COPY)\n        );\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Wrapper around the SNN Leiden clustering results on the Wasm heap, produced by {@linkcode clusterSNNGraph}.\n * @hideconstructor\n */\nexport class ClusterSNNGraphLeidenResults {\n    #id;\n    #results;\n\n    #filledModularity;\n    #filledMembership;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledModularity = filled;\n        this.#filledMembership = filled;\n        return;\n    }\n\n    /**\n     * @return {?number} The quality of the Leiden clustering.\n     * Alternatively `null`, if this has not been set by {@linkcode ClusterSNNGraphLeidenResults#setModularity setModularity}.\n     *\n     * Note that Leiden's quality score is technically a different measure from modularity.\n     * Nonetheless, we use `modularity` for consistency with the other SNN clustering result classes.\n     */\n    modularity() {\n        if (!this.#filledModularity) {\n            return null;\n        } else {\n            return this.#results.modularity();\n        }\n    }\n\n    /**\n     * @param {number} modularity - Modularity value.\n     * @return Modularity value is set in this object.\n     * This is typically used after calling {@linkcode emptyClusterSNNGraphResults}.\n     */\n    setModularity(modularity) {\n        if (!this.#filledModularity) {\n            this.#filledModularity = true;\n        }\n        this.#results.set_modularity(modularity);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the cluster membership for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    membership({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledMembership, \n            () => { this.#filledMembership = true; }, \n            COPY => utils.possibleCopy(this.#results.membership(), COPY)\n        );\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Cluster cells using community detection on the SNN graph.\n *\n * @param {BuildSNNGraphResults} x - The shared nearest neighbor graph constructed by {@linkcode buildSNNGraph}.\n * @param {object} [options={}] - Optional parameters.\n * @param {string} [options.method=\"multilevel\"] - Community detection method to use.\n * This should be one of `\"multilevel\"`, `\"walktrap\"` or `\"leiden\"`.\n * @param {number} [options.multiLevelResolution=1] - The resolution of the multi-level clustering, when `method = \"multilevel\"`.\n * Larger values result in more fine-grained clusters.\n * @param {number} [options.leidenResolution=1] - The resolution of the Leiden clustering, when `method = \"leiden\"`.\n * Larger values result in more fine-grained clusters.\n * @param {boolean} [options.leidenModularityObjective=false] - Whether to use the modularity as the objective function when `method = \"leiden\"`.\n * By default, the Constant-Potts Model is used instead.\n * Set to `true` to get an interpretation of the resolution on par with that of `method = \"multilevel\"`.\n * @param {number} [options.walktrapSteps=4] - Number of steps for the Walktrap algorithm, when `method = \"walktrap\"`.\n *\n * @return {ClusterSNNGraphMultiLevelResults|ClusterSNNGraphWalktrapResults|ClusterSNNGraphLeidenResults} Object containing the clustering results.\n * The class of this object depends on the choice of `method`.\n */\nexport function clusterSNNGraph(x, { \n    method = \"multilevel\", \n    multiLevelResolution = 1, \n    leidenResolution = 1, \n    leidenModularityObjective = false,\n    walktrapSteps = 4\n} = {}) {\n    var output;\n\n    try {\n        if (method == \"multilevel\") {\n            output = gc.call(\n                module => module.cluster_snn_graph_multilevel(x.graph, multiLevelResolution),\n                ClusterSNNGraphMultiLevelResults\n            );\n        } else if (method == \"walktrap\") {\n            output = gc.call(\n                module => module.cluster_snn_graph_walktrap(x.graph, walktrapSteps),\n                ClusterSNNGraphWalktrapResults\n            );\n        } else if (method == \"leiden\") {\n            output = gc.call(\n                module => module.cluster_snn_graph_leiden(x.graph, leidenResolution, leidenModularityObjective),\n                ClusterSNNGraphLeidenResults\n            );\n        } else {\n            throw new Error(\"unknown method '\" + method + \"'\")\n        }\n    } catch (e) {\n        utils.free(output);\n        throw e;\n    }\n\n    return output;\n}\n\n/**\n * Create an empty {@linkplain ClusterSNNGraphMultiLevelResults} object (or one of its counterparts), to be filled with custom results.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfCells - Number of cells in the dataset.\n * @param {object} [options={}] - Optional parameters.\n * @param {string} [options.method=\"multilevel\"] - Community detection method to use.\n * This should be one of `\"multilevel\"`, `\"walktrap\"` or `\"leiden\"`.\n * @param {number} [options.numberOfLevels=1] - Number of levels for which to allocate space when `method=\"multilevel\"`.\n * @param {number} [options.numberOfMergeSteps=1] - Number of merge steps for which to allocate space when `method=\"walktrap\"`.\n *\n * @return {ClusterSNNGraphMultiLevelResults|ClusterSNNGraphWalktrapResults|ClusterSNNGraphLeidenResults} \n * Object with space allocated to store the clustering results.\n */\nexport function emptyClusterSNNGraphResults(numberOfCells, { method = \"multilevel\", numberOfLevels = 1, numberOfMergeSteps = 1 } = {}) {\n    if (method == \"multilevel\") {\n        return gc.call(\n            module => new module.ClusterSNNGraphMultiLevel_Result(numberOfCells, numberOfLevels),\n            ClusterSNNGraphMultiLevelResults,\n            /* filled = */ false\n        );\n    } else if (method == \"walktrap\") {\n        return gc.call(\n            module => new module.ClusterSNNGraphWalktrap_Result(numberOfCells, numberOfMergeSteps),\n            ClusterSNNGraphWalktrapResults,\n            /* filled = */ false\n        );\n    } else if (method == \"leiden\") {\n        return gc.call(\n            module => new module.ClusterSNNGraphLeiden_Result(numberOfCells),\n            ClusterSNNGraphLeidenResults,\n            /* filled = */ false\n        );\n    } else {\n        throw new Error(\"unknown method '\" + method + \"'\")\n    }\n}\n","import * as wa from \"wasmarrays.js\";\nimport * as utils from \"./utils.js\";\n\n/**\n * Convert an arbitrary array into a R-style factor, with integer indices into an array of levels.\n * This is useful for formatting grouping or blocking vectors for {@linkcode scoreMarkers}, {@linkcode modelGeneVar}, etc.\n *\n * @param {Array|TypedArray} x - Array of values to be converted into a factor.\n * \n * Note that TypedArray views on Wasm-allocated buffers should only be provided if `buffer` is also provided;\n * otherwise, a Wasm memory allocation may invalidate the view.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.asWasmArray=true] - Whether to return an Int32WasmArray instance for the indices.\n * If `false`, an Int32Array is returned instead.\n * Only used if `buffer` is not supplied.\n * @param {?(Int32WasmArray|Int32Array)} [options.buffer=null] - Array in which the output is to be stored.\n * If provided, this should be of length equal to that of `x`.\n * @param {string} [options.action=\"warn\"] - Action to take when invalid values (i.e., null, NaNs) are detected in `x`.\n *\n * - `\"none\"`: the index is silently set to `placeholder`.\n * - `\"warn\"`: a warning is raised on the first occurrence of an invalid value, and the index is set to `placeholder`.\n * - `\"error\"`: an error is raised.\n * \n * @param {number} [options.placeholder=-1] - Placeholder index to use upon detecting invalid values in `x`.\n *\n * @return {object} Object containing:\n *\n * - `ids`: an Int32WasmArray or Int32Array of length equal to `x`, containing the index into `levels` for each cell.\n * - `levels`: an array of unique levels, such that `Array.from(ids).map(i => levels[i])` returns the same contents as `x` (aside from invalid values).\n *\n * If `buffer` was supplied, it is used as the value of the `ids` property.\n */\nexport function convertToFactor(x, { asWasmArray = true, buffer = null, action = \"error\", placeholder = -1 } = {}) {\n    let levels = [];\n    let local_buffer;\n\n    let failure;\n    if (action == \"warn\") {\n        let warned = false;\n        failure = () => {\n            if (!warned) {\n                console.warn (\"replacing invalid values with the placeholder index '\" + String(placeholder) + \"'\");\n                warned = true;\n            }\n        };\n    } else if (action == \"none\") {\n        failure = () => {};\n    } else if (action == \"error\") {\n        failure = () => {\n            throw new Error(\"detected invalid value (e.g., null, NaN) in 'x'\");\n        };\n    } else {\n        throw new Error(\"unknown action '\" + action + \"' for handling invalid entries\");\n    }\n\n    try {\n        if (buffer == null) {\n            local_buffer = (asWasmArray ? utils.createInt32WasmArray(x.length) : new Int32Array(x.length));\n            buffer = local_buffer;\n        } else {\n            if (buffer.length !== x.length) {\n                throw new Error(\"'buffer' should have length equal to that of 'x'\");\n            }\n            asWasmArray = buffer instanceof wa.Int32WasmArray;\n        }\n\n        let barr = (asWasmArray ? buffer.array() : buffer); // no allocations from this point onwards!\n        let mapping = new Map;\n\n        for (var i = 0; i < x.length; i++) {\n            let y = x[i];\n            if (y == null || (typeof y == \"number\" && !Number.isFinite(y))) {\n                failure();\n                barr[i] = placeholder;\n                continue;\n            }\n\n            let existing = mapping.get(y);\n            if (typeof existing == \"undefined\") {\n                let n = levels.length;\n                mapping.set(y, n);\n                levels.push(y);\n                barr[i] = n;\n            } else {\n                barr[i] = existing;\n            }\n        }\n\n    } catch (e) {\n        utils.free(local_buffer);\n        throw e;\n    }\n\n    return {\n        ids: buffer,\n        levels: levels\n    };\n}\n\n// Back-compatible renaming.\nexport function factorize(x, options = {}) {\n    return convertToFactor(x, options);\n}\n\n/**\n * Reindex the factor indices to remove unused levels.\n * This is done by adjusting the indices such that every index from `[0, N)` is represented at least once, where `N` is the number of (used) levels.\n *\n * @param {Int32WasmArray|TypedArray|Array} x - Array of factor indices such as that produced by {@linkcode convertToFactor}. \n *\n * @return {Array} `x` is modified in place to remove unused levels.\n *\n * An array (denoted here as `y`) is returned that represents the mapping between the original and modified IDs,\n * i.e., running `x.map(i => y[i])` will recover the input `x`.\n * This is most commonly used to create a new array of levels, i.e., `y.map(i => old_levels[i])` will drop the unused levels. \n */\nexport function dropUnusedLevels(x) {\n    if (x instanceof wa.WasmArray) {\n        // No more wasm allocations past this point!\n        x = x.array();\n    }\n\n    let uniq = new Set(x);\n    let uniq_arr = Array.from(uniq).sort();\n    let mapping = {};\n    uniq_arr.forEach((y, i) => { mapping[y] = i; });\n\n    x.forEach((y, i) => {\n        x[i] = mapping[y];\n    });\n\n    return uniq_arr;\n}\n\n/**\n * Subset a factor, possibly also dropping its unused levels.\n * This is typically based on the same filtering vector as {@linkcode filterCells}.\n *\n * @param {object} x - An object representing a factor, containing the following properties:\n *\n * - `ids`: An Int32Array or Int32WasmArray of integer indices.\n * - `levels`: An array of levels that can be indexed by entries of `ids`.\n *\n * This is typically produced by {@linkcode convertToFactor}. \n * @param {(Array|TypedArray|WasmArray)} subset - Array specifying the subset to retain or filter out, depending on `filter`.\n *\n * If `filter = null`, the array is expected to contain integer indices specifying the entries in `x` to retain.\n * The ordering of indices in `subset` will be respected in the subsetted array.\n *\n * If `filter = true`, the array should be of length equal to that of `x`.\n * Each value is interpreted as a boolean and, if truthy, indicates that the corresponding entry of `x` should be filtered out.\n *\n * If `filter = false`, the array should be of length equal to that of `x`.\n * Each value is interpreted as a boolean and, if truthy, indicates that the corresponding entry of `x` should be retained.\n *\n * Note that TypedArray views on Wasm-allocated buffers should only be provided if `buffer` is also provided;\n * otherwise, a Wasm memory allocation may invalidate the view.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.drop=true] - Whether to drop unused levels in the output, see {@linkcode dropUnusedLevels}.\n * @param {?boolean} [options.filter=null] - Whether to retain truthy or falsey values in a `subset` boolean filter.\n * If `null`, `subset` should instead contain the indices of elements to retain.\n * @param {?(Int32Array|Int32WasmArray)} [options.buffer=null] - Array in which the output is to be stored, of the same type as `x.ids`.\n * If provided, this should be of length equal to `subset`, if `filter = null`;\n * the number of truthy elements in `subset`, if `filter = false`;\n * or the number of falsey elements in `subset`, if `filter = true`.\n *\n * @return {object} An object like `x`, containing:\n *\n * - `ids`: An Int32Array or Int32WasmArray of integer indices, subsetted from those in `x.ids`.\n * - `levels`: Array of levels that can be indexed by entries of the output `ids`.\n *   If `drop = true`, this may be a subset of `x.levels` where every entry is represented at least once in the output `ids`.\n *\n * If `buffer` is supplied, the returned `ids` will be set to `buffer`.\n */\nexport function subsetFactor(x, subset, { drop = true, filter = null, buffer = null } = {}) {\n    let output = { ids: null, levels: x.levels };\n\n    if (x.ids instanceof wa.WasmArray) {\n        output.ids = wa.subsetWasmArray(x.ids, subset, { filter, buffer });\n    } else {\n        let n = wa.checkSubsetLength(subset, filter, x.length, \"x\");\n        if (buffer == null) {\n            buffer = new x.ids.constructor(n);\n        }\n        wa.fillSubset(subset, filter, x.ids, buffer);\n        output.ids = buffer;\n    }\n\n    if (drop) {\n        let remapping = dropUnusedLevels(output.ids);\n        output.levels = remapping.map(i => x.levels[i]);\n    }\n    return output;\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\n\n/**\n * Filter out low-quality cells.\n *\n * @param {ScranMatrix} x The count matrix.\n * @param {(Uint8WasmArray|Array|TypedArray)} filters \n * An array of length equal to the number of columns in `x`, where truthy elements specify the cells to be discarded.\n *\n * @return {ScranMatrix} A matrix of the same type as `x`, filtered by column to remove all cells specified in `filters`. \n */\nexport function filterCells(x, filters) {\n    var filter_data;\n    var output;\n\n    try {\n        filter_data = utils.wasmifyArray(filters, \"Uint8WasmArray\");\n        if (filter_data.length != x.numberOfColumns()) {\n            throw new Error(\"length of 'filters' must be equal to number of columns in 'x'\");\n        }\n        var ptr = filter_data.offset;\n\n        output = gc.call(\n            module => module.filter_cells(x.matrix, ptr, false),\n            x.constructor\n        );\n\n    } catch(e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(filter_data);\n    }\n\n    return output;\n}\n","import * as utils from \"./utils.js\";\nimport * as gc from \"./gc.js\";\nimport { RunPCAResults } from \"./runPCA.js\";\n\n/** \n * Wrapper for the neighbor search index on the Wasm heap, typically produced by {@linkcode buildNeighborSearchIndex}.\n * @hideconstructor\n */\nexport class BuildNeighborSearchIndexResults {\n    #id;\n    #index; \n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#index = raw;\n        return;\n    }\n\n    /**\n     * @return {number} Number of cells in the index.\n     */\n    numberOfCells() {\n        return this.#index.num_obs();\n    }\n\n    /**\n     * @return {number} Number of dimensions in the index.\n     */\n    numberOfDims() {\n        return this.#index.num_dim();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#index !== null) {\n            gc.release(this.#id);\n            this.#index = null;\n        }\n        return;\n    }\n\n    // Internal only, not documented.\n    get index() {\n        return this.#index;\n    }\n}\n\n/**\n * Build the nearest neighbor search index.\n *\n * @param {(RunPCAResults|Float64WasmArray|Array|TypedArray)} x - Numeric coordinates of each cell in the dataset.\n * For array inputs, this is expected to be in column-major format where the rows are the variables and the columns are the cells.\n * For a {@linkplain RunPCAResults} input, we extract the principal components.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfDims=null] - Number of variables/dimensions per cell.\n * Only used (and required) for array-like `x`.\n * @param {?number} [options.numberOfCells=null] - Number of cells.\n * Only used (and required) for array-like `x`.\n * @param {boolean} [options.approximate=true] - Whether to build an index for an approximate neighbor search.\n *\n * @return {BuildNeighborSearchIndexResults} Index object to use for neighbor searches.\n */\nexport function buildNeighborSearchIndex(x, { numberOfDims = null, numberOfCells = null, approximate = true } = {}) {\n    var buffer;\n    var output;\n\n    try {\n        let pptr;\n\n        if (x instanceof RunPCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            let pcs = x.principalComponents({ copy: false });\n            pptr = pcs.byteOffset;\n\n        } else {\n            if (numberOfDims === null || numberOfCells === null) {\n                throw new Error(\"'numberOfDims' and 'numberOfCells' must be specified when 'x' is an Array\");\n            }\n\n            buffer = utils.wasmifyArray(x, \"Float64WasmArray\");\n            if (buffer.length != numberOfDims * numberOfCells) {\n                throw new Error(\"length of 'x' must be the product of 'numberOfDims' and 'numberOfCells'\");\n            }\n\n            pptr = buffer.offset;\n        }\n\n        output = gc.call(\n            module => module.build_neighbor_index(pptr, numberOfDims, numberOfCells, approximate),\n            BuildNeighborSearchIndexResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(buffer);\n    }\n\n    return output;\n}\n\n/** \n * Wrapper for the neighbor search results on the Wasm heap, typically produced by {@linkcode findNearestNeighbors}.\n * @hideconstructor\n */\nexport class FindNearestNeighborsResults {\n    #id;\n    #results;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#results = raw;\n        return;\n    }\n\n    /**\n     * @return {number} The total number of neighbors across all cells.\n     * This is usually the product of the number of neighbors and the number of cells.\n     */\n    size() {\n        return this.#results.size();\n    }\n\n    /**\n     * @return {number} The number of cells used in the search.\n     */\n    numberOfCells() {\n        return this.#results.num_obs();\n    }\n\n    // Internal use only, not documented.\n    get results() {\n        return this.#results;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?Int32WasmArray} [options.runs=null] - A Wasm-allocated array of length equal to `numberOfCells()`,\n     * to be used to store the number of neighbors per cell.\n     * @param {?Int32WasmArray} [options.indices=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the indices of the neighbors of each cell.\n     * @param {?Float64WasmArray} [options.distances=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the distances to the neighbors of each cell.\n     *\n     * @return {object} \n     * An object is returned with the `runs`, `indices` and `distances` keys, each with an appropriate TypedArray as the value.\n     *\n     * If all of the arguments are non-`null`, the TypedArrays in the returned object are views on the corresponding input WasmArrays.\n     * Note that these views may be invalidated on the next allocation on the Wasm heap.\n     *\n     * If only some of the arguments are non-`null`, an error is raised.\n     */\n    serialize({ runs = null, indices = null, distances = null } = {}) {\n        var copy = (runs === null) + (indices === null) + (distances === null);\n        if (copy != 3 && copy != 0) {\n            throw new Error(\"either all or none of 'runs', 'indices' and 'distances' can be 'null'\");\n        }\n\n        var output;\n\n        if (copy === 3) {\n            var run_data;\n            var ind_data;\n            var dist_data;\n            \n            try {\n                run_data = utils.createInt32WasmArray(this.numberOfCells());\n                let s = this.size();\n                ind_data = utils.createInt32WasmArray(s);\n                dist_data = utils.createFloat64WasmArray(s);\n                this.#results.serialize(run_data.offset, ind_data.offset, dist_data.offset);\n\n                output = { \n                    \"runs\": run_data.slice(), \n                    \"indices\": ind_data.slice(), \n                    \"distances\": dist_data.slice() \n                };\n            } finally {\n                utils.free(run_data);\n                utils.free(ind_data);\n                utils.free(dist_data);\n            }\n\n        } else {\n            this.#results.serialize(runs.offset, indices.offset, distances.offset);\n            output = {\n                \"runs\": runs.array(),\n                \"indices\": indices.array(),\n                \"distances\": distances.array()\n            };\n        }\n\n        return output;\n    }\n\n    /**\n     * @param {Int32WasmArray|Array|TypedArray} runs An array of length equal to `numberOfCells()`,\n     * containing the number of neighbors per cell.\n     * @param {Int32WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the indices of the neighbors of each cell.\n     * @param {Float64WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the distances to the neighbors of each cell.\n     *\n     * @return {FindNearestNeighborsResults} Object containing the unserialized search results.\n     */\n    static unserialize(runs, indices, distances) {\n        var output;\n        var run_data;\n        var ind_data;\n        var dist_data;\n\n        try {\n            run_data = utils.wasmifyArray(runs, \"Int32WasmArray\");\n            ind_data = utils.wasmifyArray(indices, \"Int32WasmArray\");\n            dist_data = utils.wasmifyArray(distances, \"Float64WasmArray\");\n            output = gc.call(\n                module => new module.NeighborResults(runs.length, run_data.offset, ind_data.offset, dist_data.offset),\n                FindNearestNeighborsResults\n            );\n\n        } catch (e) {\n            utils.free(output);\n            throw e;\n\n        } finally { \n            utils.free(run_data);\n            utils.free(ind_data);\n            utils.free(dist_data);\n        }\n\n        return output;\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Find the nearest neighbors for each cell.\n *\n * @param {NeighborSearchIndex} x The neighbor search index built by {@linkcode buildNeighborSearchIndex}.\n * @param {number} k Number of neighbors to find.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {FindNearestNeighborsResults} Object containing the search results.\n */\nexport function findNearestNeighbors(x, k, { numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n    return gc.call(\n        module => module.find_nearest_neighbors(x.index, k, nthreads),\n        FindNearestNeighborsResults\n    );\n}\n","import * as wasm from \"./wasm.js\";\nimport * as utils from \"./utils.js\";\nimport { ScranMatrix } from \"./ScranMatrix.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Compute group-based size factors, where composition biases are removed between groups and library size normalization is performed within groups.\n * This allows us to generate per-cell size factors in spite of the sparsity.\n *\n * @param {ScranMatrix} x The count matrix, usually after filtering.\n * @param {(Int32WasmArray|Array|TypedArray)} groups - Array containing the group assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of groups.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.center=true] - Whether to return centered size factors.\n * If `false`, the size factors can be interpreted as the scaling to match `reference`.\n * @param {?Float64WasmArray} [options.buffer=null] - Output buffer for the size factors.\n * This should have length equal to the number of columns in `x`.\n * @param {number} [options.priorCount=10] - Prior count to use for shrinking size factors towards the relative library size.\n * Larger values result in stronger shrinkage when the coverage is low.\n * @param {?number} [options.reference=null] - Group to use as a reference.\n * This should be an entry in `groups`. \n * If `null`, it is automatically determined.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {Float64WasmArray} Array of length equal to the number of columns in `x`, containing the size factors for all cells.\n *\n * If `buffer` was supplied, it is used as the return value.\n */\nexport function groupedSizeFactors(x, groups, { center = true, buffer = null, priorCount = 10, reference = null, numberOfThreads = null } = {}) {\n    var local_buffer;\n    var group_arr;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        if (!(buffer instanceof wa.Float64WasmArray)) {\n            local_buffer = utils.createFloat64WasmArray(x.numberOfColumns());\n            buffer = local_buffer;\n        } else if (buffer.length !== x.numberOfColumns()) {\n            throw new Error(\"length of 'buffer' must be equal to the number of columns in 'x'\");\n        }\n\n        group_arr = utils.wasmifyArray(groups, \"Int32WasmArray\");\n        if (reference == null) {\n            reference = -1;\n        }\n\n        wasm.call(module => module.grouped_size_factors(x.matrix, group_arr.offset, center, priorCount, reference, buffer.offset, nthreads));\n\n    } catch (e) {\n        utils.free(local_buffer);\n        throw e;\n\n    } finally {\n        utils.free(group_arr);\n    }\n    \n    return buffer;\n}\n","/**\n * Guess the identity of the features from their names.\n *\n * @param {Array} features - Array of strings containing feature identifiers, typically Ensembl IDs or gene symbols.\n * Elements may also be `null` or undefined if an identifier is missing.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceTaxonomy=false] - Whether to force the use of taxonomy IDs for human and mouse.\n * This is `false` for back compatibility.\n *\n * @return {object} An object containing:\n *\n * - `species`, the inferred species as a string.\n *   This can be either `\"human\"` or `\"mouse\"`, or an NCBI taxonomy ID (one of 6239, 10116, 9541, 7227, 7955, 9598).\n *   If `forceTaxonomy = true`, human and mouse are replaced with 9606 and 10090, respectively.\n * - `type`: the feature identifier type.\n *   This can either be `\"ensembl\"` or `\"symbol\"`.\n * - `confidence`: the percentage of entries in `x` that are consistent with the inferred identity.\n */\nexport function guessFeatures(features, { forceTaxonomy = false } = {}) {\n    let ntotal = features.length;\n    let early_threshold = Math.ceil(ntotal / 2);\n    let format = payload => {\n        payload.confidence /= ntotal;\n        return payload;\n    };\n\n    // Duplicated entries only count as one match, so as to avoid problems with\n    // chromosome positions, feature type specifications, etc. Note that we\n    // still need to use the full length to compute 'ntotal', otherwise we\n    // wouldn't be penalizing the duplicates properly.\n    features = new Set(features); \n\n    let ensembl_human = 0;\n    let ensembl_mouse = 0;\n    let ensembl_6239 = 0;\n    let ensembl_10116 = 0; // Ensembl only, Rat symbols are indistiguishable from mice.\n    let ensembl_9541 = 0; // Ensembl only, Mfac symbols are indistiguishable from human.\n    let ensembl_7227 = 0; // Ensembl only, fly symbols are crazy.\n    let ensembl_7955 = 0;\n    let ensembl_9598 = 0; // Ensembl only, Chimp symbols are indistinguishable from human.\n\n    let symbol_human = 0;\n    let symbol_mouse = 0;\n    let symbol_6239 = 0;\n    let symbol_7955 = 0;\n\n    let hsid = (forceTaxonomy ? \"9606\" : \"human\");\n    let mmid = (forceTaxonomy ? \"10090\" : \"mouse\");\n    let collected = [];\n\n    // Checking if it's any type of Ensembl.\n    let any_ens = 0;\n    features.forEach(x => {\n        if (x && x.match(/^ENS[A-Z]*G[0-9]{11}$/)) {\n            any_ens++;\n        }\n    });\n\n    if (any_ens) {\n        features.forEach(x => {\n            if (x) {\n                if (x.startsWith(\"ENSG\")) {\n                    ensembl_human++;\n                } else if (x.startsWith(\"ENSMUSG\")) {\n                    ensembl_mouse++;\n                } else if (x.startsWith(\"ENSRNOG\")) {\n                    ensembl_10116++;\n                } else if (x.startsWith(\"ENSMFAG\")) {\n                    ensembl_9541++;\n                } else if (x.startsWith(\"ENSDARG\")) {\n                    ensembl_7955++;\n                } else if (x.startsWith(\"ENSPTRG\")) {\n                    ensembl_9598++;\n                }\n            }\n        });\n\n        collected.push({ species: hsid, type: \"ensembl\", confidence: ensembl_human });\n        collected.push({ species: mmid, type: \"ensembl\", confidence: ensembl_mouse });\n        collected.push({ species: \"10116\", type: \"ensembl\", confidence: ensembl_10116 });\n        collected.push({ species: \"9541\", type: \"ensembl\", confidence: ensembl_9541 });\n        collected.push({ species: \"7955\", type: \"ensembl\", confidence: ensembl_7955 });\n        collected.push({ species: \"9598\", type: \"ensembl\", confidence: ensembl_9598 });\n\n        // See if we can quit early and avoid the other checks.\n        for (const x of collected) {\n            if (x.confidence >= early_threshold) {\n                return format(x);\n            }\n        }\n    }\n\n    // Human symbol; starts with upper case, no lower case, and not an Ensembl of any kind.\n    features.forEach(x => {\n        if (x && x.match(/^[A-Z][^a-z]+$/) && !x.match(/^ENS[A-Z]+[0-9]{11}/)) {\n            symbol_human++;\n        }\n    });\n    {\n        let payload = { species: hsid, type: \"symbol\", confidence: symbol_human };\n        if (payload.confidence >= early_threshold) {\n            return format(payload);\n        }\n        collected.push(payload);\n    }\n\n    // Mouse symbol; starts with upper case, but no upper case after that.\n    features.forEach(x => {\n        if (x && x.match(/^[A-Z][^A-Z]+$/)) {\n            symbol_mouse++;\n        }\n    });\n    {\n        let payload = { species: mmid, type: \"symbol\", confidence: symbol_mouse };\n        if (payload.confidence >= early_threshold) {\n            return format(payload);\n        }\n        collected.push(payload);\n    }\n\n    // Worm Ensembl (WormBase).\n    features.forEach(x => {\n        if (x && x.match(/^WBGene[0-9]+$/)) {\n            ensembl_6239++;\n        }\n    });\n    {\n        let payload = { species: \"6239\", type: \"ensembl\", confidence: ensembl_6239 };\n        if (payload.confidence >= early_threshold) {\n            return format(payload);\n        }\n        collected.push(payload);\n    }\n\n    // Fly Ensembl (FlyBase).\n    features.forEach(x => {\n        if (x && x.match(/^FBgn[0-9]+$/)) {\n            ensembl_7227++;\n        }\n    });\n    {\n        let payload = { species: \"7227\", type: \"ensembl\", confidence: ensembl_7227 };\n        if (payload.confidence >= early_threshold) {\n            return format(payload);\n        }\n        collected.push(payload);\n    }\n\n    // Worm symbols; at least three lower case with a dash and numbers.\n    features.forEach(x => {\n        if (x && x.match(/^[a-z]{3,}-[0-9]+$/)) {\n            symbol_6239++;\n        }\n    });\n    {\n        let payload = { species: \"6239\", type: \"symbol\", confidence: symbol_6239 };\n        if (payload.confidence >= early_threshold) {\n            return format(payload);\n        }\n        collected.push(payload);\n    }\n\n    // Zebrafish symbols; at least three lower case letters, no dash, followed by numbers and/or more lower case.\n    features.forEach(x => {\n        if (x && x.match(/^[a-z]{3,}[0-9a-z]+$/)) {\n            symbol_7955++;\n        }\n    });\n    {\n        let payload = { species: \"7955\", type: \"symbol\", confidence: symbol_7955 };\n        if (payload.confidence >= early_threshold) {\n            return format(payload);\n        }\n        collected.push(payload);\n    }\n\n    // Picking the best.\n    let highest = collected[0];\n    for (var i = 1; i < collected.length; i++) {\n        if (collected[i].confidence > highest.confidence) {\n            highest = collected[i];\n        }\n    }\n\n    return format(highest);\n}\n","import * as utils from \"./utils.js\";\nimport * as wasm from \"./wasm.js\";\n\n/** \n * Perform a hypergeometric test, typically for over-enrichment of markers across feature sets.\n * This can be computed for multiple feature sets by providing arrays as some or all of the arguments.\n * If multiple arrays are supplied, they must be of the same length.\n *\n * @param {number|Array|TypedArray|WasmArray} markersInSet - Number of detected markers that are also in the feature set.\n * @param {number|Array|TypedArray|WasmArray} numberOfMarkers - Total number of detected markers.\n * @param {number|Array|TypedArray|WasmArray} featureSetSize - Size of the feature set.\n * @param {number|Array|TypedArray|WasmArray} numberOfFeatures - Total number of features.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n * @param {boolean} [options.assumeSorted=false] - Whether the input arrays are already sorted such that `markersInSet` is the slowest-changing value.\n * Setting this to `true` can avoid an extra sorting step for greater efficiency.\n *\n * @return {Float64Array} An array of length equal to that of the supplied arrays (or 1, if no arrays are supplied).\n * The i-th entry contains the p-value for enrichment computed using the i-th entry of each supplied array. \n */\nexport function hypergeometricTest(markersInSet, numberOfMarkers, featureSetSize, numberOfFeatures, { numberOfThreads = null, assumeSorted = false } = {}) {\n    let markersInSet_data;\n    let numberOfMarkers_data;\n    let featureSetSize_data;\n    let numberOfFeatures_data;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    let ntests = null;\n    let check_length = (candidate, name, sofar) => {\n        if (sofar !== null && candidate.length !== sofar) {\n            throw new Error(\"array inputs must have the same length (failing for '\" + name + \"')\");\n        }\n        return candidate.length;\n    }\n\n    if (typeof markersInSet == \"number\") {\n        markersInSet = [markersInSet];\n    } else { \n        ntests = check_length(markersInSet, \"markersInSet\", ntests);\n    }\n\n    if (typeof numberOfMarkers == \"number\") {\n        numberOfMarkers = [numberOfMarkers];\n    } else {\n        ntests = check_length(numberOfMarkers, \"numberOfMarkers\", ntests);\n    }\n\n    if (typeof featureSetSize == \"number\") {\n        featureSetSize = [featureSetSize];\n    } else {\n        ntests = check_length(featureSetSize, \"featureSetSize\", ntests);\n    }\n\n    if (typeof numberOfFeatures == \"number\") {\n        numberOfFeatures = [numberOfFeatures];\n    } else {\n        ntests = check_length(numberOfFeatures, \"numberOfFeatures\", ntests);\n    }\n\n    if (ntests == null) {\n        ntests = 1;\n    }\n\n    let output;\n    let output_data;\n\n    try {\n        markersInSet_data = utils.wasmifyArray(markersInSet, \"Int32WasmArray\");\n        numberOfMarkers_data = utils.wasmifyArray(numberOfMarkers, \"Int32WasmArray\");\n        featureSetSize_data = utils.wasmifyArray(featureSetSize, \"Int32WasmArray\");\n        numberOfFeatures_data = utils.wasmifyArray(numberOfFeatures, \"Int32WasmArray\");\n        output_data = utils.createFloat64WasmArray(ntests);\n\n        wasm.call(module => module.hypergeometric_test(\n            ntests, \n            markersInSet_data.length != 1,\n            markersInSet_data.offset,\n            featureSetSize_data.length != 1,\n            featureSetSize_data.offset,\n            numberOfMarkers_data.length != 1,\n            numberOfMarkers_data.offset,\n            numberOfFeatures_data.length != 1,\n            numberOfFeatures_data.offset,\n            assumeSorted,\n            output_data.offset,\n            nthreads\n        ));\n\n        output = output_data.slice();\n\n    } finally {\n        utils.free(markersInSet_data);\n        utils.free(numberOfMarkers_data);\n        utils.free(featureSetSize_data);\n        utils.free(numberOfFeatures_data);\n        utils.free(output_data);\n    }\n\n    return output;\n}\n","import * as gc from \"./gc.js\";\nimport * as wasm from \"./wasm.js\";\nimport * as utils from \"./utils.js\"; \nimport { ScranMatrix } from \"./ScranMatrix.js\";\n\n/**\n * Initialize a sparse matrix from a dense array.\n *\n * @param {number} numberOfRows Number of rows in the matrix.\n * @param {number} numberOfColumns Number of columns in the matrix.\n * @param {WasmArray|Array|TypedArray} values Values of all elements in the matrix, stored in column-major order.\n * This is generally expected to contain non-negative integers; otherwise, users should set `forceInteger = false`.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceInteger=true] - Whether to coerce `values` to integers via truncation.\n * @param {boolean} [options.layered=true] - Whether to create a layered sparse matrix, which reorders the rows of the loaded matrix for better memory efficiency.\n * Only used if `values` contains an integer type and/or `forceInteger = true`.\n * Setting to `true` assumes that `values` contains only non-negative integers.\n *\n * @return {object} An object containing:\n * - `matrix`, a {@linkplain ScranMatrix} containing the sparse matrix data.\n *   If layering is enabled, rows are shuffled to enable use of smaller integer types for low-abundance features.\n * - `row_ids`, an Int32Array specifying the identity of each row in `matrix`.\n *   This can be interpreted as the row slicing that was applied to the original matrix to obtain `matrix`.\n *   If layering is not enabled, this is `null`.\n *\n * Layering is enabled if the matrix contains integer data (either directly or via `forceInteger = true`) and `layered = true`.\n */\nexport function initializeSparseMatrixFromDenseArray(numberOfRows, numberOfColumns, values, { forceInteger = true, layered = true } = {}) {\n    var val_data; \n    var output;\n    var ids = null; \n\n    try {\n        val_data = utils.wasmifyArray(values, null);\n        if (val_data.length !== numberOfRows * numberOfColumns) {\n            throw new Error(\"length of 'values' is not consistent with supplied dimensions\");\n        }\n\n        output = gc.call(\n            module => module.initialize_sparse_matrix_from_dense_vector(\n                numberOfRows, \n                numberOfColumns, \n                val_data.offset, \n                val_data.constructor.className.replace(\"Wasm\", \"\"),\n                forceInteger,\n                layered\n            ),\n            ScranMatrix\n        );\n\n        if (output.isReorganized()) {\n            ids = output.identities();\n            output.wipeIdentities();\n        }\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(val_data);\n    }\n\n    return { \"matrix\": output, \"row_ids\": ids };\n}\n\n/**\n * Initialize a sparse matrix from its compressed components.\n *\n * @param {number} numberOfRows Number of rows in the matrix.\n * @param {number} numberOfColumns Number of columns in the matrix.\n * @param {WasmArray} values Values of the non-zero elements.\n * This is generally expected to contain non-negative integers; otherwise, users should set `forceInteger = false`.\n * @param {WasmArray} indices Row indices of the non-zero elements.\n * This should be of the same length as `values`.\n * @param {WasmArray} pointers Pointers specifying the start of each column in `indices`.\n * This should have length equal to `numberOfColumns + 1`.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.byColumn=true] - Whether the input arrays are supplied in the compressed sparse column format.\n * If `true`, `indices` should contain column indices and `pointers` should specify the start of each row in `indices`.\n * @param {boolean} [options.forceInteger=true] - Whether to coerce `values` to integers via truncation.\n * @param {boolean} [options.layered=true] - Whether to create a layered sparse matrix, which reorders the rows of the loaded matrix for better memory efficiency.\n * Only used if `values` contains an integer type and/or `forceInteger = true`.\n * Setting to `true` assumes that `values` contains only non-negative integers.\n *\n * @return {object} An object containing:\n * - `matrix`, a {@linkplain ScranMatrix} containing the sparse matrix data.\n *   If layering is enabled, rows are shuffled to enable use of smaller integer types for low-abundance features.\n * - `row_ids`, an Int32Array specifying the identity of each row in `matrix`. \n *   This can be interpreted as the row slicing that was applied to the original matrix to obtain `matrix`.\n *   If layering is not enabled, this is `null`.\n * \n * Layering is enabled if the matrix contains integer data (either directly or via `forceInteger = true`) and `layered = true`.\n */ \nexport function initializeSparseMatrixFromCompressedVectors(numberOfRows, numberOfColumns, values, indices, pointers, { byColumn = true, forceInteger = true, layered = true } = {}) {\n    var val_data;\n    var ind_data;\n    var indp_data;\n    var output;\n    var ids = null;\n\n    try {\n        val_data = utils.wasmifyArray(values, null);\n        ind_data = utils.wasmifyArray(indices, null);\n        indp_data = utils.wasmifyArray(pointers, null);\n        if (val_data.length != ind_data.length) {\n            throw new Error(\"'values' and 'indices' should have the same length\");\n        }\n        if (indp_data.length != (byColumn ? numberOfColumns : numberOfRows) + 1) {\n            throw new Error(\"'pointers' does not have an appropriate length\");\n        }\n\n        output = gc.call(\n            module => module.initialize_sparse_matrix(\n                numberOfRows, \n                numberOfColumns, \n                val_data.length, \n                val_data.offset, \n                val_data.constructor.className.replace(\"Wasm\", \"\"), \n                ind_data.offset, \n                ind_data.constructor.className.replace(\"Wasm\", \"\"), \n                indp_data.offset, \n                indp_data.constructor.className.replace(\"Wasm\", \"\"), \n                byColumn,\n                forceInteger,\n                layered\n            ),\n            ScranMatrix\n        );\n\n        if (output.isReorganized()) {\n            ids = output.identities();\n            output.wipeIdentities();\n        }\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(val_data);\n        utils.free(ind_data);\n        utils.free(indp_data);\n    }\n\n    return { \"matrix\": output, \"row_ids\": ids };\n}\n\n/** \n * Initialize a sparse matrix from a buffer containing a MatrixMarket file.\n *\n * @param {Uint8WasmArray|Array|TypedArray|string} buffer Byte array containing the contents of a Matrix Market file with non-negative counts.\n * This can be raw text or Gzip-compressed.\n * \n * Alternatively, this can be a string containing a file path to a MatrixMarket file.\n * On browsers, this should be a path in the virtual filesystem, typically created with {@linkcode writeFile}. \n * @param {object} [options={}] - Optional parameters.\n * @param {?boolean} [options.compressed=null] - Whether the buffer is Gzip-compressed.\n * If `null`, we detect this automatically from the magic number in the header.\n * @param {boolean} [options.layered=true] - Whether to create a layered sparse matrix, which reorders the rows of the loaded matrix for better memory efficiency.\n *\n * @return {object} An object containing:\n * - `matrix`, a {@linkplain ScranMatrix} containing the sparse matrix data.\n *   If `layered = true`, rows are shuffled to enable use of smaller integer types for low-abundance features.\n * - `row_ids`, an Int32Array specifying the identity of each row in `matrix`. \n *   This can be interpreted as the row slicing that was applied to the original matrix to obtain `matrix`.\n *   If `layered = false`, this is `null`.\n */\nexport function initializeSparseMatrixFromMatrixMarket(x, { compressed = null, layered = true } = {}) {\n    var buf_data;\n    var output;\n    var ids = null;\n\n    try {\n        compressed = convert_compressed(compressed);\n        if (typeof x !== \"string\") {\n            buf_data = utils.wasmifyArray(x, \"Uint8WasmArray\");\n            output = gc.call(\n                module => module.read_matrix_market_from_buffer(buf_data.offset, buf_data.length, compressed, layered),\n                ScranMatrix\n            );\n        } else {\n            output = gc.call(\n                module => module.read_matrix_market_from_file(x, compressed, layered),\n                ScranMatrix\n            );\n        }\n\n        if (output.isReorganized()) {\n            ids = output.identities();\n            output.wipeIdentities();\n        }\n\n    } catch(e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(buf_data);\n    }\n\n    return { \"matrix\": output, \"row_ids\": ids };\n}\n\nfunction convert_compressed(compressed) {\n    if (compressed === null) {\n        return -1;\n    } else if (compressed) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n/** \n * Extract dimensions and other details from a MatrixMarket file.\n *\n * @param {Uint8WasmArray|Array|TypedArray|string} buffer Byte array containing the contents of a Matrix Market file with non-negative counts.\n * This can be raw text or Gzip-compressed.\n * \n * Alternatively, this can be a string containing a file path to a MatrixMarket file.\n * On browsers, this should be a path in the virtual filesystem, typically created with {@linkcode writeFile}. \n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.compressed=null] - Whether the buffer is Gzip-compressed.\n * If `null`, we detect this automatically from the magic number in the header.\n *\n * @return {object} An object containing the number of `rows`, `columns` and `lines` in the matrix.\n */\nexport function extractMatrixMarketDimensions(x, { compressed = null } = {}) {\n    var buf_data;\n    var stats = utils.createFloat64WasmArray(3);\n    let output = {};\n\n    try {\n        compressed = convert_compressed(compressed);\n        if (typeof x !== \"string\") {\n            buf_data = utils.wasmifyArray(x, \"Uint8WasmArray\");\n            wasm.call(module => module.read_matrix_market_header_from_buffer(buf_data.offset, buf_data.length, compressed, stats.offset));\n        } else {\n            wasm.call(module => module.read_matrix_market_header_from_file(x, compressed, stats.offset));\n        }\n\n        let sarr = stats.array();\n        output.rows = sarr[0];\n        output.columns = sarr[1];\n        output.lines = sarr[2];\n\n    } finally {\n        utils.free(buf_data);\n        utils.free(stats);\n    }\n\n    return output;\n}\n\n/**\n * Initialize a layered sparse matrix from a HDF5 file.\n *\n * @param {string} file Path to the HDF5 file.\n * For browsers, the file should have been saved to the virtual filesystem.\n * @param {string} name Name of the dataset inside the file.\n * This can be a HDF5 Dataset for dense matrices or a HDF5 Group for sparse matrices.\n * For the latter, both H5AD and 10X-style sparse formats are supported.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceInteger=true] - Whether to coerce all elements to integers via truncation.\n * @param {boolean} [options.layered=true] - Whether to create a layered sparse matrix, which reorders the rows of the loaded matrix for better memory efficiency.\n * Only used if the relevant HDF5 dataset contains an integer type and/or `forceInteger = true`.\n * Setting to `true` assumes that the matrix contains only non-negative integers.\n *\n * @return {object} An object containing:\n * - `matrix`, a {@linkplain ScranMatrix} containing the sparse matrix data.\n *   If layering is enabled, rows are shuffled to enable use of smaller integer types for low-abundance features.\n * - `row_ids`, an Int32Array specifying the identity of each row in `matrix`. \n *   This can be interpreted as the row slicing that was applied to the original matrix to obtain `matrix`.\n *   If layering is not enabled, this is `null`.\n *\n * Layering is enabled if the matrix contains integer data (either directly or via `forceInteger = true`) and `layered = true`.\n */\nexport function initializeSparseMatrixFromHDF5(file, name, { forceInteger = true, layered = true } = {}) {\n    var ids = null;\n    var output;\n\n    try {\n        output = gc.call(\n            module => module.read_hdf5_matrix(file, name, forceInteger, layered),\n            ScranMatrix\n        );\n\n        if (output.isReorganized()) {\n            ids = output.identities();\n            output.wipeIdentities();\n        }\n\n    } catch(e) {\n        utils.free(output);\n        throw e;\n    }\n\n    return { \"matrix\": output, \"row_ids\": ids };\n}\n\n/**\n * Extract the format and dimensions of a HDF5 matrix.\n *\n * @param {string} file Path to the HDF5 file.\n * For browsers, the file should have been saved to the virtual filesystem.\n * @param {string} name Name of the dataset inside the file.\n * This can be a HDF5 Dataset for dense matrices or a HDF5 Group for sparse matrices.\n * For the latter, both H5AD and 10X-style sparse formats are supported.\n *\n * @return {object} An object containing:\n * - `rows`, the number of rows in the matrix.\n * - `columns`, the number of columns.\n * - `format`, whether the matrix is dense, CSR or CSC.\n * - `integer`, whether the matrix data is stored as integers or doubles.\n */\nexport function extractHDF5MatrixDetails(file, name) { \n    let output = {};\n    let arr = utils.createInt32WasmArray(5);\n    try {\n        wasm.call(module => module.extract_hdf5_matrix_details(file, name, arr.offset));\n\n        let vals = arr.array();\n        if (vals[0] > 0) {\n            output.format = \"dense\";\n        } else if (vals[1] > 0) {\n            output.format = \"csc\";\n        } else {\n            output.format = \"csr\";\n        }\n\n        output.rows = vals[2];\n        output.columns = vals[3];\n        output.integer = vals[4] > 0;\n    } finally {\n        arr.free();\n    }\n    return output;\n}\n\n/**\n * Initialize a dense matrix from a column-major array.\n *\n * @param {number} numberOfRows - Number of rows.\n * @param {number} numberOfColumns - Number of columns.\n * @param {(WasmArray|TypedArray|Array)} values - Array of length equal to the product of `numberOfRows` and `numberOfColumns`,\n * containing the values to store in the array.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceInteger=true] - Whether to coerce `values` to integers via truncation.\n *\n * @return {ScranMatrix} A dense matrix, filled by column with the contents of `values`.\n */\nexport function initializeDenseMatrixFromDenseArray(numberOfRows, numberOfColumns, values, { forceInteger = false } = {}) {\n    var tmp;\n    var output;\n\n    try {\n        tmp = utils.wasmifyArray(values, null);\n        output = gc.call(\n            module => module.initialize_dense_matrix(\n                numberOfRows, \n                numberOfColumns, \n                tmp.offset, \n                tmp.constructor.className.replace(\"Wasm\", \"\"),\n                forceInteger\n            ),\n            ScranMatrix\n        );\n    } catch (e) {\n        utils.free(output);\n        throw e;\n    } finally {\n        utils.free(tmp);\n    }\n\n    return output;\n}\n\n/**\n * Initialize a layered sparse matrix from an RDS file.\n *\n * @param {RdsObject} x - Handle to an object inside an RDS file.\n * This should be an integer/numeric matrix, `dgCMatrix` or `dgTMatrix` object.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.consume=false] - Whether to consume the values in `x` when creating the output sparse matrix.\n * Setting this to `true` improves memory efficiency at the cost of preventing any further use of `x`.\n * @param {boolean} [options.forceInteger=true] - Whether to coerce all elements to integers via truncation.\n * @param {boolean} [options.layered=true] - Whether to create a layered sparse matrix, which reorders the rows of the loaded matrix for better memory efficiency.\n * Only used if the R matrix is of an integer type and/or `forceInteger = true`.\n * Setting to `true` assumes that the matrix contains only non-negative integers.\n *\n * @return {object} An object containing:\n * - `matrix`, a {@linkplain ScranMatrix} containing the sparse matrix data.\n *   If layering is enabled, rows are shuffled to enable use of smaller integer types for low-abundance features.\n * - `row_ids`, an Int32Array specifying the identity of each row in `matrix`. \n *   This can be interpreted as the row slicing that was applied to the original matrix to obtain `matrix`.\n *   If layering is not enabled, this is `null`.\n *\n * Layering is enabled if the matrix contains integer data (either directly or via `forceInteger = true`) and `layered = true`.\n */\nexport function initializeSparseMatrixFromRds(x, { consume = false, forceInteger = true, layered = true } = {}) {\n    var ids = null;\n    var output;\n\n    try {\n        output = gc.call(\n            module => module.initialize_sparse_matrix_from_rds(x.object.$$.ptr, forceInteger, layered, consume),\n            ScranMatrix\n        );\n\n        if (output.isReorganized()) {\n            ids = output.identities();\n            output.wipeIdentities();\n        }\n\n    } catch(e) {\n        utils.free(output);\n        throw e;\n    }\n\n    return { \"matrix\": output, \"row_ids\": ids };\n}\n","import * as utils from \"./../utils.js\";\nimport * as wasm from \"../wasm.js\";\n\nexport function computePerCellQcFilters(metrics, block, run) {\n    var block_data;\n    var output;\n\n    try {\n        var bptr = 0;\n        var use_blocks = false;\n\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != metrics.numberOfCells()) {\n                throw new Error(\"'block' must be of length equal to the number of cells in 'metrics'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        output = run(metrics, use_blocks, bptr);\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(block_data);\n    }\n\n    return output;\n}\n\nexport function applyFilter(thresholds, metrics, block, buffer) {\n    var block_data;\n    var rebuffer;\n    var output;\n\n    try {\n        var bptr = 0;\n        var use_blocks = false;\n\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != metrics.numberOfCells()) {\n                throw new Error(\"'block' must be of length equal to the number of cells in 'metrics'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        let optr;\n        if (buffer == null) {\n            rebuffer = utils.createUint8WasmArray(metrics.numberOfCells());\n            optr = rebuffer.offset;\n        } else {\n            if (buffer.length != metrics.numberOfCells()) {\n                throw new Error(\"'buffer' must be of length equal to the number of cells in 'metrics'\");\n            }\n            optr = buffer.offset;\n        }\n\n        wasm.call(module => thresholds.filter(metrics.results.$$.ptr, use_blocks, bptr, optr));\n        if (buffer == null) {\n            output = rebuffer.slice();\n        } else {\n            output = buffer.array();\n        }\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(block_data);\n        utils.free(rebuffer);\n    }\n\n    return output;\n}\n\n","import * as wasm from \"../wasm.js\";\nimport * as utils from \"../utils.js\"; \nimport * as wa from \"wasmarrays.js\";\n\nexport function computePerCellQcMetrics(x, subsets, run) {\n    var output;\n    var tmp_subsets = [];\n    var subset_offsets;\n\n    try {\n        let nsubsets = 0;\n        let offset_offset = 0;\n\n        if (subsets != null) {\n            nsubsets = subsets.length;\n            subset_offsets = utils.createBigUint64WasmArray(nsubsets);\n            offset_offset = subset_offsets.offset;\n            let offset_arr = subset_offsets.array();\n\n            for (var i = 0; i < nsubsets; i++) {\n                // This will either create a cheap view, or it'll clone\n                // 'subsets' into the appropriate memory space.\n                let current = utils.wasmifyArray(subsets[i], \"Uint8WasmArray\");\n                if (current.length != x.numberOfRows()) {\n                    throw new Error(\"length of each array in 'subsets' should be equal to the matrix rows\");\n                }\n                tmp_subsets.push(current);\n                offset_arr[i] = BigInt(current.offset);\n            }\n        }\n\n        output = run(x.matrix, nsubsets, offset_offset);\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(subset_offsets);\n        for (const y of tmp_subsets) {\n            utils.free(y);\n        }\n    }\n\n    return output;\n}\n","import * as utils from \"../utils.js\";\n\nexport function unpack_strings(buffer, lengths) {\n    let dec = new TextDecoder();\n    let names = [];\n    let sofar = 0;\n    for (const l of lengths) {\n        let view = buffer.slice(sofar, sofar + l);\n        names.push(dec.decode(view));\n        sofar += l;\n    }\n    return names;\n}\n\nexport function repack_strings(x) {\n    let buffer;\n    let lengths;\n\n    for (const y of x) {\n        if (!(typeof y == \"string\")) {\n            throw new Error(\"all entries of 'x' should be strings for a string HDF5 dataset\");\n        }\n    }\n\n    try {\n        lengths = utils.createInt32WasmArray(x.length);\n        let lengths_arr = lengths.array();\n\n        let total = 0;\n        const enc = new TextEncoder;\n        let contents = new Array(x.length);\n\n        x.forEach((y, i) => {\n            let e = enc.encode(y);\n            lengths_arr[i] = e.length;\n            contents[i] = e;\n            total += e.length;\n        });\n\n        buffer = utils.createUint8WasmArray(total);\n        let buffer_arr = buffer.array();\n        total = 0;\n\n        contents.forEach(y => {\n            buffer_arr.set(y, total);\n            total += y.length;\n        });\n    } catch (e) {\n        utils.free(buffer);\n        utils.free(lengths);\n        throw e;\n    }\n\n    return [lengths, buffer];\n}\n","import * as gc from \"./gc.js\";\nimport * as wasm from \"./wasm.js\";\nimport * as utils from \"./utils.js\";\nimport { ScranMatrix } from \"./ScranMatrix.js\";\nimport * as wa from \"wasmarrays.js\";\nimport * as init from \"./initializeSparseMatrix.js\";\n\n/**************************************************\n **************************************************/\n\n/**\n * Wrapper around a labelled reference dataset on the Wasm heap, typically produced by {@linkcode loadLabelledReferenceFromBuffers}.\n * @hideconstructor\n */\nclass LoadLabelledReferenceResults {\n    #id;\n    #reference;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#reference = raw;\n        return;\n    }\n\n    // Internal use only, not documented.\n    get reference() {\n        return this.#reference;\n    }\n\n    /**\n     * @return {number} Number of samples in this dataset.\n     */\n    numberOfSamples() {\n        return this.#reference.num_samples();\n    }\n\n    /**\n     * @return {number} Number of features in this dataset.\n     */\n    numberOfFeatures() {\n        return this.#reference.num_features();\n    }\n\n    /**\n     * @return {number} Number of labels in this dataset.\n     */\n    numberOfLabels() {\n        return this.#reference.num_labels();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#reference !== null) {\n            gc.release(this.#id);\n            this.#reference = null;\n        }\n    }\n}\n\n/**\n * Load a reference dataset for annotation.\n * \n * @param {Uint8Array} ranks - Buffer containing the Gzipped CSV file containing a matrix of ranks.\n * Each line corresponds to a sample and contains a comma-separated vector of ranks across all features.\n * All lines should contain the same number of entries.\n * This is effectively a row-major matrix where rows are samples and columns are features.\n * (Advanced users may note that this is transposed in C++.) \n * @param {Uint8Array} markers - Buffer containing the Gzipped GMT file containing the markers for each pairwise comparison between labels.\n * For `markers`, the GMT format is a tab-separated file with possibly variable numbers of fields for each line.\n * Each line corresponds to a pairwise comparison between labels, defined by the first two fields.\n * The remaining fields should contain indices of marker features (referring to columns of `matrix`) that are upregulated in the first label when compared to the second.\n * Markers should be sorted in order of decreasing strength.\n * @param {Uint8Array} labels - Buffer containing the Gzipped text file containing the label for each sample.\n * Each line should contain an integer representing a particular label, from `[0, N)` where `N` is the number of unique labels.\n * The number of lines should be equal to the number of rows in `matrix`.\n * The actual names of the labels are usually held elsewhere.\n * \n * @return {LoadLabelledReferenceResults} Object containing the reference dataset.\n */\nexport function loadLabelledReferenceFromBuffers(ranks, markers, labels) {\n    var output;\n    var matbuf;\n    var markbuf;\n    var labbuf;\n\n    try {\n        matbuf = utils.wasmifyArray(ranks, \"Uint8WasmArray\");\n        markbuf = utils.wasmifyArray(markers, \"Uint8WasmArray\");\n        labbuf = utils.wasmifyArray(labels, \"Uint8WasmArray\");\n        output = gc.call(\n            module => module.load_singlepp_reference(labbuf.offset, labbuf.length, markbuf.offset, markbuf.length, matbuf.offset, matbuf.length),\n            LoadLabelledReferenceResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(matbuf);\n        utils.free(markbuf);\n        utils.free(labbuf);\n    }\n\n    return output;\n}\n\n/**\n * Wrapper around a built labelled reference dataset on the Wasm heap, typically produced by {@linkcode buildLabelledReference}.\n * @hideconstructor\n */\nclass BuildLabelledReferenceResults {\n    #id;\n    #reference;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#reference = raw;\n        return;\n    }\n\n    // internal use only.\n    get reference() {\n        return this.#reference;\n    }\n\n    /**\n     * @return {number} Number of shared features between the test and reference datasets.\n     */\n    sharedFeatures() {\n        return this.#reference.shared_features();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#reference !== null) {\n            gc.release(this.#id);\n            this.#reference = null;\n        }\n    }\n}\n\nfunction register_features(features, id_array) {\n    let registry_contents = new Map;\n\n    // All features in the data are guaranteed to get the a unique ID,\n    // but only non-null and non-duplicated (or the first of a duplicate set)\n    // are actually registered.\n    for (var i = 0; i < features.length; i++) {\n        let id = features[i];\n        if (id !== null) {\n            if (!registry_contents.has(id)) {\n                registry_contents.set(id, i);\n            }\n        }\n        id_array[i] = i;\n    }\n\n    return { contents: registry_contents, counter: features.length };\n}\n\nfunction convert_features(features, registry, id_array) {  \n    let used = new Set;\n    let set = (id, index) => {\n        let found = registry.contents.get(id);\n        if (typeof found !== \"undefined\") {\n            if (!used.has(found)) { // if entries of 'features' match to the same ID, only the first entry gets to match to the ID.\n                id_array[index] = found;\n                used.add(found);\n                return true;\n            }\n        }\n        return false;\n    };\n\n    let counter = registry.counter;\n    for (var i = 0; i < features.length; i++) {\n        let y = features[i];\n        let found = false;\n\n        if (y !== null) {\n            if (y instanceof Array) {\n                for (const z of y) {\n                    if (set(z, i)) { // if an entry of 'features' has multiple names, the first matching name wins.\n                        found = true;\n                        break;\n                    }\n                }\n            } else {\n                found = set(y, i);\n            }\n        }\n\n        // If something isn't found, they get a unique ID.\n        if (!found) {\n            id_array[i] = counter;\n            ++counter;\n        }\n    }\n\n    return;\n}\n\n/**\n * Build the reference dataset for annotation.\n * The build process involves harmonizing the identities of the features available in the test dataset compared to the reference.\n * Specifically, a feature must be present in both datasets in order to be retained. \n * Of those features in the intersection, only the `top` markers from each pairwise comparison are ultimately used for classification.\n *\n * Needless to say, `features` should match up to the rows of the {@linkplain ScranMatrix} that is actually used for annotation in {@linkcode labelCells}.\n *\n * @param {Array} features - An array of feature identifiers (usually strings) of length equal to the number of rows in the test matrix.\n * Each entry should contain the identifier for the corresponding row of the test matrix.\n * Any `null` entries are considered to be incomparable.\n * If any identifiers are duplicated, only the first occurrence is used and the rest are ignored.\n * @param {LoadLabelledReferenceResults} loaded - A reference dataset, typically loaded with {@linkcode loadLabelledReferenceFromBuffers}.\n * @param {Array} referenceFeatures - An array of feature identifiers (usually strings) of length equal to the number of features in `reference`.\n * Each entry may also be an array of synonymous identifiers, in which case the first identifier that matches to an entry of `features` is used.\n * Contents of `referenceFeatures` are expected to exhibit some overlap with identifiers in `features`.\n * Any `null` entries are considered to be incomparable.\n * If multiple entries of `referenceFeatures` match to the same feature in `features`, only the first matching entry is used and the rest are ignored.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.top=20] - Number of top marker features to use.\n * These features are taken from each pairwise comparison between labels.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {BuildLabelledReferenceResults} Object containing the built reference dataset.\n */\nexport function buildLabelledReference(features, loaded, referenceFeatures, { top = 20, numberOfThreads = null } = {}) {\n    var mat_id_buffer;\n    var ref_id_buffer;\n    var output;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        var nfeat = features.length;\n        mat_id_buffer = utils.createInt32WasmArray(nfeat);\n        ref_id_buffer = utils.createInt32WasmArray(loaded.numberOfFeatures());\n        if (referenceFeatures.length != ref_id_buffer.length) {\n            throw new Error(\"length of 'referenceFeatures' should be equal to the number of features in 'reference'\");\n        }\n\n        let registry = register_features(features, mat_id_buffer.array());\n        convert_features(referenceFeatures, registry, ref_id_buffer.array());\n\n        output = gc.call(\n            module => module.build_singlepp_reference(nfeat, mat_id_buffer.offset, loaded.reference, ref_id_buffer.offset, top, nthreads),\n            BuildLabelledReferenceResults\n        );\n\n        output.expectedNumberOfFeatures = nfeat;\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(mat_id_buffer);\n        utils.free(ref_id_buffer);\n    }\n\n    return output;\n}\n\n/**************************************************\n **************************************************/\n\n/**\n * Wrapper around the cell labelling results on the Wasm heap, typically produced by {@linkcode labelCells}.\n * @hideconstructor\n */\nclass LabelCellsResults {\n    #id;\n    #results;\n    #cell_buffer;\n    #label_buffer;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#results = raw;\n        return;\n    }\n\n    /**\n     * @return {number} Number of labels used in {@linkcode labelCells}.\n     */\n    numberOfLabels() {\n        return this.#results.num_labels();\n    }\n\n    /**\n     * @return {number} Number of cells that were labelled.\n     */\n    numberOfCells() {\n        return this.#results.num_samples();\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     *\n     * @return {Int32Array|Int32WasmArray} Array of length equal to the number of cells,\n     * containing the index of the best label for each cell.\n     */\n    predictedLabels({ copy = true } = {}) {\n        return utils.possibleCopy(this.#results.get_best(), copy);\n    }\n\n    /**\n     * @param {number} i - Index of the cell of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     * Only used if `buffer` is not supplied.\n     * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output.\n     * This should have the same length as the {@linkcode LabelCellsResults#numberOfLabels numberOfLabels}.\n     *\n     * @return {Float64Array|Float64WasmArray} Array containing the scores for this cell across all labels.\n     * If `buffer` is supplied, it is used as the return value.\n     */\n    scoresForCell(i, { copy = true, buffer = null } = {}) {\n        if (buffer == null) {\n            if (typeof this.#cell_buffer == \"undefined\") {\n                this.#cell_buffer = utils.createFloat64WasmArray(this.#results.num_labels());\n            }\n            this.#results.get_scores_for_sample(i, this.#cell_buffer.offset);\n            return utils.possibleCopy(this.#cell_buffer.array(), copy);\n        } else {\n            if (buffer.length !== this.#results.num_labels()) {\n                throw new Error(\"length of 'buffer' should equal the number of labels\");\n            }\n            this.#results.get_scores_for_sample(i, buffer.offset);\n            return buffer;\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the label of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     * Only used if `buffer` is not supplied.\n     * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output.\n     * This should have the same length as the {@linkcode LabelCellsResults#numberOfCells numberOfCells}.\n     *\n     * @return {Float64Array|Float64WasmArray} Array containing the scores across all cells for this label.\n     * If `buffer` is supplied, it is used as the return value.\n     */\n    scoresForLabel(i, { copy = true, buffer = null } = {}) {\n        if (buffer == null) {\n            if (typeof this.#label_buffer == \"undefined\") {\n                this.#label_buffer = utils.createFloat64WasmArray(this.#results.num_samples());\n            }\n            this.#results.get_scores_for_label(i, this.#label_buffer.offset);\n            return utils.possibleCopy(this.#label_buffer.array(), copy);\n        } else {\n            if (buffer.length !== this.#results.num_samples()) {\n                throw new Error(\"length of 'buffer' should equal the number of cells\");\n            }\n            this.#results.get_scores_for_label(i, buffer.offset);\n            return utils.possibleCopy(this.#label_buffer.array(), copy);\n        }\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     *\n     * @return {Float64Array|Float64WasmArray} Array of length equal to the number of cells,\n     * containing the difference in scores between the best and second-best label during fine-tuning.\n     */\n    fineTuningDelta({ copy = true } = {}) {\n        return utils.possibleCopy(this.#results.get_delta(), copy);\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n\n            utils.free(this.#label_buffer);\n            utils.free(this.#cell_buffer);\n        }\n    }\n}\n\nfunction label_cells(x, expectedNumberOfFeatures, numberOfFeatures, numberOfCells, FUN, msg) {\n    var output = null;\n    var matbuf;\n    var tempmat;\n\n    try {\n        let target;\n        if (x instanceof ScranMatrix) {\n            target = x.matrix;\n        } else if (x instanceof wa.Float64WasmArray) {\n            tempmat = init.initializeDenseMatrixFromDenseArray(numberOfFeatures, numberOfCells, x, { forceInteger: false });\n            target = tempmat.matrix;\n        } else {\n            throw new Error(\"unknown type for 'x'\");\n        }\n\n        if (target.nrow() != expectedNumberOfFeatures) {\n            throw new Error(\"number of rows in 'x' should be equal to length of 'features' used to build '\" + msg + \"'\");\n        }\n\n        output = FUN(target);\n\n    } finally {\n        utils.free(matbuf);\n        utils.free(tempmat);\n    }\n\n    return output;\n}\n\n/**\n * Label cells based on similarity in expression to a reference dataset.\n *\n * @param {(ScranMatrix|Float64WasmArray)} x - The count matrix, or log-normalized matrix, containing features in the rows and cells in the columns.\n * If a Float64WasmArray is supplied, it is assumed to contain a column-major dense matrix.\n * @param {BuildLabelledReferenceResults} reference - A built reference dataset, typically generated by {@linkcode buildLabelledReference}.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfFeatures=null] - Number of features, used when `x` is a Float64WasmArray.\n * @param {?number} [options.numberOfCells=null] - Number of cells, used when `x` is a Float64WasmArray.\n * @param {number} [options.quantile=0.8] - Quantile on the correlations to use to compute the score for each label.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {LabelCellsResults} Labelling results for each cell in `x`.\n */\nexport function labelCells(x, reference, { numberOfFeatures = null, numberOfCells = null, quantile = 0.8, numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n    let FUN = (target, ptr) => {\n        return gc.call(module => module.run_singlepp(target, reference.reference, quantile, nthreads), LabelCellsResults);\n    };\n    return label_cells(x, reference.expectedNumberOfFeatures, numberOfFeatures, numberOfCells, FUN, \"reference\");\n}\n\n/**************************************************\n **************************************************/\n\n/**\n * Wrapper around integrated reference datasets on the Wasm heap, typically produced by {@linkcode integrateLabelledReferences}.\n * @hideconstructor\n */\nclass IntegrateLabelledReferencesResults {\n    #id;\n    #integrated;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#integrated = raw;\n        return;\n    }\n\n    // Internal use only, not documented.\n    get integrated() {\n        return this.#integrated;\n    }\n\n    /**\n     * @return {number} Number of reference datasets.\n     */\n    numberOfReferences() {\n        return this.#integrated.num_references();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#integrated !== null) {\n            gc.release(this.#id);\n            this.#integrated = null;\n        }\n    }\n}\n\n/**\n * Integrate multiple reference datasets.\n *\n * @param {Array} features - An array of feature identifiers (usually strings) of length equal to the number of rows in the test matrix.\n * Each entry should contain a single identifier for the corresponding row of the test matrix.\n * Any `null` entries are considered to be incomparable.\n * If any entries are duplicated, only the first occurrence is used and the rest are ignored.\n * @param {Array} loaded - Array of {@linkplain LabelledReference} objects, typically created with {@linkcode loadLabelledReferenceFromBuffers}.\n * @param {Array} referenceFeatures - Array of length equal to `loaded`, \n * containing arrays of feature identifiers (usually strings) of length equal to the number of features the corresponding entry of `loaded`.\n * Each entry may also be an array of synonymous identifiers, in which case the first identifier that matches to an entry of `features` is used.\n * Contents of `referenceFeatures` are expected to exhibit some overlap with identifiers in `features`.\n * Any `null` entries are considered to be incomparable.\n * If multiple entries of `referenceFeatures` match to the same feature in `features`, only the first matching entry is used and the rest are ignored.\n * @param {Array} reference - Array of {@linkplain BuildLabelledReferenceResults} objects, typically generated by calling {@linkcode buildLabelledReference} \n * on the same `features` and the corresponding entries of `loaded` and `referenceFeatures`.\n * This should have length equal to that of `loaded`.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {IntegrateLabelledReferencesResults} Object containing the integrated references.\n */\nexport function integrateLabelledReferences(features, loaded, referenceFeatures, built, { numberOfThreads = null } = {}) {\n    let id_arr;\n    let loaded_arr2;\n    let ref_arr2;\n    let built_arr2;\n    let output;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    // Checking the inputs.\n    let nrefs = loaded.length;\n    if (referenceFeatures.length != nrefs) {\n        throw new Error(\"'loaded' and 'referenceFeatures' should be of the same length\");\n    }\n    if (built.length != nrefs) {\n        throw new Error(\"'loaded' and 'built' should be of the same length\");\n    }\n    for (var i = 0; i < nrefs; i++) {\n        if (loaded[i].numberOfFeatures() != referenceFeatures[i].length) {\n            throw new Error(\"length of each 'referenceFeatures' should be equal to the number of features in the corresponding 'loaded'\");\n        }\n    }\n\n    let ref_arr = new Array(nrefs);\n    try {\n        id_arr = utils.createInt32WasmArray(features.length);\n        let registry = register_features(features, id_arr.array());\n\n        loaded_arr2 = utils.createBigUint64WasmArray(nrefs);\n        let la2 = loaded_arr2.array();\n        for (var i = 0; i < nrefs; i++) {\n            la2[i] = BigInt(loaded[i].reference.$$.ptr);\n        }\n\n        ref_arr2 = utils.createBigUint64WasmArray(nrefs);\n        let ra2 = ref_arr2.array();\n        for (var i = 0; i < nrefs; i++) {\n            let current = referenceFeatures[i];\n            ref_arr[i] = utils.createInt32WasmArray(current.length);\n            convert_features(current, registry, ref_arr[i].array());\n            ra2[i] = BigInt(ref_arr[i].offset);\n        }\n\n        built_arr2 = utils.createBigUint64WasmArray(nrefs);\n        let ba2 = built_arr2.array();\n        for (var i = 0; i < nrefs; i++) {\n            ba2[i] = BigInt(built[i].reference.$$.ptr);\n        }\n        \n        output = gc.call(\n            module => module.integrate_singlepp_references(\n                features.length,\n                id_arr.offset,\n                nrefs,\n                loaded_arr2.offset,\n                ref_arr2.offset,\n                built_arr2.offset,\n                nthreads\n            ),\n            IntegrateLabelledReferencesResults\n        );\n\n        output.expectedNumberOfFeatures = features.length;\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(id_arr);\n        utils.free(loaded_arr2);\n        utils.free(built_arr2);\n        utils.free(ref_arr2);\n        for (const x of ref_arr) {\n            utils.free(x);\n        }\n    }\n\n    return output;\n}\n\n/**\n * Wrapper around the integrated cell labelling results on the Wasm heap, typically produced by {@linkcode labelCells}.\n * @hideconstructor\n */\nclass IntegrateCellLabelsResults {\n    #results;\n\n    constructor(raw) {\n        this.#results = raw;\n        return;\n    }\n\n    /**\n     * @return {number} Number of labels used in {@linkcode integrateCellLabels}.\n     */\n    numberOfReferences() {\n        return this.#results.numberOfLabels();\n    }\n\n    /**\n     * @return {number} Number of cells that were labelled.\n     */\n    numberOfCells() {\n        return this.#results.numberOfCells();\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     *\n     * @return {Int32Array|Int32WasmArray} Array of length equal to the number of cells,\n     * containing the index of the best reference for each cell.\n     */\n    predictedReferences({ copy = true } = {}) {\n        return utils.possibleCopy(this.#results.predictedLabels(), copy);\n    }\n\n    /**\n     * @param {number} i - Index of the cell of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     * Only used if `buffer` is not supplied.\n     * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output.\n     * This should have the same length as the {@linkcode LabelCellsResults#numberOfLabels numberOfLabels}.\n     *\n     * @return {Float64Array|Float64WasmArray} Array containing the scores for this cell across all references.\n     * If `buffer` is supplied, it is used as the return value.\n     */\n    scoresForCell(i, { copy = true, buffer = null } = {}) {\n        return this.#results.scoresForCell(i, { copy, buffer });\n    }\n\n    /**\n     * @param {number} i - Index of the reference of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     * Only used if `buffer` is not supplied.\n     * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output.\n     * This should have the same length as the {@linkcode LabelCellsResults#numberOfCells numberOfCells}.\n     *\n     * @return {Float64Array|Float64WasmArray} Array containing the scores across all cells for this label.\n     * If `buffer` is supplied, it is used as the return value.\n     */\n    scoresForReference(i, { copy = true, buffer = null } = {}) {\n        return this.#results.scoresForLabel(i, { copy, buffer });\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     *\n     * @return {Float64Array|Float64WasmArray} Array of length equal to the number of cells,\n     * containing the difference in scores between the best and second-best reference during fine-tuning.\n     */\n    fineTuningDelta({ copy = true } = {}) {\n        return utils.possibleCopy(this.#results.fineTuningDelta(), copy);\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            this.#results.free();\n            this.#results = null;\n        }\n    }\n}\n\n/**\n * Integrate cell labels across multiple reference datasets.\n *\n * @param {(ScranMatrix|Float64WasmArray)} x - The count matrix, or log-normalized matrix, containing features in the rows and cells in the columns.\n * If a Float64WasmArray is supplied, it is assumed to contain a column-major dense matrix.\n * @param {IntegratedLabelledReferences} integrated - An integrated set of reference datasets, typically generated by {@linkcode integrateLabelledReferences}.\n * @param {Array} assigned - An array of length equal to the number of references in `integrated`.\n * This should contain the result of classification of `x` with each individual reference via {@linkcode labelCells}.\n * Each element should be a {@linkplain LabelCells} object; or an Array, TypedArray or Int32WasmArray of length equal to the number of cells in `x`.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfFeatures=null] - Number of features, used when `x` is a Float64WasmArray.\n * @param {?number} [options.numberOfCells=null] - Number of cells, used when `x` is a Float64WasmArray.\n * @param {number} [options.quantile=0.8] - Quantile on the correlations to use to compute the score for each label.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {LabelCellsResults} Integrated labelling results for each cell in `x`.\n */\nexport function integrateCellLabels(x, assigned, integrated, { numberOfFeatures = null, numberOfCells = null, quantile = 0.8, numberOfThreads = null } = {}) { \n    let nrefs = integrated.numberOfReferences();\n    if (assigned.length != nrefs) {\n        throw new Error(\"length of 'assigned' should be equal to the number of references in 'integrated'\");\n    }\n\n    let output;\n    let aptrs;\n    let assigned_arrs = new Array(nrefs);\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        aptrs = utils.createBigUint64WasmArray(nrefs);\n        let aptrs_arr = aptrs.array();\n        for (var i = 0; i < assigned.length; i++) {\n            let current = assigned[i];\n\n            if (current instanceof LabelCellsResults) {\n                current = current.predictedLabels({ copy: \"view\" });\n            }\n\n            let fail = false;\n            if (x instanceof ScranMatrix) {\n                if (current.length != x.numberOfColumns()) {\n                    fail = true;\n                }\n            } else if (current.length != numberOfCells) {\n                fail = true;\n            }\n            if (fail) {\n                throw new Error(\"length of each element in 'assigned' should be equal to number of columns in 'x'\");\n            }\n\n            assigned_arrs[i] = utils.wasmifyArray(current, \"Int32WasmArray\");\n            aptrs_arr[i] = BigInt(assigned_arrs[i].offset);\n        }\n    \n        let FUN = (target, ptr) => {\n            return gc.call(module => module.integrate_singlepp(target, aptrs_arr.offset, integrated.integrated, quantile, nthreads), LabelCellsResults);\n        };\n        output = label_cells(x, integrated.expectedNumberOfFeatures, numberOfFeatures, numberOfCells, FUN, \"integrated\");\n\n    } finally{\n        utils.free(aptrs);\n        for (const x of assigned_arrs) {\n            utils.free(x);\n        }\n    }\n\n    return new IntegrateCellLabelsResults(output);\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\nimport * as wa from \"wasmarrays.js\";\nimport * as wasm from \"./wasm.js\";\n\n/**\n * Compute log-transformed normalized expression values.\n *\n * @param {ScranMatrix} x The count matrix, usually after filtering.\n * @param {object} [options={}] - Optional parameters.\n * @param {?(Float64WasmArray|Array|TypedArray)} [options.sizeFactors=null] - Array of positive numbers containing the size factor for each cell in `x`.\n * This should have length equal to the number of columns in `x`.\n * If `null`, size factors are computed from the column sums of `x`.\n * @param {boolean} [options.center=true] - Whether to center the size factors so that the normalized expression values are comparable in magnitude to the input counts.\n * Set this to `false` if `sizeFactors` are provided and already centered, e.g., with {@linkcode centerSizeFactors}.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to adjust the scaling of cells in different blocks, to avoid excessive up-scaling of low-coverage blocks.\n *\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n *\n * This option is ignored if `center = false`, in which case it is assumed that scaling has already been provided in the input `sizeFactors`.\n * @param {boolean} [options.allowZeros=false] - Whether size factors of zero should be allowed.\n * If `true`, no scaling normalization is performed for the corresponding cells, under the assumption they are all-zero libraries.\n * If `false`, an error is raised instead.\n *\n * @return {ScranMatrix} A matrix of the same type as `x` containing log-transformed normalized expression values.\n */\nexport function logNormCounts(x, { sizeFactors = null, center = true, block = null, allowZeros = false } = {}) {\n    var sf_data;\n    var block_data;\n    var output;\n\n    try {\n        var sfptr = 0;\n        var use_sf = false;\n\n        if (sizeFactors !== null) {\n            sf_data = utils.wasmifyArray(sizeFactors, \"Float64WasmArray\");\n            if (sf_data.length != x.numberOfColumns()) {\n                throw new Error(\"length of 'sizeFactors' must be equal to number of columns in 'x'\");\n            }\n            sfptr = sf_data.offset;\n            use_sf = true;\n        }\n\n        var bptr = 0;\n        var use_blocks = false;\n\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != x.numberOfColumns()) {\n                throw new Error(\"'block' must be of length equal to the number of columns in 'x'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        output = gc.call(\n            module => module.log_norm_counts(x.matrix, use_sf, sfptr, use_blocks, bptr, center, allowZeros),\n            x.constructor\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(sf_data);\n        utils.free(block_data);\n    }\n    \n    return output;\n}\n\n/**\n * Center size factors in preparation for log-transformation.\n * This is usually called by {@linkcode logNormCounts} internally, but can also be directly called by users to reconstitute the size factors used in the log-normalized matrix.\n *\n * @param {TypedArray|WasmArray} sizeFactors - Array of non-negative size factors, one per cell.\n * @param {object} [options={}] - Optional parameters.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell, see {@linkcode logNormCounts}.\n * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output size factors.\n * Length should be equal to that of `sizeFactors`.\n * If `null`, an array is allocated by the function.\n *\n * @return {Float64WasmArray} Array containing the centered size factors.\n * If `buffer` is provided, it is returned directly.\n */\nexport function centerSizeFactors(sizeFactors, { block = null, buffer = null } = {}) {\n    let local_buffer;\n    let block_data;\n\n    try {\n        if (buffer === null) {\n            local_buffer = utils.createFloat64WasmArray(sizeFactors.length);\n            buffer = local_buffer;\n        }\n\n        if (buffer !== sizeFactors) {\n            buffer.set(sizeFactors instanceof wa.WasmArray ? sizeFactors.array() : sizeFactors);\n        }\n\n        var bptr = 0;\n        var use_blocks = false;\n\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != buffer.length) {\n                throw new Error(\"'block' must be of length equal to that of 'sizeFactors'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        wasm.call(module => module.center_size_factors(buffer.length, buffer.offset, use_blocks, bptr));\n\n    } catch(e) {\n        utils.free(local_buffer);\n        throw e;\n\n    } finally {\n        utils.free(block_data);\n    }\n\n    return buffer;\n}\n","import * as utils from \"./utils.js\";\nimport { RunPCAResults } from \"./runPCA.js\";\nimport * as wasm from \"./wasm.js\";\n\n/**\n * Perform mutual nearest neighbor (MNN) correction on a low-dimensional representation.\n * This is primarily used to remove batch effects.\n *\n * @param {(RunPCAResults|TypedArray|Array|Float64WasmArray)} x - A matrix of low-dimensional results where rows are dimensions and columns are cells.\n * If this is a {@linkplain RunPCAResults} object, the PCs are automatically extracted.\n * Otherwise, the matrix should be provided as an array in column-major form, with specification of `numberOfDims` and `numberOfCells`.\n * @param {(Int32WasmArray|Array|TypedArray)} block - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to perform normalization within each block.\n * @param {object} [options={}] - Further optional parameters.\n * @param {?Float64WasmArray} [options.buffer=null] - Buffer of length equal to the product of the number of cells and dimensions,\n * to be used to store the corrected coordinates for each cell.\n * If `null`, this is allocated and returned by the function.\n * @param {?number} [options.numberOfDims=null] - Number of dimensions in `x`.\n * This should be specified if an array-like object is provided, otherwise it is ignored.\n * @param {?number} [options.numberOfCells=null] - Number of cells in `x`.\n * This should be specified if an array-like object is provided, otherwise it is ignored.\n * @param {number} [options.k=15] - Number of neighbors to use in the MNN search. \n * @param {number} [options.numberOfMADs=3] - Number of MADs to use to define the threshold on the distances to the neighbors,\n * see comments [here](https://ltla.github.io/CppMnnCorrect).\n * @param {number} [options.robustIterations=2] - Number of robustness iterations to use for computing the center of mass,\n * see comments [here](https://ltla.github.io/CppMnnCorrect).\n * @param {number} [options.robustTrim=0.25] - Proportion of furthest observations to remove during robustness iterations, \n * see comments [here](https://ltla.github.io/CppMnnCorrect).\n * @param {string} [options.referencePolicy=\"max-rss\"] - What policy to use to choose the first reference batch.\n * This can be the largest batch (`\"max-size\"`), the most variable batch (`\"max-variance\"`), the batch with the highest RSS (`\"max-rss\"`) or batch 0 in `block` (`\"input\"`).\n * @param {boolean} [options.approximate=true] - Whether to perform an approximate nearest neighbor search.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {Float64WasmArray} Array of length equal to `x`, containing the batch-corrected low-dimensional coordinates for all cells.\n * Values are organized using the column-major layout.\n * This is equal to `buffer` if provided.\n */\nexport function mnnCorrect(x, block, { \n    buffer = null, \n    numberOfDims = null,\n    numberOfCells = null,\n    k = 15,\n    numberOfMADs = 3, \n    robustIterations = 2, \n    robustTrim = 0.25,\n    referencePolicy = \"max-rss\",\n    approximate = true,\n    numberOfThreads = null\n} = {}) {\n\n    let local_buffer;\n    let x_data;\n    let block_data;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        if (x instanceof RunPCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            x = x.principalComponents({ copy: \"view\" });\n        } else {\n            if (numberOfDims === null || numberOfCells === null || numberOfDims * numberOfCells !== x.length) {\n                throw new Error(\"length of 'x' must be equal to the product of 'numberOfDims' and 'numberOfCells'\");\n            }\n            x_data = utils.wasmifyArray(x, \"Float64WasmArray\");\n            x = x_data;\n        }\n\n        if (buffer == null) {\n            local_buffer = utils.createFloat64WasmArray(numberOfCells * numberOfDims);\n            buffer = local_buffer;\n        } else if (buffer.length !== x.length) {\n            throw new Error(\"length of 'buffer' must be equal to the product of the number of dimensions and cells\");\n        }\n\n        block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n        if (block_data.length != numberOfCells) {\n            throw new Error(\"'block' must be of length equal to the number of cells in 'x'\");\n        }\n\n        wasm.call(module => module.mnn_correct(\n            numberOfDims, \n            numberOfCells,\n            x.offset,\n            block_data.offset,\n            buffer.offset,\n            k,\n            numberOfMADs,\n            robustIterations,\n            robustTrim,\n            referencePolicy,\n            approximate,\n            nthreads\n        ));\n\n    } catch (e) {\n        utils.free(local_buffer);\n        throw e;\n        \n    } finally {\n        utils.free(x_data);\n    }\n\n    return buffer; \n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\n\n/**\n * Wrapper for the variance modelling results, produced by {@linkcode modelGeneVar}.\n * @hideconstructor\n */\nexport class ModelGeneVarResults {\n    #id;\n    #results;\n\n    #filledMeans;\n    #filledVariances;\n    #filledFitted;\n    #filledResiduals;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledMeans = utils.spawnArray(this.numberOfBlocks() + 1, filled);\n        this.#filledVariances = utils.spawnArray(this.numberOfBlocks() + 1, filled);\n        this.#filledFitted = utils.spawnArray(this.numberOfBlocks() + 1, filled);\n        this.#filledResiduals = utils.spawnArray(this.numberOfBlocks() + 1, filled);\n\n        return;\n    }\n\n    #extract(block, copy, fillable, fillcheck, method) {\n        let fillindex = block;\n        if (block == null) {\n            let nblocks = this.numberOfBlocks();\n            fillindex = (nblocks > 1 ? nblocks : 0);\n            block = -1;\n        }\n\n        return utils.checkFillness(\n            fillable, \n            copy, \n            fillcheck[fillindex], \n            () => { fillcheck[fillindex] = true }, \n            COPY => utils.possibleCopy(this.#results[method](block), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.block=null] - Number of the block for which to extract statistics.\n     * If `null`, the average across all blocks is returned.\n     * Otherwise, should be less than the value returned by {@linkcode ModelGeneVarResults#numberOfBlocks numberOfBlocks}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the mean log-expression across all cells in the specified `block`\n     * (or the average across all blocks, if `block < 0`).\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    means({ block = null, copy = true, fillable = false } = {}) {\n        return this.#extract(block, copy, fillable, this.#filledMeans, \"means\");\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.block=null] - Number of the block for which to extract statistics.\n     * If `null`, the average across all blocks is returned.\n     * Otherwise, should be less than the value returned by {@linkcode ModelGeneVarResults#numberOfBlocks numberOfBlocks}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the variance of log-expression across all cells in the specified `block`\n     * (or the average across all blocks, if `block < 0`).\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    variances({ block = null, copy = true, fillable = false } = {}) {\n        return this.#extract(block, copy, fillable, this.#filledVariances, \"variances\");\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.block=null] - Number of the block for which to extract statistics.\n     * If `null`, the average across all blocks is returned.\n     * Otherwise, should be less than the value returned by {@linkcode ModelGeneVarResults#numberOfBlocks numberOfBlocks}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {Float64Array|Float64WasmArray} Array of length equal to the number of genes,\n     * containing the fitted value of the mean-variance trend for the specified `block`\n     * (or the average across all blocks, if `block < 0`).\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    fitted({ block = null, copy = true, fillable = false } = {}) {\n        return this.#extract(block, copy, fillable, this.#filledFitted, \"fitted\");\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.block=null] - Number of the block for which to extract statistics.\n     * If `null`, the average across all blocks is returned.\n     * Otherwise, should be less than the value returned by {@linkcode ModelGeneVarResults#numberOfBlocks numberOfBlocks}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {Float64Array|Float64WasmArray} Array of length equal to the number of genes,\n     * containing the residuals from the mean-variance trend for the specified `block`\n     * (or the average across all blocks, if `block < 0`).\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    residuals({ block = null, copy = true, fillable = false } = {}) {\n        return this.#extract(block, copy, fillable, this.#filledResiduals, \"residuals\");\n    }\n\n    /**\n     * @return {number} Number of blocks used.\n     */\n    numberOfBlocks() {\n        return this.#results.num_blocks();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Model the mean-variance trend across genes.\n *\n * @param {ScranMatrix} x - The normalized log-expression matrix.\n * @param {object} [options={}] - Optional parameters.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to fit the mean-variance trend within each block.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n * @param {number} [options.span=0.3] - Span to use for the LOWESS trend fitting.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {ModelGeneVarResults} Object containing the variance modelling results.\n */\nexport function modelGeneVar(x, { block = null, span = 0.3, numberOfThreads = null } = {}) {\n    var block_data;\n    var output;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        var bptr = 0;\n        var use_blocks = false;\n\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != x.numberOfColumns()) {\n                throw new Error(\"'block' must be of length equal to the number of columns in 'x'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        output = gc.call(\n            module => module.model_gene_var(x.matrix, use_blocks, bptr, span, nthreads),\n            ModelGeneVarResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(block_data);\n    }\n    \n    return output;\n}\n\n/**\n * Create an empty {@linkplain ModelGeneVarResults} object, to be filled with custom results.\n * This is typically used to generate a convenient input into later {@linkcode chooseHVGs} calls.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfGenes - Number of genes in the dataset.\n * @param {number} numberOfBlocks - Number of blocks in the dataset.\n *\n * @return {ModelGeneVarResults} Object with allocated memory to store variance modelling statistics, but no actual values.\n */\nexport function emptyModelGeneVarResults(numberOfGenes, numberOfBlocks) {\n    return gc.call(\n        module => new module.ModelGeneVar_Results(numberOfGenes, numberOfBlocks),\n        ModelGeneVarResults,\n        /* filled = */ false\n    );\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\"; \nimport * as internal from \"./internal/computePerCellQcMetrics.js\";\n\n/**\n * Wrapper for the ADT-based metrics allocated on the Wasm heap, typically produced by {@linkcode computePerCellAdtQcMetrics}.\n * @hideconstructor\n */\nexport class PerCellAdtQcMetricsResults {\n    #id;\n    #results;\n\n    #filledSums;\n    #filledDetected;\n    #filledSubsetTotals;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledSums = filled;\n        this.#filledDetected = filled;\n        this.#filledSubsetTotals = utils.spawnArray(this.numberOfSubsets(), filled);\n\n        return;\n    }\n\n    // Internal use only, not documented.\n    get results() {\n        return this.#results;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the total ADT count for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    sums({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSums, \n            () => { this.#filledSums = true }, \n            COPY => utils.possibleCopy(this.#results.sums(), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the total number of detected ADT features for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    detected({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledDetected, \n            () => { this.#filledDetected = true }, \n            COPY => utils.possibleCopy(this.#results.detected(), COPY)\n        );\n    }\n\n    /**\n     * @param {number} i - Index of the feature subset of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {?boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the total count in the ADT subset `i` for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    subsetTotals(i, { copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSubsetTotals[i], \n            () => { this.#filledSubsetTotals[i] = true }, \n            COPY => utils.possibleCopy(this.#results.subset_totals(i), COPY)\n        );\n    }\n\n    /**\n     * @return {number} Number of feature subsets in this object.\n     */\n    numberOfSubsets() {\n        return this.#results.num_subsets();\n    }\n\n    /**\n     * @return {number} Number of cells in this object.\n     */\n    numberOfCells() {\n        return this.#results.num_cells();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Compute the per-cell QC metrics from an ADT count matrix.\n *\n * @param {ScranMatrix} x - The ADT count matrix.\n * @param {?Array} subsets - Array of arrays of boolean values specifying the feature subsets.\n * Each internal array corresponds to a subset and should be of length equal to the number of rows.\n * Each entry of each internal array specifies whether the corresponding row of `x` belongs to that subset; \n * any value interpretable as a boolean can be used here.\n * \n * Alternatively, each internal array may be any TypedArray or TypedWasmArray.\n * Each array should be of length equal to the number of rows and values are interpreted as booleans.\n *\n * Alternatively `null`, which is taken to mean that there are no subsets.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {PerCellAdtQcMetricsResults} Object containing the ADT-based QC metrics.\n */\nexport function perCellAdtQcMetrics(x, subsets, { numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n    return internal.computePerCellQcMetrics(\n        x, \n        subsets, \n        (matrix, nsubsets, subset_offset) => gc.call(\n            module => module.per_cell_adt_qc_metrics(matrix, nsubsets, subset_offset, nthreads),\n            PerCellAdtQcMetricsResults\n        )\n    );\n}\n\n/**\n * Create an empty {@linkplain PerCellAdtQcMetricsResults} object, to be filled with custom results.\n * This is typically used to generate a convenient input into later {@linkcode computePerCellAdtQcFilters} calls.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfCells - Number of cells in the dataset.\n * @param {number} numberOfSubsets - Number of feature subsets.\n *\n * @return {PerCellAdtQcMetricsResults} Object with allocated memory but no actual values.\n */\nexport function emptyPerCellAdtQcMetricsResults(numberOfCells, numberOfSubsets) {\n    return gc.call(\n        module => new module.PerCellAdtQcMetrics_Results(numberOfCells, numberOfSubsets),\n        PerCellAdtQcMetricsResults,\n        /* filled = */ false \n    );\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\"; \n\n/**\n * Wrapper for the CRISPR-based metrics allocated on the Wasm heap, produced by {@linkcode perCellCrisprQcMetrics}.\n * @hideconstructor\n */\nexport class PerCellCrisprQcMetricsResults {\n    #id;\n    #results;\n\n    #filledSums;\n    #filledDetected;\n    #filledMaxProportions;\n    #filledMaxIndex;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledSums = filled;\n        this.#filledDetected = filled;\n        this.#filledMaxProportions = filled;\n        this.#filledMaxIndex = filled;\n\n        return;\n    }\n\n    // Internal use only, not documented.\n    get results() {\n        return this.#results;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the total count across guides for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    sums({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSums, \n            () => { this.#filledSums = true }, \n            COPY => utils.possibleCopy(this.#results.sums(), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the total number of detected guides for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    detected({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledDetected, \n            () => { this.#filledDetected = true }, \n            COPY => utils.possibleCopy(this.#results.detected(), COPY),\n            \"detected\"\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the proportion of counts in the most abundant guide for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    maxProportions({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledMaxProportions, \n            () => { this.#filledMaxProportions = true }, \n            COPY => utils.possibleCopy(this.#results.max_proportion(), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the index of the most abundant guide for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    maxIndex({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledMaxIndex, \n            () => { this.#filledMaxIndex = true }, \n            COPY => utils.possibleCopy(this.#results.max_index(), COPY),\n            \"maxIndex\"\n        );\n    }\n\n    /**\n     * @return {number} Number of cells in this object.\n     */\n    numberOfCells() {\n        return this.#results.num_cells();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Compute per-cell QC metrics from the CRISPR guide count matrix.\n *\n * @param {ScranMatrix} x - The count matrix for CRISPR guides.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {PerCellCrisprQcMetricsResults} Object containing the QC metrics.\n */\nexport function perCellCrisprQcMetrics(x, { numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n    return gc.call(\n        module => module.per_cell_crispr_qc_metrics(x.matrix, nthreads),\n        PerCellCrisprQcMetricsResults\n    );\n}\n\n/**\n * Create an empty {@linkplain PerCellCrisprQcMetricsResults} object, to be filled with custom results.\n * This is typically used to generate a convenient input into later {@linkcode suggestCrisprQcFilters} calls.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfCells - Number of cells in the dataset.\n *\n * @return {PerCellCrisprQcMetricsResults} Object with allocated memory to store QC metrics, but no actual values.\n */\nexport function emptyPerCellCrisprQcMetricsResults(numberOfCells) {\n    return gc.call(\n        module => new module.PerCellCrisprQcMetrics_Results(numberOfCells),\n        PerCellCrisprQcMetricsResults,\n        /* filled = */ false \n    );\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\"; \nimport * as internal from \"./internal/computePerCellQcMetrics.js\";\n\n/**\n * Wrapper for the RNA-based metrics allocated on the Wasm heap, produced by {@linkcode perCellRnaQcMetrics}.\n * @hideconstructor\n */\nexport class PerCellRnaQcMetricsResults {\n    #id;\n    #results;\n\n    #filledSums;\n    #filledDetected;\n    #filledSubsetProportions;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledSums = filled;\n        this.#filledDetected = filled;\n        this.#filledSubsetProportions = utils.spawnArray(this.numberOfSubsets(), filled);\n\n        return;\n    }\n\n    // Internal use only, not documented.\n    get results() {\n        return this.#results;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the total count across genes for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    sums({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSums, \n            () => { this.#filledSums = true }, \n            COPY => utils.possibleCopy(this.#results.sums(), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the total number of detected genes for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    detected({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledDetected, \n            () => { this.#filledDetected = true }, \n            COPY => utils.possibleCopy(this.#results.detected(), COPY)\n        );\n    }\n\n    /**\n     * @param {number} i - Index of the feature subset of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the proportion of counts in the subset `i` for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    subsetProportions(i, { copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSubsetProportions[i], \n            () => { this.#filledSubsetProportions[i] = true }, \n            COPY => utils.possibleCopy(this.#results.subset_proportions(i), COPY)\n        );\n    }\n\n    /**\n     * @return {number} Number of feature subsets in this object.\n     */\n    numberOfSubsets() {\n        return this.#results.num_subsets();\n    }\n\n    /**\n     * @return {number} Number of cells in this object.\n     */\n    numberOfCells() {\n        return this.#results.num_cells();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Compute per-cell QC metrics from the RNA count matrix.\n *\n * @param {ScranMatrix} x - The RNA count matrix for genes.\n * @param {?Array} subsets - Array of arrays of boolean values specifying the feature subsets.\n * Each internal array corresponds to a subset and should be of length equal to the number of rows.\n * Each entry of each internal array specifies whether the corresponding row of `x` belongs to that subset; \n * any value interpretable as a boolean can be used here.\n * \n * Alternatively, each internal array may be any TypedArray or TypedWasmArray.\n * Each array should be of length equal to the number of rows and values are interpreted as booleans.\n *\n * Alternatively `null`, which is taken to mean that there are no subsets.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {PerCellRnaQcMetricsResults} Object containing the QC metrics.\n */\nexport function perCellRnaQcMetrics(x, subsets, { numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n     return internal.computePerCellQcMetrics(\n        x, \n        subsets, \n        (matrix, nsubsets, subset_offset) => gc.call(\n            module => module.per_cell_rna_qc_metrics(matrix, nsubsets, subset_offset, nthreads),\n            PerCellRnaQcMetricsResults\n        )\n    );\n}\n\n/**\n * Create an empty {@linkplain PerCellRnaQcMetricsResults} object, to be filled with custom results.\n * This is typically used to generate a convenient input into later {@linkcode suggestRnaQcFilters} calls.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfCells - Number of cells in the dataset.\n * @param {number} numberOfSubsets - Number of feature subsets.\n *\n * @return {PerCellRnaQcMetricsResults} Object with allocated memory to store QC metrics, but no actual values.\n */\nexport function emptyPerCellRnaQcMetricsResults(numberOfCells, numberOfSubsets) {\n    return gc.call(\n        module => new module.PerCellRnaQcMetrics_Results(numberOfCells, numberOfSubsets),\n        PerCellRnaQcMetricsResults,\n        /* filled = */ false \n    );\n}\n","import { clusterKmeans } from \"./clusterKmeans.js\";\nimport { logNormCounts } from \"./logNormCounts.js\";\nimport { groupedSizeFactors } from \"./groupedSizeFactors.js\";\nimport { runPCA } from \"./runPCA.js\";\nimport * as utils from \"./utils.js\";\n\n/**\n * Quickly compute size factors for an ADT count matrix.\n * This generates k-means clusters from a matrix of PCs before calling {@linkcode groupedSizeFactors}.\n * The aim is to account for composition biases that are common in ADT-based data, while avoiding problems with per-cell sparsity.\n *\n * @param {ScranMatrix} x - An ADT count matrix.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfClusters=20] - Number of clusters to create.\n * More clusters improves the accuracy of the size factors at the cost of precision.\n * @param {number} [options.numberOfPCs=25] - Number of PCs to use.\n * More PCs captures more biological signal at the cost of increasing noise.\n * @param {?(Float64WasmArray|Array|TypedArray)} [options.totals=null] - Array containing the total count for each column in `x`, to speed up the initial normalization.\n * If `null`, this is computed from `x`.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Blocking level for each column in `x`, see {@linkcode logNormCounts} and {@linkcode runPCA}.\n * For PCA, this is used to equalize the contribution of blocks of differing size.\n * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output size factors.\n * Length should be equal to the number of columns in `x`.\n * If `null`, an array is allocated by the function.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n * \n * @return {Float64WasmArray} Per-cell size factors for each column of `x`.\n *\n * If `buffer` is supplied, it is directly used as the return value.\n */\nexport function quickAdtSizeFactors(x, { numberOfClusters = 20, numberOfPCs = 25, totals = null, block = null, buffer = null, numberOfThreads = null } = {}) {\n    let norm, pcs;\n    try {\n        norm = logNormCounts(x, { sizeFactors: totals, block: block });\n        pcs = runPCA(norm, { numberOfPCs: Math.min(norm.numberOfRows() - 1, numberOfPCs), numberOfThreads: numberOfThreads, block: block, blockMethod: \"weight\" });\n    } finally {\n        utils.free(norm);\n    }\n\n    let clust;\n    try {\n        clust = clusterKmeans(pcs, numberOfClusters, { numberOfThreads: numberOfThreads });\n    } finally {\n        utils.free(pcs);\n    }\n\n    let local_buffer;\n    try {\n        if (buffer === null) {\n            local_buffer = utils.createFloat64WasmArray(x.numberOfColumns());\n            buffer = local_buffer;\n        } else if (buffer.length !== x.numberOfColumns()) {\n            throw new Error(\"length of 'buffer' should be equal to the number of columns in 'x'\");\n        }\n        groupedSizeFactors(x, clust.clusters({ copy: \"view\" }), { buffer: buffer, numberOfThreads: numberOfThreads });\n\n    } catch (e) {\n        utils.free(local_buffer);\n        throw e;\n\n    } finally {\n        utils.free(clust);\n    }\n\n    return buffer;\n}\n","import * as utils from \"./utils.js\";\nimport * as wasm from \"./wasm.js\";\nimport * as gc from \"./gc.js\";\nimport * as packer from \"./internal/pack_strings.js\";\n\n/**\n * Base class for RDS objects.\n * @hideconstructor\n */\nexport class RdsObject {\n    constructor(id, raw, par) {\n        this.id = id;\n        this.object = raw;\n        this.parent = par;\n    }\n\n    /**\n     * @return {string} Type of the object.\n     */\n    type() {\n        return this.object.type();\n    }\n\n    /**\n     * Free the memory on the Wasm heap for this object.\n     */\n    free() {\n        if (this.object !== null) {\n            gc.release(this.id);\n            this.object = null;\n        }\n    }\n}\n\n/**\n * Vector-like R object.\n *\n * @augments RdsObject\n * @hideconstructor\n */\nexport class RdsVector extends RdsObject {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * @return{number} Length of the vector.\n     */\n    length() {\n        return this.object.size();\n    }\n\n    /**\n     * @return {Array} Names of all attributes.\n     */\n    attributeNames() {\n        return wasm.call(mod => {\n            this.object.fill_attribute_names();\n            let anames_buf = this.object.attribute_names_buffer();\n            let anames_len = this.object.attribute_names_length();\n            return packer.unpack_strings(anames_buf, anames_len);\n        });\n    }\n\n    /**\n     * @param {string} name - Name of the attribute of interest.\n     * @return {number} Index of `name` in the array of attributes from {@linkcode RdsVector#attributeNames attributeNames}.\n     * If `name` is not present, -1 is returned.\n     */\n    findAttribute(name) {\n        return wasm.call(mod => this.object.find_attribute(name));\n    }\n\n    /**\n     * @param {number|string} i - Index or name of the attribute of interest.\n     * @return {RdsObject} Value of the attribute.\n     */\n    attribute(i) {\n        if (typeof i == \"number\") {\n            return dispatch(mod => this.object.load_attribute_by_index(i), this.parent);\n        } else {\n            return dispatch(mod => this.object.load_attribute_by_name(i), this.parent);\n        }\n    }\n}\n\n/**\n * Integer vector from R.\n *\n * @augments RdsVector \n * @hideconstructor\n */\nexport class RdsIntegerVector extends RdsVector {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     *\n     * @return {Int32Array|Int32WasmArray} Values of the integer vector.\n     */\n    values({ copy = true } = {}) {\n        return utils.possibleCopy(this.object.numeric_vector(), copy);\n    }\n}\n\n/**\n * Boolean (i.e., boolean) vector from R.\n *\n * @augments RdsVector \n * @hideconstructor\n */\nexport class RdsBooleanVector extends RdsVector {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     *\n     * @return {Int32Array|Int32WasmArray} Values of the logical vector.\n     * Zero values are falsey and values of 1 are truthy.\n     */\n    values({ copy = true } = {}) {\n        return utils.possibleCopy(this.object.numeric_vector(), copy);\n    }\n}\n\n/**\n * Double-precision vector from R.\n *\n * @augments RdsVector \n * @hideconstructor\n */\nexport class RdsDoubleVector extends RdsVector {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     *\n     * @return {Float64Array|Float64WasmArray} Values of the double vector.\n     */\n    values({ copy = true } = {}) {\n        return utils.possibleCopy(this.object.numeric_vector(), copy);\n    }\n}\n\n/**\n * String vector from R.\n *\n * @augments RdsVector \n * @hideconstructor\n */\nexport class RdsStringVector extends RdsVector {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * @return {Array} Values of the string vector.\n     */\n    values() {\n        return wasm.call(mod => {\n            this.object.fill_string_vector();\n            let buf = this.object.string_vector_buffer();\n            let len = this.object.string_vector_length();\n            return packer.unpack_strings(buf, len);\n        });\n    }\n}\n\n/**\n * Generic vector from R, typically known as a \"list\".\n *\n * @augments RdsVector \n * @hideconstructor\n */\nexport class RdsGenericVector extends RdsVector {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * @param {number} index - Index of the list element of interest.\n     * @return {RdsObject} Value of the list element.\n     */\n    load(index) {\n        return dispatch(mod => this.object.load_list_element(index), this.parent);\n    }\n}\n\n/**\n * S4 object from R, containing slot data in its attributes.\n *\n * @augments RdsObject\n * @hideconstructor\n */\nexport class RdsS4Object extends RdsObject {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * Name of the R class.\n     */\n    className() {\n        return wasm.call(mod => this.object.class_name());\n    }\n\n    /**\n     * Name of the package that defines the class.\n     */\n    packageName() {\n        return wasm.call(mod => this.object.package_name());\n    }\n\n    /**\n     * @return {Array} Names of all attributes.\n     */\n    attributeNames() {\n        return wasm.call(mod => {\n            this.object.fill_attribute_names();\n            let anames_buf = this.object.attribute_names_buffer();\n            let anames_len = this.object.attribute_names_length();\n            return packer.unpack_strings(anames_buf, anames_len);\n        });\n    }\n\n    /**\n     * @param {string} name - Name of the attribute of interest.\n     * @return {number} Index of `name` in the array of attributes from {@linkcode RdsVector#attributeNames attributeNames}.\n     * If `name` is not present, -1 is returned.\n     */\n    findAttribute(name) {\n        return wasm.call(mod => this.object.find_attribute(name));\n    }\n\n    /**\n     * @param {number|string} i - Index or name of the attribute of interest.\n     * @return {RdsObject} Value of the attribute.\n     */\n    attribute(i) {\n        if (typeof i == \"number\") {\n            return dispatch(mod => this.object.load_attribute_by_index(i), this.parent);\n        } else {\n            return dispatch(mod => this.object.load_attribute_by_name(i), this.parent);\n        }\n    }\n}\n\n/**\n * NULL type in R.\n *\n * @augments RdsObject\n * @hideconstructor\n */\nexport class RdsNull extends RdsVector {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n};\n\nfunction dispatch(fun, par) {\n    let obj = wasm.call(fun);\n\n    let tt = null;\n    try {\n        tt = obj.type();\n    } catch (e) {\n        obj.delete();\n        throw e;\n    }\n\n    // Remaining steps until gc.call() should be no-throw!\n    let cons;\n    if (tt == \"integer\") {\n        cons = RdsIntegerVector;\n    } else if (tt == \"double\") {\n        cons = RdsDoubleVector;\n    } else if (tt == \"boolean\") {\n        cons = RdsBooleanVector;\n    } else if (tt == \"string\") {\n        cons = RdsStringVector;\n    } else if (tt == \"vector\") {\n        cons = RdsGenericVector;\n    } else if (tt == \"S4\") {\n        cons = RdsS4Object;\n    } else if (tt == \"null\") {\n        cons = RdsNull;\n    } else {\n        cons = RdsObject;\n    }\n\n    return gc.call(mod => obj, cons, par);\n}\n\n/**\n * Details of the RDS file.\n * @hideconstructor\n */\nexport class RdsDetails {\n    #id;\n    #obj;\n\n    constructor(id, obj) {\n        this.#id = id;\n        this.#obj = obj;\n    }\n\n    /**\n     * @return {number} Version of the RDS format. This should be 3.\n     */\n    formatVersion() {\n        return this.#obj.format_version();\n    }\n\n    /**\n     * @return {string} The R version used to create the file.\n     */\n    writerVersion() {\n        let info = this.#obj.writer_version();\n        return String(info[0]) + \".\" + String(info[1]) + \".\" + String(info[2]);\n    }\n\n    /**\n     * @return {string} The minimum R version that can read the file.\n     */\n    readerVersion() {\n        let info = this.#obj.reader_version();\n        return String(info[0]) + \".\" + String(info[1]) + \".\" + String(info[2]);\n    }\n\n    /**\n     * @return {RdsObject} Interface into the underlying R object.\n     */\n    value() {\n        return dispatch(mod => this.#obj.load(), this); \n    }\n\n    /**\n     * Free the memory on the Wasm heap for this object.\n     * Doing so will invalidate all {@linkplain RdsObject} instances derived from this object, \n     * directly via {@linkcode RdsDetails#load} or indirectly \n     * (e.g., from further {@linkcode RdsVector#attribute RdsVector.attribute} or {@linkcode RdsGenericVector#load RdsGenericVector.load} calls).\n     */\n    free() {\n        if (this.#obj !== null) {\n            gc.release(this.#id);\n            this.#obj = null;\n        }\n    }\n}\n\n/**\n * Read the contents of an RDS file.\n *\n * @param {Uint8WasmArray|Array|TypedArray|string} buffer Byte array containing the contents of an RDS file.\n * This can be raw text or Gzip-compressed.\n * \n * Alternatively, this can be a string containing a file path to a MatrixMarket file.\n *\n * @return {RdsDetails} Details of the file.\n */\nexport function readRds(x) {\n    let tmp;\n    let output;\n\n    try {\n        if (typeof x == \"string\") {\n            output = gc.call(module => module.parse_rds_from_file(x), RdsDetails)\n        } else {\n            tmp = utils.wasmifyArray(x, \"Uint8WasmArray\");\n            output = gc.call(module => module.parse_rds_from_buffer(tmp.offset, tmp.length), RdsDetails);\n        }\n    } finally {\n        utils.free(tmp);\n    }\n\n    return output;\n}\n\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\n\n/** \n * Wrapper for the PCA results on the Wasm heap, typically created by {@linkcode runPCA}.\n * @hideconstructor\n */\nexport class RunPCAResults {\n    #id;\n    #results;\n\n    #filledComponents;\n    #filledVariances;\n    #filledTotalVariance;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledComponents = filled;\n        this.#filledVariances = filled;\n        this.#filledTotalVariance = filled;\n\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     * \n     * @return {?(Float64Array|Float64Wasmarray)} Array containing the principal components for all cells.\n     * This should be treated as a column-major array where the rows are the PCs and columns are the cells.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    principalComponents({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledComponents, \n            () => { this.#filledComponents = true }, \n            COPY => utils.possibleCopy(this.#results.pcs(), COPY)\n        );\n    }\n\n    /**\n     * @param {number} total - Total variance in the dataset,\n     * equal to the sum of the variances across all PCs (including those that were not explicitly computed).\n     *\n     * @return Total varaiance in this object is set to `total`.\n     * This is primarily intended for use with {@linkcode emptyRunPCAResults}.\n     */\n    setTotalVariance(total) {\n        if (!this.#filledTotalVariance) {\n            this.#filledTotalVariance = true;\n        }\n        this.#results.set_total_variance(total);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     * \n     * @return {?(Float64Array|Float64WasmArray)} Array containing the variance explained for each requested PC.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    varianceExplained({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledVariances, \n            () => { this.#filledVariances = true }, \n            COPY => utils.possibleCopy(this.#results.variance_explained(), COPY)\n        );\n    }\n\n    /**\n     * @return {?number} The total variance in the dataset,\n     * typically used with {@linkcode PCAResults#varianceExplained varianceExplained} to compute the proportion of variance explained.\n     * Alternatively `null`, if this value has not been filled by {@linkcode ClusterKmeansResults#setTotalVariance setTotalVariance}.\n     */\n    totalVariance() {\n        if (!this.#filledTotalVariance) {\n            return null;\n        } else {\n            return this.#results.total_variance();\n        }\n    }\n\n    /**\n     * @return {number} Number of PCs available in these results.\n     */\n    numberOfPCs() {\n        return this.#results.num_pcs();\n    }\n\n    /**\n     * @return {number} Number of cells used to compute these results.\n     */\n    numberOfCells() {\n        // TODO: switch to this.#results.num_cells();\n        return this.principalComponents({ copy: false }).length / this.numberOfPCs();\n\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Run a principal components analysis on the log-expression matrix.\n * This is usually done on a subset of features, and possibly with some kind of blocking on a per-cell batch factor.\n *\n * @param {ScranMatrix} x - The log-normalized expression matrix.\n * @param {object} [options={}] - Optional parameters. \n * @param {?(Uint8WasmArray|Array|TypedArray)} [options.features=null] - Array specifying which features should be retained (e.g., HVGs).\n * This should be of length equal to the number of rows in `x`; elements should be `true` to retain each row.\n * If `null`, all features are retained.\n * @param {number} [options.numberOfPCs=25] - Number of top principal components to compute.\n * @param {boolean} [options.scale=false] - Whether to scale each feature to unit variance.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to compute filters within each block.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n * @param {string} [options.blockMethod=\"regress\"] - How to modify the PCA for the blocking factor.\n *\n * - `\"regress\"` will regress out the factor, effectively performing a PCA on the residuals.\n * - `\"weight\"` will weight the contribution of each blocking level equally so that larger blocks do not dominate the PCA.\n * - `\"none\"` will ignore any blocking factor, i.e., as if `block = null`.\n *\n * This option is only used if `block` is not `null`.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {RunPCAResults} Object containing the computed PCs.\n */\nexport function runPCA(x, { features = null, numberOfPCs = 25, scale = false, block = null, blockMethod = \"regress\", numberOfThreads = null } = {}) {\n    var feat_data;\n    var block_data;\n    var output;\n\n    utils.matchOptions(\"blockMethod\", blockMethod, [\"none\", \"regress\", \"weight\" ]);\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        var use_feat = false;\n        var fptr = 0;\n\n        if (features !== null) {\n            feat_data = utils.wasmifyArray(features, \"Uint8WasmArray\");\n            if (feat_data.length != x.numberOfRows()) {\n                throw new Error(\"length of 'features' should be equal to number of rows in 'x'\");\n            }\n            use_feat = true;\n            fptr = feat_data.offset;\n        }\n\n        // Avoid asking for more PCs than is possible.\n        // Remember that centering removes one df, so we subtract 1 from the dimensions.\n        numberOfPCs = Math.min(numberOfPCs, x.numberOfRows() - 1, x.numberOfColumns() - 1);\n\n        if (block === null || blockMethod == 'none') {\n            output = gc.call(\n                module => module.run_pca(x.matrix, numberOfPCs, use_feat, fptr, scale, nthreads),\n                RunPCAResults\n            );\n\n        } else {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != x.numberOfColumns()) {\n                throw new Error(\"length of 'block' should be equal to the number of columns in 'x'\");\n            }\n            if (blockMethod == \"regress\") {\n                output = gc.call(\n                    module => module.run_blocked_pca(x.matrix, numberOfPCs, use_feat, fptr, scale, block_data.offset, nthreads),\n                    RunPCAResults\n                );\n            } else if (blockMethod == \"weight\") {\n                output = gc.call(\n                    module => module.run_multibatch_pca(x.matrix, numberOfPCs, use_feat, fptr, scale, block_data.offset, nthreads),\n                    RunPCAResults\n                );\n            } else {\n                throw new Error(\"unknown value '\" + blockMethod + \"' for 'blockMethod='\");\n            }\n        }\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(feat_data);\n        utils.free(block_data);\n    }\n\n    return output;\n}\n\n/**\n * Create an empty {@linkplain RunPCAResults} object, to be filled with custom results.\n * This is typically used to generate a convenient input into later {@linkcode clusterKmeans} calls.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfCells - Number of cells in the dataset, usually after QC filtering.\n * @param {number} numberOfPCs - Number of PCs to be computed.\n *\n * @return {RunPCAResults} Object with allocated memory to store the PCs, but no actual values.\n */\nexport function emptyRunPCAResults(numberOfCells, numberOfPCs) {\n    return gc.call(\n        module => new module.RunPCA_Results(numberOfCells, numberOfPCs),\n        RunPCAResults,\n        /* filled = */ false\n    );\n}\n","import * as utils from \"./utils.js\";\nimport * as wasm from \"./wasm.js\";\nimport * as gc from \"./gc.js\";\nimport { BuildNeighborSearchIndexResults, findNearestNeighbors } from \"./findNearestNeighbors.js\";\n\n/**\n * Wrapper around the t-SNE status object on the Wasm heap, typically created by {@linkcode initializeTSNE}.\n * @hideconstructor\n */\nexport class InitializeTSNEResults {\n    #id;\n    #status;\n    #coordinates;\n\n    constructor(id, raw_status, raw_coordinates) {\n        this.#id = id;\n        this.#status = raw_status;\n        this.#coordinates = raw_coordinates;\n        return;\n    }\n\n    // Internal use only, not documented.\n    get status() {\n        return this.#status;\n    }\n\n    // Internal use only, not documented.\n    get coordinates() {\n        return this.#coordinates;\n    }\n\n    /**\n     * @return {InitializeTSNEResults} A deep copy of this object.\n     */\n    clone() {\n        return gc.call(\n            module => this.#status.deepcopy(), \n            InitializeTSNEResults, \n            this.#coordinates.clone()\n        );\n    }\n\n    /**\n     * @return {number} Number of cells in the dataset.\n     */\n    numberOfCells () {\n        return this.#status.num_obs();\n    }\n\n    /**\n     * @return {number} Number of iterations processed so far.\n     * This will change with repeated invocations of {@linkcode runTSNE} on this object.\n     */\n    iterations () {\n        return this.#status.iterations();\n    }\n\n    /**\n     * @return {object} Object with `x` and `y` keys.\n     * The corresponding values are Float64Array objects of length equal to the number of cells,\n     * containing the x- and  y- coordinates for each cell at the current state of the algorithm.\n     */\n    extractCoordinates() {\n        return utils.extractXY(this.numberOfCells(), this.#coordinates.array()); \n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */   \n    free() {\n        if (this.#status !== null) {\n            gc.release(this.#id);\n            this.#status = null;\n        }\n        if (this.#coordinates !== null) {\n            this.#coordinates.free();\n            this.#coordinates = null;\n        }\n        return;\n    }\n}\n\n/**\n * @param {number} perplexity - Perplexity to use in the t-SNE algorithm.\n * @return {number} Appropriate number of neighbors to use in the nearest neighbor search.\n */\nexport function perplexityToNeighbors(perplexity) {\n    return wasm.call(module => module.perplexity_to_k(perplexity));\n}\n\n/**\n * @param {(BuildNeighborSearchIndexResults|FindNearestNeighborsResults)} x \n * Either a pre-built neighbor search index for the dataset (see {@linkcode buildNeighborSearchIndex}),\n * or a pre-computed set of neighbor search results for all cells (see {@linkcode findNearestNeighbors}).\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.perplexity=30] - Perplexity to use when computing neighbor probabilities in the t-SNE.\n * @param {boolean} [options.checkMismatch=true] - Whether to check for a mismatch between the perplexity and the number of searched neighbors.\n * Only relevant if `x` is a {@linkplain FindNearestNeighborsResults} object.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {InitializeTSNEResults} Object containing the initial status of the t-SNE algorithm.\n */\nexport function initializeTSNE(x, { perplexity = 30, checkMismatch = true, numberOfThreads = null } = {}) {\n    var my_neighbors;\n    var raw_coords;\n    var output;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        let neighbors;\n\n        if (x instanceof BuildNeighborSearchIndexResults) {\n            let k = perplexityToNeighbors(perplexity);\n            my_neighbors = findNearestNeighbors(x, k, { numberOfThreads: nthreads });\n            neighbors = my_neighbors;\n\n        } else {\n            if (checkMismatch) {\n                let k = perplexityToNeighbors(perplexity);\n                if (k * x.numberOfCells() != x.size()) {\n                    throw new Error(\"number of neighbors in 'x' does not match '3 * perplexity'\");\n                }\n            }\n            neighbors = x;\n        }\n\n        raw_coords = utils.createFloat64WasmArray(2 * neighbors.numberOfCells());\n        wasm.call(module => module.randomize_tsne_start(neighbors.numberOfCells(), raw_coords.offset, 42));\n        output = gc.call(\n            module => module.initialize_tsne(neighbors.results, perplexity, nthreads),\n            InitializeTSNEResults,\n            raw_coords\n        );\n\n    } catch(e) {\n        utils.free(output);\n        utils.free(raw_coords);\n        throw e;\n\n    } finally {\n        utils.free(my_neighbors);\n    }\n\n    return output;\n}\n\n/**\n * Run the t-SNE algorithm on an initialized {@linkplain InitializeTSNEResults}.\n *\n * @param {InitializeTSNEResults} x A previously initialized status object from {@linkcode initializeTSNE}.\n * This may be passed through {@linkcode runTSNE} any number of times.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.maxIterations=1000] - Maximum number of iterations to perform.\n * This number includes all existing iterations that were already performed in `x` from previous calls to {@linkcode runTSNE}.\n * @param {?number} [options.runTime=null] - Number of milliseconds for which the algorithm is allowed to run before returning.\n * If `null`, no limit is imposed on the runtime.\n *\n * @return The algorithm status in `x` is advanced up to the requested number of iterations,\n * or until the requested run time is exceeded, whichever comes first.\n */\nexport function runTSNE(x, { maxIterations = 1000, runTime = null } = {}) {\n    if (runTime === null) {\n        runTime = -1;\n    }\n    wasm.call(module => module.run_tsne(x.status, runTime, maxIterations, x.coordinates.offset));\n    return;\n}\n","import * as wasm from \"./wasm.js\";\nimport * as utils from \"./utils.js\";\nimport { buildNeighborSearchIndex, BuildNeighborSearchIndexResults } from \"./findNearestNeighbors.js\"; \n\n/**\n * Scale embeddings based on the variation between neighboring cells.\n * This aims to equalize the noise across embeddings for the same population of cells across different data modalities,\n * allowing them to be combined into a single embedding for coordinated downstream analyses.\n *\n * @param {Array} embeddings - Array of Float64WasmArrays containing column-major matrices where rows are dimensions and columns are cells.\n * All entries of this array should contain data for the same number and ordering of cells.\n * @param {number} numberOfCells - Number of cells in all embeddings.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.neighbors=20] - Number of neighbors to use for quantifying variation.\n * Larger values provide a more stable calculation but assume larger subpopulations.\n * @param {?Array} [options.indices=null] - Array of {@linkplain BuildNeighborSearchIndexResults} objects, \n * where each entry is constructed from the corresponding entry of `embeddings` (see {@linkcode buildNeighborSearchIndex}).\n * This can be used to avoid redundant calculation of indices if they are already available.\n * @param {?Float64WasmArray} [options.buffer=null] - Array in which to store the combined embedding.\n * This should have length equal to the product of `numberOfCells` and the sum of dimensions of all embeddings.\n * @param {boolean} [options.approximate=true] - Should we construct an approximate search index if `indices` is not supplied?\n * @param {?(Array|TypedArray|Float64WasmArray)} [options.weights=null] - Array of length equal to the number of embeddings, containing a non-enegative relative weight for each embedding.\n * This is used to scale each embedding if non-equal noise is desired in the combined embedding.\n * If `null`, all embeddings receive the same weight.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {Float64WasmArray} Array containing the combined embeddings in column-major format, i.e., dimensions in rows and cells in columns.\n *\n * If `buffer` was supplied, it is used as the return value.\n */\nexport function scaleByNeighbors(embeddings, numberOfCells, { neighbors = 20, indices = null, buffer = null, approximate = true, weights = null, numberOfThreads = null } = {}) {\n    let nembed = embeddings.length;\n    let embed_ptrs, index_ptrs;\n    let holding_ndims;\n    let holding_weights;\n    let local_buffer;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    let deletable = [];\n    try {\n        // Fetching the pointers.\n        embed_ptrs = utils.createBigUint64WasmArray(nembed);\n        let embed_arr = embed_ptrs.array();\n        for (var i = 0; i < nembed; i++) {\n            embed_arr[i] = BigInt(embeddings[i].offset);\n        }\n\n        let weight_offset = 0;\n        let use_weights = false;\n        if (weights !== null) {\n            use_weights = true;\n            holding_weights = utils.wasmifyArray(weights, \"Float64WasmArray\");\n            if (holding_weights.length != nembed) {\n                throw new Error(\"length of 'weights' should be equal to the number of embeddings\");\n            }\n            weight_offset = holding_weights.offset;\n        }\n\n        // Allocating output space, if necessary; and then scaling.\n        let allocator = (total_ndim) => {\n            let total_len = total_ndim * numberOfCells;\n            if (buffer === null) {\n                local_buffer = utils.createFloat64WasmArray(total_len);\n                buffer = local_buffer;\n            } else if (total_len !== buffer.length) {\n                throw new Error(\"length of 'buffer' should be equal to the product of 'numberOfCells' and the total number of dimensions\");\n            }\n        }\n\n        if (indices !== null) {\n            if (nembed !== indices.length) {\n                throw new Error(\"'indices' and 'embeddings' should have the same length\");\n            }\n\n            index_ptrs = utils.createBigUint64WasmArray(nembed);\n            let index_arr = index_ptrs.array();\n            let total_ndim = 0;\n\n            for (var i = 0; i < nembed; i++) {\n                let index = indices[i];\n                if (numberOfCells != index.numberOfCells()) {\n                    throw new Error(\"each element of 'indices' should have the same number of cells as 'numberOfCells'\");\n                }\n                if (embeddings[i].length != index.numberOfCells() * index.numberOfDims()) {\n                    throw new Error(\"length of arrays in 'embeddings' should equal the length of arrays used to build 'indices'\");\n                }\n\n                index_arr[i] = BigInt(indices[i].index.$$.ptr);\n                total_ndim += indices[i].numberOfDims();\n            }\n\n            allocator(total_ndim);\n            wasm.call(module => module.scale_by_neighbors_indices(\n                numberOfCells, \n                nembed, \n                embed_ptrs.offset, \n                index_ptrs.offset, \n                buffer.offset, \n                neighbors, \n                use_weights, \n                weight_offset,\n                nthreads\n            ));\n\n        } else {\n            holding_ndims = utils.createInt32WasmArray(nembed);\n            let ndims_arr = holding_ndims.array();\n            let total_ndim = 0;\n\n            for (var i = 0; i < nembed; i++) {\n                let n = embeddings[i].length;\n                ndims_arr[i] = Math.floor(n / numberOfCells);\n                if (numberOfCells * ndims_arr[i] !== n) {\n                    throw new Error(\"length of arrays in 'embeddings' should be a multiple of 'numberOfCells'\");\n                }\n                total_ndim += ndims_arr[i];\n            }\n\n            allocator(total_ndim);\n            wasm.call(module => module.scale_by_neighbors_matrices(\n                numberOfCells, \n                nembed, \n                holding_ndims.offset, \n                embed_ptrs.offset, \n                buffer.offset, \n                neighbors, \n                use_weights, \n                weight_offset,\n                approximate,\n                nthreads\n            ));\n        }\n\n    } catch (e) {\n        utils.free(local_buffer);\n        throw e;\n\n    } finally {\n        for (const x of deletable) {\n            x.free();\n        }\n        utils.free(embed_ptrs);\n        utils.free(index_ptrs);\n        utils.free(holding_weights);\n        utils.free(holding_ndims);\n    }\n\n    return buffer;\n}\n","import * as gc from \"./gc.js\";\nimport * as wasm from \"./wasm.js\";\nimport * as utils from \"./utils.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Compute per-cell scores for the activity of a feature set.\n *\n * @param {ScranMatrix} x - Log-normalized expression matrix.\n * @param {Uint8Array|Uint8WasmArray|TypedArray|Array} features - An array of length equal to the number of rows in `x`, indicating which features belong to the set.\n * A non-zero value for any entry indicates that the corresponding row of `x` is part of the feature set.\n * @param {object} [options={}] - Optional parameters.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n * @param {boolean} [options.scale=false] - Whether to scale the expression matrix to unit variance for each feature before computing the per-feature weights.\n * Setting to `true` improves robustness (or reduces sensitivity) to the behavior of highly variable features in the set.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {object} Object containing:\n *\n * - `weights`, a Float64Array containing per-gene weights for each feature in the set.\n * - `scores`, a Float64Array containing the per-cell scores for each column of `x`.\n */\nexport function scoreFeatureSet(x, features, { block = null, scale = false, numberOfThreads = null } = {}) {\n    let temp;\n    let output = {};\n    let feature_data, block_data;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        // Setting up the features.\n        if (features.length !== x.numberOfRows()) {\n            throw new Error(\"Uint8Array 'features' must be of length equal to the number of rows in 'x'\");\n        }\n        feature_data = utils.wasmifyArray(features, \"Uint8WasmArray\");\n\n        // Setting up the blocks.\n        var bptr = 0;\n        var use_blocks = false;\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != x.numberOfColumns()) {\n                throw new Error(\"'block' must be of length equal to the number of columns in 'x'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        temp = wasm.call(module => module.score_feature_set(x.matrix, feature_data.offset, use_blocks, bptr, scale, nthreads));\n        output.weights = temp.weights().slice();\n        output.scores = temp.scores().slice();\n\n    } finally {\n        utils.free(block_data);\n        utils.free(feature_data);\n        if (temp) {\n            temp.delete();\n        }\n    }\n\n    return output;\n}\n","import * as gc from \"./gc.js\";\nimport * as wasm from \"./wasm.js\";\nimport * as utils from \"./utils.js\";\n\nfunction checkFillness2(group, summary, fillable, copy, fillcheck, getfun) {\n    return utils.checkFillness(\n        fillable, \n        copy, \n        fillcheck.filled || fillcheck.details[group][summary] || false, \n        () => { fillcheck.details[group][summary] = true }, \n        getfun  \n    );\n}\n\nfunction intifySummary(summary) {\n    if (typeof summary == \"number\") {\n        return summary; // for back-compatibility with numeric summaries.\n    }\n    let output;\n    switch (summary) {\n        case \"minimum\": \n            output = 0;\n            break;\n        case \"mean\": \n            output = 1;\n            break;\n        case \"median\":\n            output = 2;\n            break;\n        case \"maximum\": \n            output = 3;\n            break;\n        case \"min-rank\":\n            output = 4;\n            break;\n        default:\n            throw new Error(\"unknown summary type '\" + summary + \"'\");\n    }\n    return output;\n}\n\n/**\n * Wrapper around the marker scoring results on the Wasm heap, typically produced by {@linkcode scoreMarkers}.\n * @hideconstructor\n */\nexport class ScoreMarkersResults {\n    #id;\n    #results;\n\n    #filledMeans;\n    #filledDetected;\n    #filledCohen;\n    #filledLfc;\n    #filledAuc;\n    #filledDeltaDetected;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        let n = this.numberOfGroups();\n        let b = this.numberOfBlocks();\n\n        function createBlockedStatsFilled(filled) {\n            let output = { filled };\n            if (!filled) {\n                output.details = new Array(n);\n                for (var g = 0; g < n; g++) {\n                    output.details[g] = utils.spawnArray(b + 1, filled);\n                }\n            }\n            return output;\n        }\n\n        this.#filledMeans = createBlockedStatsFilled(filled);\n        this.#filledDetected = createBlockedStatsFilled(filled);\n\n        function createEffectsFilled(filled) {\n            let output = { filled };\n            if (!filled) {\n                output.details = new Array(n);\n                for (var g = 0; g < n; g++) {\n                    output.details[g] = {};\n                }\n            }\n            return output;\n        }\n\n        this.#filledCohen = createEffectsFilled(filled); \n        this.#filledLfc = createEffectsFilled(filled); \n        this.#filledAuc = createEffectsFilled(filled); \n        this.#filledDeltaDetected = createEffectsFilled(filled); \n\n        return;\n    }\n\n    #extractBlockedStat(group, block, copy, fillable, fillcheck, method) {\n        let index = block;\n        if (block == null) {\n            let nblocks = this.numberOfBlocks();\n            index = (nblocks > 1 ? nblocks : 0);\n            block = -1;\n        }\n\n        return utils.checkFillness(\n            fillable, \n            copy, \n            fillcheck.filled || fillcheck.details[group][index] || false, \n            () => { fillcheck.details[group][index] = true }, \n            COPY => utils.possibleCopy(this.#results[method](group, block), COPY)\n        );\n    }\n\n    /**\n     * @return {number} Number of blocks used to compute the results.\n     */\n    numberOfBlocks() {\n        return this.#results.num_blocks();\n    }\n\n    /**\n     * @return {number} Number of groups in the results.\n     */\n    numberOfGroups() {\n        return this.#results.num_groups();\n    }\n\n    /**\n     * @param {number} group - Group of interest.\n     * Should be non-negative and less than {@linkcode ScoreMarkersResults#numberOfGroups numberOfGroups}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.block=null] - Number of the block for which to extract statistics.\n     * If `null`, the average across all blocks is returned.\n     * Otherwise, should be less than the value returned by {@linkcode ModelGeneVarResults#numberOfBlocks numberOfBlocks}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the mean expression for the requested group in the requested block.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    means(group, { block = null, copy = true, fillable = false } = {}) {\n        return this.#extractBlockedStat(group, block, copy, fillable, this.#filledMeans, \"means\");\n    }\n\n    /**\n     * @param {number} group - Group of interest.\n     * Should be non-negative and less than {@linkcode ScoreMarkersResults#numberOfGroups numberOfGroups}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.block=null] - Number of the block for which to extract statistics.\n     * If `null`, the average across all blocks is returned.\n     * Otherwise, should be less than the value returned by {@linkcode ModelGeneVarResults#numberOfBlocks numberOfBlocks}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the proportion of cells with detectable expression for the requested group in the requested block.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    detected(group, { block = null, copy = true, fillable = false } = {}) {\n        return this.#extractBlockedStat(group, block, copy, fillable, this.#filledDetected, \"detected\");\n    }\n\n    /**\n     * @param {number} group - Group of interest.\n     * Should be non-negative and less than {@linkcode ScoreMarkersResults#numberOfGroups numberOfGroups}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {string} [options.summary=\"mean\"] - Summary statistic to be computed from the Cohen's d values of all pairwise comparisons involving `group`.\n     * This can be the `\"minimum\"` across comparisons, `\"mean\"` or `\"min-rank\"`.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the summarized Cohen's d for the comparisons between `group` and all other groups.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    cohen(group, { summary = \"mean\", copy = true, fillable = false } = {}) {\n        summary = intifySummary(summary);\n        return checkFillness2(\n            group, \n            summary, \n            fillable, \n            copy, \n            this.#filledCohen,\n            COPY => utils.possibleCopy(\n                wasm.call(_ => this.#results.cohen(group, summary)),\n                COPY\n            )\n        );\n    }\n\n    /**\n     * AUCs are only computed if `computeAuc = true` in {@linkcode scoreMarkers}.\n     * If `false`, this method will throw an error.\n     *\n     * @param {number} group - Group of interest.\n     * Should be non-negative and less than {@linkcode ScoreMarkersResults#numberOfGroups numberOfGroups}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {string} [options.summary=\"mean\"] - Summary statistic to be computed from the AUCs of all pairwise comparisons involving `group`.\n     * This can be the `\"minimum\"` across comparisons, `\"mean\"` or `\"min-rank\"`.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the summarized AUC for the comparisons between `group` and all other groups.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    auc(group, { summary = \"mean\", copy = true, fillable = false } = {}) {\n        summary = intifySummary(summary);\n        return checkFillness2(\n            group, \n            summary, \n            fillable, \n            copy, \n            this.#filledAuc, \n            COPY => utils.possibleCopy(\n                wasm.call(_ => this.#results.auc(group, summary)),\n                COPY\n            )\n        );\n    }\n\n    /**\n     * @param {number} group - Group of interest.\n     * Should be non-negative and less than {@linkcode ScoreMarkersResults#numberOfGroups numberOfGroups}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {string} [options.summary=\"mean\"] - Summary statistic to be computed from the log-fold changes of all pairwise comparisons involving `group`.\n     * This can be the `\"minimum\"` across comparisons, `\"mean\"` or `\"min-rank\"`.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the summarized log-fold change for the comparisons between `group` and all other groups.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    lfc(group, { summary = \"mean\", copy = true, fillable = false } = {}) {\n        summary = intifySummary(summary);\n        return checkFillness2(\n            group, \n            summary, \n            fillable, \n            copy, \n            this.#filledLfc, \n            COPY => utils.possibleCopy(\n                wasm.call(_ => this.#results.lfc(group, summary)),\n                COPY\n            )\n        );\n    }\n\n    /**\n     * @param {number} group - Group of interest.\n     * Should be non-negative and less than {@linkcode ScoreMarkersResults#numberOfGroups numberOfGroups}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {string} [options.summary=\"mean\"] - Summary statistic to be computed from the delta-detected values of all pairwise comparisons involving `group`.\n     * This can be the `\"minimum\"` across comparisons, `\"mean\"` or `\"min-rank\"`.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {Float64Array|Float64WasmArray} Array of length equal to the number of genes,\n     * containing the summarized delta-detected for the comparisons between `group` and all other groups.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    deltaDetected(group, { summary = \"mean\", copy = true, fillable = false } = {}) {\n        summary = intifySummary(summary);\n        return checkFillness2(\n            group, \n            summary, \n            fillable, \n            copy, \n            this.#filledDeltaDetected, \n            COPY => utils.possibleCopy(\n                wasm.call(_ => this.#results.delta_detected(group, summary)),\n                COPY\n            )\n        );\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Score genes as potential markers for each group of cells.\n *\n * @param {ScranMatrix} x - Log-normalized expression matrix.\n * @param {(Int32WasmArray|Array|TypedArray)} groups - Array containing the group assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of groups.\n * @param {object} [options={}] - Optional parameters.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to perform comparisons within each block.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n * @param {number} [options.lfcThreshold=0] - Log-fold change threshold to use for computing Cohen's d and AUC.\n * Large positive values favor markers with large log-fold changes over those with low variance.\n * @param {boolean} [options.computeAuc=true] - Whether to compute the AUCs as an effect size.\n * This can be set to `false` for greater speed and memory efficiency.\n * @param {boolean} [options.computeMedian=false] - Whether to compute the median effect sizes across all pairwise comparisons for each group.\n * This can be used as a more robust/less sensitive alternative to the mean.\n * @param {boolean} [options.computeMaximum=false] - Whether to compute the maximum effect size across all pairwise comparisons for each group.\n * This could be used to find uniquely downregulated genes.\n *\n * @return {ScoreMarkersResults} Object containing the marker scoring results.\n */\nexport function scoreMarkers(x, groups, { block = null, numberOfThreads = null, lfcThreshold = 0, computeAuc = true, computeMedian = false, computeMaximum = false } = {}) {\n    var output;\n    var block_data;\n    var group_data;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        group_data = utils.wasmifyArray(groups, \"Int32WasmArray\");\n        if (group_data.length != x.numberOfColumns()) {\n            throw new Error(\"length of 'groups' should be equal to number of columns in 'x'\");\n        }\n\n        var bptr = 0;\n        var use_blocks = false;\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != x.numberOfColumns()) {\n                throw new Error(\"'block' must be of length equal to the number of columns in 'x'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        output = gc.call(\n            module => module.score_markers(x.matrix, group_data.offset, use_blocks, bptr, lfcThreshold, computeAuc, computeMedian, computeMaximum, nthreads),\n            ScoreMarkersResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(block_data);\n        utils.free(group_data);\n    }\n\n    return output;\n}\n\n/**\n * Create an empty {@linkplain ScoreMarkersResults} object, to be filled with custom results.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfGenes - Number of genes in the dataset.\n * @param {number} numberOfGroups - Number of groups for which to store marker detection statistics.\n * @param {number} numberOfBlocks - Number of blocks in the dataset.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.computeAuc=true] - Whether to allocate memory for storing AUCs.\n * @param {boolean} [options.computeMedian=false] - Whether to allocate memory for storing median effect sizes.\n * @param {boolean} [options.computeMaximum=false] - Whether to allocate memory for storing maximum effect sizes.\n *\n * @return {ScoreMarkersResults} Object with memory allocated to store marker statistics, but not containing any actual values.\n */\nexport function emptyScoreMarkersResults(numberOfGenes, numberOfGroups, numberOfBlocks, { computeAuc = true, computeMedian = false, computeMaximum = false } = {}) {\n    return gc.call(\n        module => new module.ScoreMarkers_Results(numberOfGenes, numberOfGroups, numberOfBlocks, computeAuc, computeMedian, computeMaximum),\n        ScoreMarkersResults,\n        /* filled = */ false\n    );\n}\n","import * as utils from \"./utils.js\";\nimport * as wasm from \"./wasm.js\";\nimport { MultiMatrix } from \"./MultiMatrix.js\";\n\n/**\n * Slice a {@linkplain ScranMatrix} by its rows.\n * \n * @param {ScranMatrix} x - The matrix of interest.\n * @param {Array} indices - Row indices to extract.\n * All indices must be non-negative integers less than `mat.numberOfRows()`.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.inPlace=false] - Whether to modify `x` in place.\n * If `false`, a new ScranMatrix is returned.\n *\n * @return {ScranMatrix}\n * A ScranMatrix containing the subset of rows from `mat` specified by `indices`.\n * If `inPlace = true`, this is a reference to `x`, otherwise it is a new ScranMatrix.\n */\nexport function subsetRows(x, indices, { inPlace = false } = {}) {\n    let xcopy;\n    let target;\n    let wasm_indices;\n\n    try {\n        if (inPlace) {\n            target = x;\n        } else {\n            xcopy = x.clone();\n            target = xcopy;\n        }\n\n        wasm_indices = utils.wasmifyArray(indices, \"Int32WasmArray\");\n        wasm.call(module => module.row_subset(target.matrix, wasm_indices.offset, wasm_indices.length));\n\n    } catch (e) {\n        utils.free(xcopy);\n        throw e;\n\n    } finally {\n        utils.free(wasm_indices);\n    }\n\n    return target;\n}\n\n/**\n * Slice a ScranMatrix by its columns.\n * \n * @param {ScranMatrix} x - The matrix of interest.\n * @param {Array} indices - Column indices to extract.\n * Al indices must be a non-negative integer less than `mat.numberOfColumns()`.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.inPlace=false] - Whether to modify `x` in place.\n * If `false`, a new ScranMatrix is returned.\n *\n * @return {ScranMatrix}\n * A new ScranMatrix containing the subset of columns from `mat` specified by `indices`.\n * If `inPlace = true`, this is a reference to `x`, otherwise it is a new ScranMatrix.\n */\nexport function subsetColumns(x, indices, { inPlace = false } = {}) {\n    let xcopy;\n    let target;\n    let wasm_indices;\n\n    try {\n        if (inPlace) {\n            target = x;\n        } else {\n            xcopy = x.clone();\n            target = xcopy;\n        }\n\n        wasm_indices = utils.wasmifyArray(indices, \"Int32WasmArray\");\n        wasm.call(module => module.column_subset(target.matrix, wasm_indices.offset, wasm_indices.length));\n\n    } catch (e) {\n        utils.free(xcopy);\n        throw e;\n\n    } finally {\n        utils.free(wasm_indices);\n    }\n\n    return target;\n}\n\n/**\n * Split a {@linkplain ScranMatrix} by row.\n *\n * @param {ScranMatrix} matrix - A ScranMatrix object.\n * @param {object} split - Object specifying how rows should be split.\n * Each value should be an Array/TypedArray of 0-based row indices.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.singleNull=false] - Whether `null` should be returned if `split` only contains one level and all rows are represented exactly once.\n * This can be used to avoid the creation of a redundant {@linkplain ScranMatrix} object.\n * @param {boolean} [options.createMultiMatrix=false] - Whether the output should be returned as a {@linkplain MultiMatrix}.\n *\n * @return {object|MultiMatrix} Object with the same keys as `split` where each value is a ScranMatrix for the corresponding subset of rows.\n * Alternatively, this is wrapped in a MultiMatrix if `createMultiMatrix = true`.\n */\nexport function splitRows(matrix, split, { singleNull = false, createMultiMatrix = false } = {}) { \n    let output = {};\n    let tkeys = Object.keys(split);\n\n    if (tkeys.length == 1) {\n        let chosen = split[tkeys[0]];\n        let consec = (chosen.length == matrix.numberOfRows());\n        if (consec) {\n            for (var i = 0; i < chosen.length; i++) {\n                if (i != chosen[i]) {\n                    consec = false;\n                    break;\n                }\n            }\n        }\n\n        if (consec) {\n            if (singleNull) {\n                return null;\n            } else {\n                output[tkeys[0]] = matrix.clone();\n                return output;\n            }\n        }\n    }\n\n    let stuff;\n    try {\n        for (const k of tkeys) {\n            output[k] = subsetRows(matrix, split[k]);\n        }\n\n        // Sticking this inside the trycatch, so that\n        // memory is released if the constructor fails. \n        if (createMultiMatrix) {\n            stuff = new MultiMatrix({ store: output });\n        }\n    } catch (e) {\n        for (const v of Object.values(output)) {\n            v.free();\n        }\n        throw e;\n    }\n\n    if (createMultiMatrix) {\n        return stuff;\n    } else {\n        return output;\n    }\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\nimport * as internal from \"./internal/computePerCellQcFilters.js\";\nimport { PerCellAdtQcMetricsResults } from \"./perCellAdtQcMetrics.js\";\n\n/**\n * Wrapper class for the ADT-based QC filtering results, produced by {@linkcode suggestAdtQcFilters}.\n * @hideconstructor\n */\nexport class SuggestAdtQcFiltersResults {\n    #results;\n    #id;\n\n    #filledDetected;\n    #filledSubsetTotals;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledDetected = filled;\n        this.#filledSubsetTotals = utils.spawnArray(this.numberOfSubsets(), filled);\n\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the filtering threshold on the number of detected ADTs for each batch.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    thresholdsDetected({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledDetected, \n            () => { this.#filledDetected = true }, \n            COPY => utils.possibleCopy(this.#results.thresholds_detected(), COPY)\n        );\n    }\n\n    /**\n     * @param {number} i - Index of the feature subset of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the filtering threshold on the total counts for subset `i` in each batch.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    thresholdsSubsetTotals(i, { copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSubsetTotals[i], \n            () => { this.#filledSubsetTotals[i] = true }, \n            COPY => utils.possibleCopy(this.#results.thresholds_subset_totals(i), COPY)\n        );\n    }\n\n    /**\n     * @return {number} Number of feature subsets in this object.\n     */\n    numberOfSubsets() {\n        return this.#results.num_subsets();\n    }\n\n    /**\n     * @return {number} Number of blocks in this object.\n     */\n    numberOfBlocks() {\n        return this.#results.num_blocks();\n    }\n\n    /**\n     * @param {PerCellAdtQcMetricsResults} metrics - Per-cell QC metrics, usually computed by {@linkcode perCellAdtQcMetrics}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell in `metrics`.\n     * This should have length equal to the number of cells and contain all values in `[0, n)` where `n` is the return value of {@linkcode SuggestAdtQcFilters#numberOfBlocks numberOfBlocks}.\n     *\n     * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n     * This will raise an error if multiple blocks were used to compute the thresholds.\n     * @param {?Uint8WasmArray} [options.buffer=null] - Array of length equal to the number of cells in `metrics`, to be used to store the low-quality calls.\n     *\n     * @return {Uint8Array} Array of length equal to the number of cells in `metrics`.\n     * Each entry is truthy if the corresponding cell is deemed to be of low-quality based on its values in `metrics`.\n     * If `buffer` is supplied, the returned array is a view on `buffer`.\n     */\n    filter(metrics, { block = null, buffer = null } = {}) {\n        if (!(metrics instanceof PerCellAdtQcMetricsResults)) {\n            throw new Error(\"'metrics' should be a PerCellAdtQcMetricsResults object\");\n        }\n        return internal.applyFilter(this.#results, metrics, block, buffer); \n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Define filters based on the per-cell QC metrics from the ADT count matrix.\n *\n * @param {PerCellAdtQcMetricsResults} metrics - Per-cell QC metrics, usually computed by {@linkcode perCellAdtQcMetrics}.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfMADs=3] - Number of median absolute deviations to use to define low-quality outliers.\n * @param {number} [options.minDetectedDrop=0.1] - Minimum relative drop in the number of detected ADTs before a cell is to be considered a low-quality cell.\n * By default, cells must exhibit at least a 10% decrease from the median before filtering is applied.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to compute filters within each block.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n *\n * @return {SuggestAdtQcFiltersResults} Object containing the filtering results.\n */\nexport function suggestAdtQcFilters(metrics, { numberOfMADs = 3, minDetectedDrop = 0.1, block = null } = {}) {\n    if (!(metrics instanceof PerCellAdtQcMetricsResults)) {\n        throw new Error(\"'metrics' should be a PerCellAdtQcMetricsResults object\");\n    }\n    return internal.computePerCellQcFilters(\n        metrics, \n        block,\n        (x, use_blocks, bptr) => gc.call(\n            module => module.suggest_adt_qc_filters(x.results.$$.ptr, use_blocks, bptr, numberOfMADs, minDetectedDrop),\n            SuggestAdtQcFiltersResults\n        )\n    );\n}\n\n/**\n * Create an empty {@linkplain SuggestAdtQcFiltersResults} object, to be filled with custom results.\n * This is typically used to generate a convenient input into later {@linkcode filterCells} calls.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfSubsets Number of feature subsets.\n * @param {number} numberOfBlocks Number of blocks in the dataset.\n *\n * @return {SuggestAdtQcFiltersResults} Object with allocated memory to store QC filters, but no actual values.\n */\nexport function emptySuggestAdtQcFiltersResults(numberOfSubsets, numberOfBlocks) {\n    return gc.call(\n        module => new module.SuggestAdtQcFilters_Results(numberOfSubsets, numberOfBlocks),\n        SuggestAdtQcFiltersResults,\n        /* filled = */ false \n    );\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\nimport * as internal from \"./internal/computePerCellQcFilters.js\";\nimport { PerCellCrisprQcMetricsResults } from \"./perCellCrisprQcMetrics.js\";\n\n/**\n * Wrapper class for the filtering results, produced by {@linkcode computeSuggestCrisprQcFilters}.\n * @hideconstructor\n */\nexport class SuggestCrisprQcFiltersResults {\n    #id;\n    #results;\n\n    #filledMaxCount;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledMaxCount = filled;\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the filtering threshold on the maximum count in each batch.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    thresholdsMaxCount({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledMaxCount, \n            () => { this.#filledMaxCount = true }, \n            COPY => utils.possibleCopy(this.#results.thresholds_max_count(), COPY)\n        );\n    }\n\n    /**\n     * @return {number} Number of blocks in this object.\n     */\n    numberOfBlocks() {\n        return this.#results.num_blocks();\n    }\n\n    /**\n     * @param {PerCellCrisprQcMetricsResults} metrics - Per-cell QC metrics, usually computed by {@linkcode perCellCrisprQcMetrics}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell in `metrics`.\n     * This should have length equal to the number of cells and contain all values in `[0, n)` where `n` is the return value of {@linkcode SuggestCrisprQcFilters#numberOfBlocks numberOfBlocks}.\n     *\n     * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n     * This will raise an error if multiple blocks were used to compute the thresholds.\n     * @param {?Uint8WasmArray} [options.buffer=null] - Array of length equal to the number of cells in `metrics`, to be used to store the low-quality calls.\n     *\n     * @return {Uint8Array} Array of length equal to the number of cells in `metrics`.\n     * Each entry is truthy if the corresponding cell is deemed to be of low-quality based on its values in `metrics`.\n     * If `buffer` is supplied, the returned array is a view on `buffer`.\n     */\n    filter(metrics, { block = null, buffer = null } = {}) {\n        if (!(metrics instanceof PerCellCrisprQcMetricsResults)) {\n            throw new Error(\"'metrics' should be a PerCellCrisprQcMetricsResults object\");\n        }\n        return internal.applyFilter(this.#results, metrics, block, buffer); \n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Define filters based on the per-cell QC metrics for CRISPR guide counts.\n *\n * @param {PerCellCrisprQcMetricsResults} metrics - Per-cell QC metrics, usually computed by {@linkcode perCellCrisprQcMetrics}.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfMADs=3] - Number of median absolute deviations to use to define low-quality outliers.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to compute filters within each block.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n *\n * @return {SuggestCrisprQcFiltersResults} Object containing the filtering results.\n */\nexport function suggestCrisprQcFilters(metrics, { numberOfMADs = 3, block = null } = {}) {\n    if (!(metrics instanceof PerCellCrisprQcMetricsResults)) {\n        throw new Error(\"'metrics' should be a PerCellCrisprQcMetricsResults object\");\n    }\n    return internal.computePerCellQcFilters(\n        metrics,\n        block,\n        (x, use_blocks, bptr) => gc.call(\n            module => module.suggest_crispr_qc_filters(x.results.$$.ptr, use_blocks, bptr, numberOfMADs),\n            SuggestCrisprQcFiltersResults\n        )\n    );\n}\n\n/**\n * Create an empty {@linkplain SuggestCrisprQcFiltersResults} object, to be filled with custom results.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfBlocks Number of blocks in the dataset.\n *\n * @return {SuggestCrisprQcFiltersResults} Object with allocated memory to store QC filters, but no actual values.\n */\nexport function emptySuggestCrisprQcFiltersResults(numberOfBlocks) {\n    return gc.call(\n        module => new module.SuggestCrisprQcFilters_Results(numberOfBlocks),\n        SuggestCrisprQcFiltersResults,\n        /* filled = */ false \n    );\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\nimport * as internal from \"./internal/computePerCellQcFilters.js\";\nimport { PerCellRnaQcMetricsResults } from \"./perCellRnaQcMetrics.js\";\n\n/**\n * Wrapper class for the filtering results, produced by {@linkcode computeSuggestRnaQcFilters}.\n * @hideconstructor\n */\nexport class SuggestRnaQcFiltersResults {\n    #id;\n    #results;\n\n    #filledSums;\n    #filledDetected;\n    #filledSubsetProportions;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledSums = filled;\n        this.#filledDetected = filled;\n        this.#filledSubsetProportions = utils.spawnArray(this.numberOfSubsets(), filled);\n\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the filtering threshold on the sums for each batch.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    thresholdsSums({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSums, \n            () => { this.#filledSums = true }, \n            COPY => utils.possibleCopy(this.#results.thresholds_sums(), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the filtering threshold on the number of detected genes for each batch.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    thresholdsDetected({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledDetected, \n            () => { this.#filledDetected = true }, \n            COPY => utils.possibleCopy(this.#results.thresholds_detected(), COPY)\n        );\n    }\n\n    /**\n     * @param {number} i - Index of the feature subset of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the filtering threshold on the proportions for subset `i` in each batch.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    thresholdsSubsetProportions(i, { copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSubsetProportions[i], \n            () => { this.#filledSubsetProportions[i] = true }, \n            COPY => utils.possibleCopy(this.#results.thresholds_proportions(i), COPY)\n        );\n    }\n\n    /**\n     * @return {number} Number of feature subsets in this object.\n     */\n    numberOfSubsets() {\n        return this.#results.num_subsets();\n    }\n\n    /**\n     * @return {number} Number of blocks in this object.\n     */\n    numberOfBlocks() {\n        return this.#results.num_blocks();\n    }\n\n    /**\n     * @param {PerCellRnaQcMetricsResults} metrics - Per-cell QC metrics, usually computed by {@linkcode perCellRnaQcMetrics}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell in `metrics`.\n     * This should have length equal to the number of cells and contain all values in `[0, n)` where `n` is the return value of {@linkcode SuggestRnaQcFilters#numberOfBlocks numberOfBlocks}.\n     *\n     * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n     * This will raise an error if multiple blocks were used to compute the thresholds.\n     * @param {?Uint8WasmArray} [options.buffer=null] - Array of length equal to the number of cells in `metrics`, to be used to store the low-quality calls.\n     *\n     * @return {Uint8Array} Array of length equal to the number of cells in `metrics`.\n     * Each entry is truthy if the corresponding cell is deemed to be of low-quality based on its values in `metrics`.\n     * If `buffer` is supplied, the returned array is a view on `buffer`.\n     */\n    filter(metrics, { block = null, buffer = null } = {}) {\n        if (!(metrics instanceof PerCellRnaQcMetricsResults)) {\n            throw new Error(\"'metrics' should be a PerCellRnaQcMetricsResults object\");\n        }\n        return internal.applyFilter(this.#results, metrics, block, buffer); \n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Define filters based on the per-cell QC metrics computed from an RNA count matrix.\n *\n * @param {PerCellRnaQcMetricsResults} metrics - Per-cell QC metrics, usually computed by {@linkcode perCellRnaQcMetrics}.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfMADs=3] - Number of median absolute deviations to use to define low-quality outliers.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to compute filters within each block.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n *\n * @return {SuggestRnaQcFiltersResults} Object containing the filtering results.\n */\nexport function suggestRnaQcFilters(metrics, { numberOfMADs = 3, block = null } = {}) {\n    if (!(metrics instanceof PerCellRnaQcMetricsResults)) {\n        throw new Error(\"'metrics' should be a PerCellRnaQcMetricsResults object\");\n    }\n    return internal.computePerCellQcFilters(\n        metrics,\n        block,\n        (x, use_blocks, bptr) => gc.call(\n            module => module.suggest_rna_qc_filters(x.results.$$.ptr, use_blocks, bptr, numberOfMADs),\n            SuggestRnaQcFiltersResults\n        )\n    );\n}\n\n/**\n * Create an empty {@linkplain SuggestRnaQcFiltersResults} object, to be filled with custom results.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfSubsets Number of feature subsets.\n * @param {number} numberOfBlocks Number of blocks in the dataset.\n *\n * @return {SuggestRnaQcFiltersResults} Object with allocated memory to store QC filters, but no actual values.\n */\nexport function emptySuggestRnaQcFiltersResults(numberOfSubsets, numberOfBlocks) {\n    return gc.call(\n        module => new module.SuggestRnaQcFilters_Results(numberOfSubsets, numberOfBlocks),\n        SuggestRnaQcFiltersResults,\n        /* filled = */ false \n    );\n}\n","import { buffer, wasmArraySpace, maximumThreads } from \"./wasm.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Helper function to create a Uint8WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Uint8WasmArray} Uint8WasmArray on the **scran.js** Wasm heap.\n */\nexport function createUint8WasmArray(length) {\n    return wa.createUint8WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Int32WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Int32WasmArray} Int32WasmArray on the **scran.js** Wasm heap.\n */\nexport function createInt32WasmArray(length) {\n    return wa.createInt32WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a BigUint64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {BigUint64WasmArray} BigUint64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createBigUint64WasmArray (length) {\n    return wa.createBigUint64WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Float64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Float64WasmArray} Float64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createFloat64WasmArray(length) {\n    return wa.createFloat64WasmArray(wasmArraySpace(), length);\n}\n\nexport function wasmifyArray(x, expected) {\n    if (x instanceof wa.WasmArray) {\n        if (expected !== null && expected != x.constructor.className) {\n            throw new Error(\"expected '\" + expected + \"', got '\" + x.constructor.className + \"'\");\n        }\n\n        if (x.space === wasmArraySpace()) {\n            // Creating a view. This ensures that callers can always call\n            // free() on the output of this function without worrying about\n            // whether they are breaking something else that was using 'x'.\n            if (x.owner === null) {\n                return x.view();\n            } else {\n                return x; // it's already a view, so we just pass it along.\n            }\n        } else {\n            // If it's a different space, then we have to make a copy.\n            return x.clone(wasmArraySpace());\n        }\n    }\n\n    let y = null;\n    if (expected !== null) {\n        y = wa.convertToWasmArray(wasmArraySpace(), x, wa.stringToClass(expected));\n    } else {\n        y = wa.convertToWasmArray(wasmArraySpace(), x);\n    }\n\n    return y;\n}\n\nexport function chooseNumberOfThreads(threads) {\n    if (threads == null) {\n        return maximumThreads();\n    } else {\n        return threads;\n    }\n}\n\n/**\n * Try to free a **scran.js** object's memory (typically involving some memory allocated on the Wasm heap) by calling its `free` method.\n *\n * @param {?object} x - Instance of a **scran.js** or **wasmarrays.js** class to be freed.\n * May also be `null` or undefined.\n * \n * @return The output of `x.free()` - unless `x` is undefined or `null`, in which case nothing is performed.\n */\nexport function free(x) {\n    if (typeof x == \"undefined\" || x == null) {\n        return;\n    }\n    return x.free();\n}\n\nexport function extractXY(ncells, coordinates) {\n    let x = new Float64Array(ncells);\n    let y = new Float64Array(ncells);\n\n    for (var i = 0; i < ncells; i++) {\n        x[i] = coordinates[2 * i];\n        y[i] = coordinates[2 * i + 1];\n    }\n\n    return { \"x\": x, \"y\": y };\n}\n\n/**\n * Possibly copy an array out of the Wasm heap, avoiding potential invalidation at the cost of some efficiency.\n *\n * @param {TypedArray} x - Array of data, possibly on the **scran.js** Wasm heap.\n * @param {(string|boolean)} copy - Copying mode to use.\n *\n * @return {TypedArray|WasmArray} The return value depends on the value of `copy`:\n * - If `copy = true`, a TypedArray copy of `x` is created with `x.slice()` and returned.\n *   This is a good default to avoid invalidation of TypedArray views on the heap upon reallocation, by creating a Javascript-owned copy for downstream use.\n * - If `copy = false`, `x` is returned directly.\n *   This avoids making any copy but runs the risk of invalidation when the Wasm heap is resized;\n *   it should only be used when no further Wasm allocations are performed within the lifetime of `x`.\n * - If `copy = \"view\"`, a WasmArray view is created from `x` and returned.\n *   This avoids any copy and is robust to invalidation but requires an extra `WasmArray.array()` call to create a TypedArray.\n */\nexport function possibleCopy(x, copy) {\n    if (copy === \"view\") {\n        if (x.buffer !== buffer()) {\n            throw new Error(\"cannot use copy = \\\"view\\\" for non-Wasm TypedArrays\");\n        }\n\n        let view_class = x.constructor.name.replace(\"Array\", \"WasmArray\");\n\n        // This function should only be used for objects generated in the\n        // buffer owned by scran.js, so we can assume that x's space is the\n        // same as that of the wasmArraySpace().\n        return wa.createWasmArrayView(wasmArraySpace(), x.length, x.byteOffset, wa.stringToClass(view_class));\n\n    } else if (copy) {\n        return x.slice();\n\n    } else {\n        return x;\n    }\n}\n\nexport function matchOptions(name, value, choices) {\n    if (choices.indexOf(value) == -1) {\n        throw new Error(\"'\" + name + \"=' should be one of '\" + choices.join(\"', '\") + \"'\");\n    }\n}\n\nexport function spawnArray(n, fill) {\n    let output = new Array(n);\n    output.fill(fill);\n    return output;\n}\n\nexport function checkFillness(fill, copy, check, setFilledFun, getFun) {\n    if (!check) {\n        if (fill) {\n            setFilledFun();\n            if (copy) {\n                copy = false;\n            }\n        } else {\n            return null;\n        }\n    }\n    return getFun(copy);\n}\n","import loadScran from \"./wasm/scran.js\";\nimport { register } from \"wasmarrays.js\";\nimport * as afile from \"./abstract/file.js\";\n\nconst cache = {};\n\n/**\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfThreads=4] - Number of threads to use for calculations.\n * This will spin up the requested number of Web Workers during module initialization.\n * @param {boolean} [options.localFile=false] - Whether or not to look for the Wasm and worker scripts locally.\n * This should only be `true` when using old versions of Node.js where file URLs are not supported, \n * and is ignored completely outside of Node.js contexts.\n *\n * @return {boolean}\n * The Wasm bindings are initialized and `true` is returned.\n * If the bindings were already initialized (e.g., by a previous call), nothing is done and `false` is returned.\n */\nexport async function initialize({ numberOfThreads = 4, localFile = false } = {}) {\n    if (\"module\" in cache) {\n        return false;\n    }\n\n    let options = {\n        scran_custom_nthreads: numberOfThreads\n    };\n\n    if (localFile) {                                                                /** NODE ONLY **/  \n        options.locateFile = (x) => import.meta.url.substring(7) + \"/../wasm/\" + x; /** NODE ONLY **/\n    }                                                                               /** NODE ONLY **/\n\n    cache.module = await loadScran(options);\n    cache.space = register(cache.module);\n\n    return true;\n}\n\n/**\n * Maximum number of threads available for computation.\n * This depends on the value specified during module initialization in {@linkcode initialize}. \n *\n * @return {number} Maximum number of available threads.\n */\nexport function maximumThreads() {\n    return cache.module.scran_custom_nthreads;\n}\n\nexport function call(func) {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n\n    var output;\n    try {\n        output = func(cache.module);    \n    } catch (e) {\n        if (typeof e == \"number\") {\n            throw new Error(cache.module.get_error_message(e));\n        } else {\n            throw e;\n        }\n    }\n    return output;\n}\n\nexport function buffer() {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n    return cache.module.wasmMemory.buffer;\n}\n\n/**\n * @return {number} Integer containing the **wasmarrays.js** identifier for **scran.js**'s memory space.\n * This can be used with `createWasmArray()` and related functions from **wasmarrays.js**.\n */\nexport function wasmArraySpace() {\n    return cache.space;\n}\n\n/**\n * @return All worker threads are terminated and the module is deleted from the cache.\n * This is useful for cleaning up at the end of the analysis,\n * otherwise the workers will be shut done ungracefully on program exit.\n */\nexport function terminate() {\n    cache.module.PThread.terminateAllThreads();\n    delete cache.module;\n    return;\n}\n\n/**\n * @return {number} The current size of the Wasm heap, typically used for diagnostic reporting.\n */\nexport function heapSize() {\n    return buffer().byteLength;\n}\n","import { allocate } from \"./globals.js\";\nimport { \n    Int8WasmArray, Uint8WasmArray,\n    Int16WasmArray, Uint16WasmArray,\n    Int32WasmArray, Uint32WasmArray,\n    BigInt64WasmArray, BigUint64WasmArray,\n    Float32WasmArray, Float64WasmArray\n} from \"./derived.js\";\n\n/**\n * Create a {@linkplain WasmArray} of the specified subclass.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * @param {class} arrayClass - Desired subclass of the {@linkplain WasmArray}.\n * \n * @return {WasmArray} Instance of a {@linkplain WasmArray} subclass.\n */\nexport function createWasmArray(space, length, arrayClass) {\n    return allocate(space, length, arrayClass);\n}\n\n/**\n * Create a {@linkplain Uint8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint8WasmArray} Instance of a {@linkplain Uint8WasmArray}.\n */\nexport function createUint8WasmArray(space, length) { \n    return createWasmArray(space, length, Uint8WasmArray); \n}\n\n/**\n * Create a {@linkplain Int8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int8WasmArray} Instance of a {@linkplain Int8WasmArray}.\n */\nexport function createInt8WasmArray(space, length) { \n    return createWasmArray(space, length, Int8WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint16WasmArray} Instance of a {@linkplain Uint16WasmArray}.\n */\nexport function createUint16WasmArray(space, length) { \n    return createWasmArray(space, length, Uint16WasmArray); \n}\n\n/**\n * Create a {@linkplain Int16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int16WasmArray} Instance of a {@linkplain Int16WasmArray}.\n */\nexport function createInt16WasmArray(space, length) { \n    return createWasmArray(space, length, Int16WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint32WasmArray} Instance of a {@linkplain Uint32WasmArray}.\n */\nexport function createUint32WasmArray(space, length) { \n    return createWasmArray(space, length, Uint32WasmArray); \n}\n\n/**\n * Create a {@linkplain Int32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int32WasmArray} Instance of a {@linkplain Int32WasmArray}.\n */\nexport function createInt32WasmArray(space, length) { \n    return createWasmArray(space, length, Int32WasmArray); \n}\n\n/**\n * Create a {@linkplain BigUint64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {BigUint64WasmArray} Instance of a {@linkplain BigUint64WasmArray}.\n */\nexport function createBigUint64WasmArray(space, length) { \n    return createWasmArray(space, length, BigUint64WasmArray); \n}\n\n/**\n * Create a {@linkplain BigInt64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {BigInt64WasmArray} Instance of a {@linkplain BigInt64WasmArray}.\n */\nexport function createBigInt64WasmArray(space, length) { \n    return createWasmArray(space, length, BigInt64WasmArray); \n}\n\n/**\n * Create a {@linkplain Float32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Float32WasmArray} Instance of a {@linkplain Float32WasmArray}.\n */\nexport function createFloat32WasmArray(space, length) { \n    return createWasmArray(space, length, Float32WasmArray); \n}\n\n/**\n * Create a {@linkplain Float64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Float64WasmArray} Instance of a {@linkplain Float64WasmArray}.\n */\nexport function createFloat64WasmArray(space, length) { \n    return createWasmArray(space, length, Float64WasmArray); \n}\n","import { buffer } from \"./globals.js\";\nimport { WasmArray } from \"./base.js\";\n\n/** \n * Wrapper around an unsigned 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint8WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint8WasmArray extends WasmArray {\n    /**\n     * @return {Uint8Array} A Uint8Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string}\n     */\n    static className = \"Uint8WasmArray\";\n    // We're returning the name explicitly here instead of relying\n    // on the constructor.name trick, as the name of the class can\n    // change during minification.\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around a signed 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt8WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int8WasmArray extends WasmArray {\n    /**\n     * @return {Int8Array} An Int8Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Int8WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number}\n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around an unsigned 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint16WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint16WasmArray extends WasmArray {\n    /**\n     * @return {Uint16Array} A Uint16Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Uint16WasmArray\";\n\n    /**\n     * Size of the each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage a signed 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt16WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int16WasmArray extends WasmArray {\n    /**\n     * @return {Int16Array} An Int16Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Int16WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage an unsigned 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint32WasmArray extends WasmArray {\n    /**\n     * @return {Uint32Array} A Uint32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Uint32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a signed 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int32WasmArray extends WasmArray {\n    /**\n     * @return {Int32Array} An Int32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Int32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage an unsigned 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigUint64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class BigUint64WasmArray extends WasmArray {\n    /**\n     * @return {BigUint64Array} A BigUint64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new BigUint64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"BigUint64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a signed 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigInt64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class BigInt64WasmArray extends WasmArray {\n    /**\n     * @return {BigInt64Array} An BigInt64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new BigInt64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"BigInt64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a 32-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Float32WasmArray extends WasmArray {\n    /**\n     * @return {Float32Array} A Float32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Float32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Float32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a 64-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Float64WasmArray extends WasmArray {\n    /**\n     * @return {Float64Array} A Float64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Float64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Float64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\nconst choices = {\n    \"Uint8WasmArray\": Uint8WasmArray,\n    \"Int8WasmArray\": Int8WasmArray,\n    \"Uint16WasmArray\": Uint16WasmArray,\n    \"Int16WasmArray\": Int16WasmArray,\n    \"Uint32WasmArray\": Uint32WasmArray,\n    \"Int32WasmArray\": Int32WasmArray,\n    \"BigUint64WasmArray\": BigUint64WasmArray,\n    \"BigInt64WasmArray\": BigInt64WasmArray,\n    \"Float32WasmArray\": Float32WasmArray,\n    \"Float64WasmArray\": Float64WasmArray\n};\n\n/**\n * Retrieve class from its name.\n *\n * @param {string} name - Name of the {@linkplain WasmArray} class.\n *\n * @return {class} Class object corresponding to `name`.\n */\nexport function stringToClass(name) {\n    if (!(name in choices)){ \n        throw new Error(\"unknown WasmArray class '\" + name + \"'\");\n    }\n    return choices[name];\n}\n","import { createWasmArray } from \"./create.js\";\n\n/**\n * Helper utility to determine the length of a subset, for use in allocations.\n *\n * @param {(Array|TypedArray|WasmArray)} subset - Array specifying the subset to retain or filter out, depending on `filter`.\n * See the argument of the same name in {@linkcode subsetWasmArray} for more details.\n * @param {?boolean} filter - How to interpret `subset`.\n * See the argument of the same name in {@linkcode subsetWasmArray} for more details.\n * @param {number} targetLength - Length of the target vector to be subsetted by `subset`.\n * @param {string} targetName - Name of the target vector, for use in error messages.\n *\n * @return {number} Length of the subsetted vector.\n */\nexport function checkSubsetLength(subset, filter, targetLength, targetName) {\n    if (filter === null) {\n        subset.forEach(i => {\n            if (i < 0 || i >= targetLength) {\n                throw new Error(\"'subset' contains out-of-range indices for '\" + targetName + \"'\");\n            }\n        });\n        return subset.length;\n    } \n\n    if (subset.length != targetLength) {\n        throw new Error(\"'subset' and '\" + targetName + \"' should have the same length\");\n    }\n\n    let sum = 0;\n    subset.forEach(x => { sum += (x != 0); });\n    if (filter) {\n        return subset.length - sum;\n    } \n\n    return sum;\n}\n\n/**\n * Helper utility to fill a subset from one TypedArray to another.\n *\n * @param {(Array|TypedArray|WasmArray)} subset - Array specifying the subset to retain or filter out, depending on `filter`.\n * See the argument of the same name in {@linkcode subsetWasmArray} for more details.\n * @param {?boolean} filter - How to interpret `subset`.\n * See the argument of the same name in {@linkcode subsetWasmArray} for more details.\n * @param {TypedArray} input - Input array to subset.\n * @param {TypedArray} output - Output array to store the subset, of length defined by {@linkcode checkSubsetLength}.\n *\n * @return `output` is filled with the specified subset of values from `input`.\n */\nexport function fillSubset(subset, filter, input, output) {\n    if (filter == null) {\n        subset.forEach((s, i) => {\n            output[i] = input[s];\n        });\n    } else if (filter) {\n        let j = 0;\n        subset.forEach((y, i) => {\n            if (y == 0) {\n                output[j] = input[i];\n                j++;\n            }\n        });\n    } else {\n        let j = 0;\n        subset.forEach((y, i) => {\n            if (y !== 0) {\n                output[j] = input[i];\n                j++;\n            }\n        });\n    }\n}\n\n/**\n * Create a new WasmArray from a subset of an existing WasmArray.\n * \n * @param {WasmArray} x - The input WasmArray.\n * @param {(Array|TypedArray|WasmArray)} subset - Array specifying the subset to retain or filter out, depending on `filter`.\n * \n * If `filter = null`, the array is expected to contain integer indices specifying the entries in `x` to retain.\n * The ordering of indices in `subset` will be respected in the subsetted array.\n *\n * If `filter = true`, the array should be of length equal to that of `x`.\n * Each value is interpreted as a boolean and, if truthy, indicates that the corresponding entry of `x` should be filtered out.\n *\n * If `filter = false`, the array should be of length equal to that of `x`.\n * Each value is interpreted as a boolean and, if truthy, indicates that the corresponding entry of `x` should be retained.\n *\n * Note that TypedArray views on Wasm-allocated buffers should only be provided if `buffer` is also provided;\n * otherwise, a Wasm memory allocation may invalidate the view.\n * @param {object} [options={}] - Optional parameters.\n * @param {?boolean} [options.filter=null] - Whether to retain truthy or falsey values in a `subset` boolean filter.\n * If `null`, `subset` should instead contain the indices of elements to retain.\n * @param {?WasmArray} [options.buffer=null] - Array in which the output is to be stored.\n * If provided, this should be of length equal to `subset`, if `filter = null`; \n * the number of truthy elements in `subset`, if `filter = false`;\n * or the number of falsey elements in `subset`, if `filter = true`.\n *\n * @return {WasmArray} Array of the same type of `x` and in the same space, containing the desired subset `subset`.\n * If `buffer` is supplied, it is directly returned.\n */\nexport function subsetWasmArray(x, subset, { filter = null, buffer = null } = {}) {\n    let len = checkSubsetLength(subset, filter, x.length, \"x\"); \n\n    if (buffer == null) {\n        // Function better be a no-throw from now on.\n        buffer = createWasmArray(x.space, len, x.constructor);\n    } else if (buffer.length !== len) {\n        throw new Error(\"length of 'buffer' is not consistent with 'subset'\");\n    }\n\n    let barr = buffer.array();\n    let xarr = x.array();\n    fillSubset(subset, filter, xarr, barr);\n\n    return buffer;\n}\n","import { \n    Int8WasmArray, Uint8WasmArray,\n    Int16WasmArray, Uint16WasmArray,\n    Int32WasmArray, Uint32WasmArray,\n    BigInt64WasmArray, BigUint64WasmArray,\n    Float32WasmArray, Float64WasmArray\n} from \"./derived.js\";\n\n/**\n * Create a {@linkplain WasmArray} view of the specified subclass.\n * It is assumed that some unknown entity owns the Wasm heap allocation;\n * for example, Emscripten-defined bindings on C++ classes that own array data,\n * where it may be of interest to wrap these arrays in WasmArray instances for downstream processing.\n * The caller is responsible for ensuring that the lifetime of the returned WasmArray view does not exceed that of the owner.\n * Note that this function differs from {@linkcode WasmArray#view WasmArray.view}, which creates a WasmArray view from an exising WasmArray.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the view, in terms of the number of data elements.\n * @param {number} offset - Offset on the Wasm heap to start the view.\n * This may need to be a certain multiple of 2, 4 or 8, depending on `arrayClass`.\n * @param {class} arrayClass - Desired subclass of the {@linkplain WasmArray}.\n * \n * @return {WasmArray} Instance of a {@linkplain WasmArray} subclass containing a view on the heap.\n */\nexport function createWasmArrayView(space, length, offset, arrayClass) {\n    return new arrayClass(space, -1, length, offset, {});\n}\n\n/**\n * Create a {@linkplain Uint8WasmArray} view on Wasm memory owned by some unknown entity (see {@linkcode createWasmArrayView} for details).\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the view, in terms of the number of data elements.\n * @param {number} offset - Offset on the Wasm heap to start the view.\n * \n * @return {Uint8WasmArray} Instance of a {@linkplain Uint8WasmArray} view.\n */\nexport function createUint8WasmArrayView(space, length, offset) { \n    return createWasmArrayView(space, length, offset, Uint8WasmArray); \n}\n\n/**\n * Create an {@linkplain Int8WasmArray} view on Wasm memory owned by some unknown entity (see {@linkcode createWasmArrayView} for details).\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the view, in terms of the number of data elements.\n * @param {number} offset - Offset on the Wasm heap to start the view.\n * \n * @return {Int8WasmArray} Instance of an {@linkplain Int8WasmArray} view.\n */\nexport function createInt8WasmArrayView(space, length, offset) { \n    return createWasmArrayView(space, length, offset, Int8WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint16WasmArray} view on Wasm memory owned by some unknown entity (see {@linkcode createWasmArrayView} for details).\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the view, in terms of the number of data elements.\n * @param {number} offset - Offset on the Wasm heap to start the view.\n * \n * @return {Uint16WasmArray} Instance of a {@linkplain Uint16WasmArray} view.\n */\nexport function createUint16WasmArrayView(space, length, offset) { \n    return createWasmArrayView(space, length, offset, Uint16WasmArray); \n}\n\n/**\n * Create an {@linkplain Int16WasmArray} view on Wasm memory owned by some unknown entity (see {@linkcode createWasmArrayView} for details).\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the view, in terms of the number of data elements.\n * @param {number} offset - Offset on the Wasm heap to start the view.\n * \n * @return {Int16WasmArray} Instance of an {@linkplain Int16WasmArray} view.\n */\nexport function createInt16WasmArrayView(space, length, offset) { \n    return createWasmArrayView(space, length, offset, Int16WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint32WasmArray} view on Wasm memory owned by some unknown entity (see {@linkcode createWasmArrayView} for details).\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the view, in terms of the number of data elements.\n * @param {number} offset - Offset on the Wasm heap to start the view.\n * \n * @return {Uint32WasmArray} Instance of a {@linkplain Uint32WasmArray} view.\n */\nexport function createUint32WasmArrayView(space, length, offset) { \n    return createWasmArrayView(space, length, offset, Uint32WasmArray); \n}\n\n/**\n * Create an {@linkplain Int32WasmArray} view on Wasm memory owned by some unknown entity (see {@linkcode createWasmArrayView} for details).\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the view, in terms of the number of data elements.\n * @param {number} offset - Offset on the Wasm heap to start the view.\n * \n * @return {Int32WasmArray} Instance of an {@linkplain Int32WasmArray} view.\n */\nexport function createInt32WasmArrayView(space, length, offset) { \n    return createWasmArrayView(space, length, offset, Int32WasmArray); \n}\n\n/**\n * Create a {@linkplain BigUint64WasmArray} view on Wasm memory owned by some unknown entity (see {@linkcode createWasmArrayView} for details).\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the view, in terms of the number of data elements.\n * @param {number} offset - Offset on the Wasm heap to start the view.\n * \n * @return {BigUint64WasmArray} Instance of a {@linkplain BigUint64WasmArray} view.\n */\nexport function createBigUint64WasmArrayView(space, length, offset) { \n    return createWasmArrayView(space, length, offset, BigUint64WasmArray); \n}\n\n/**\n * Create an {@linkplain BigInt64WasmArray} view on Wasm memory owned by some unknown entity (see {@linkcode createWasmArrayView} for details).\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the view, in terms of the number of data elements.\n * @param {number} offset - Offset on the Wasm heap to start the view.\n * \n * @return {BigInt64WasmArray} Instance of an {@linkplain BigInt64WasmArray} view.\n */\nexport function createBigInt64WasmArrayView(space, length, offset) { \n    return createWasmArrayView(space, length, offset, BigInt64WasmArray); \n}\n\n\n/**\n * Create a {@linkplain Float32WasmArray} view on Wasm memory owned by some unknown entity (see {@linkcode createWasmArrayView} for details).\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the view, in terms of the number of data elements.\n * @param {number} offset - Offset on the Wasm heap to start the view.\n * \n * @return {Float32WasmArray} Instance of a {@linkplain Float32WasmArray} view.\n */\nexport function createFloat32WasmArrayView(space, length, offset) { \n    return createWasmArrayView(space, length, offset, Float32WasmArray); \n}\n\n/**\n * Create a {@linkplain Float64WasmArray} view on Wasm memory owned by some unknown entity (see {@linkcode createWasmArrayView} for details).\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the view, in terms of the number of data elements.\n * @param {number} offset - Offset on the Wasm heap to start the view.\n * \n * @return {Float64WasmArray} Instance of a {@linkplain Float64WasmArray} view.\n */\nexport function createFloat64WasmArrayView(space, length, offset) { \n    return createWasmArrayView(space, length, offset, Float64WasmArray); \n}\n"],"names":["define","s","f","self","window","n","document","postMessage","o","IS_PAPA_WORKER","a","u","b","parse","e","t","r","dynamicTyping","J","dynamicTypingFunction","transform","worker","WORKERS_SUPPORTED","i","URL","webkitURL","toString","BLOB_URL","createObjectURL","Blob","type","Worker","onmessage","_","id","userStep","step","userChunk","chunk","userComplete","complete","userError","error","input","config","workerId","NODE_STREAM_INPUT","charCodeAt","slice","download","l","p","readable","read","on","g","File","Object","c","stream","unparse","m","y","delimiter","BAD_DELIMITERS","filter","indexOf","length","quotes","Array","isArray","skipEmptyLines","newline","quoteChar","header","columns","Error","escapeChar","escapeFormulae","RegExp","Q","JSON","h","keys","data","fields","meta","v","join","trim","d","push","constructor","Date","stringify","test","replace","charAt","RECORD_SEP","String","fromCharCode","UNIT_SEP","BYTE_ORDER_MARK","LocalChunkSize","RemoteChunkSize","DefaultDelimiter","Parser","E","ParserHandle","NetworkStreamer","FileStreamer","StringStreamer","ReadableStreamStreamer","jQuery","fn","this","each","prop","toUpperCase","attr","toLowerCase","FileReader","files","file","inputElem","instanceConfig","extend","before","action","reason","name","splice","_handle","_finished","_completed","_halted","_input","_baseIndex","_partialLine","_rowCount","_start","_nextChunk","isFirstChunk","_completeResults","errors","w","chunkSize","parseInt","streamer","_config","call","parseChunk","beforeFirstChunk","paused","aborted","cursor","substring","preview","results","WORKER_ID","finished","concat","_sendError","_readChunk","_chunkLoaded","XMLHttpRequest","withCredentials","onload","onerror","_chunkError","open","downloadRequestBody","downloadRequestHeaders","setRequestHeader","send","message","status","readyState","responseText","getResponseHeader","lastIndexOf","statusText","webkitSlice","mozSlice","FileReaderSync","Math","min","size","readAsText","encoding","target","result","pause","prototype","apply","arguments","resume","_streamData","_streamEnd","_streamError","_checkIsFinished","shift","_streamCleanUp","removeListener","pow","abort","k","forEach","transformHeader","map","parseFloat","code","row","split","comments","abs","successful","bestDelimiter","delimitersToGuess","getCharIndex","setTimeout","j","z","M","P","U","q","N","B","fastMode","K","W","H","L","includes","I","F","R","C","S","D","index","T","O","A","substr","x","linebreak","truncated","terminate","create","root","factory","randomColor","seed","colorDictionary","loadColorBounds","colorRanges","options","undefined","stringToInteger","TypeError","count","totalColors","colors","color","setFormat","pickHue","pickSaturation","pickBrightness","hue","randomWithin","hueRange","getRealHueRange","getHueRange","luminosity","saturationRange","getSaturationRange","sMin","sMax","bMin","getMinimumBrightness","bMax","hsv","format","HSVtoHSL","hsl","hslColor","alpha","random","HSVtoRGB","rgbColor","HSVtoHex","lowerBounds","getColorInfo","s1","v1","s2","v2","colorInput","number","match","HexToHSB","colorName","range","golden_ratio","floor","max","rnd","rgb","componentToHex","hex","defineColor","brightnessRange","h_i","red","green","blue","cMax","delta","saturation","round","string","total","Number","MAX_SAFE_INTEGER","colorHue","isNaN","module","exports","_arrayLikeToArray","arr","len","arr2","_arrayWithHoles","_arrayWithoutHoles","_classCheckPrivateStaticAccess","receiver","classConstructor","_classCheckPrivateStaticFieldDescriptor","descriptor","_classPrivateMethodGet","privateSet","has","_classPrivateMethodInitSpec","obj","add","_classStaticPrivateFieldSpecGet","_classStaticPrivateFieldSpecSet","value","_classStaticPrivateMethodGet","method","_createForOfIteratorHelper","allowArrayLike","it","Symbol","iterator","done","_e","err","normalCompletion","didErr","next","_e2","_get","Reflect","get","bind","property","base","desc","getOwnPropertyDescriptor","_iterableToArray","iter","from","_iterableToArrayLimit","_i","_s","_x","_r","_arr","_n","_d","_nonIterableRest","_nonIterableSpread","_objectDestructuringEmpty","ownKeys","object","enumerableOnly","getOwnPropertySymbols","symbols","sym","enumerable","_objectSpread2","source","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_slicedToArray","_superPropBase","hasOwnProperty","_toConsumableArray","_unsupportedIterableToArray","minLen","cloneCached","cached","bioc","baseUrl","registry","check_class","handle","accepted","scran","_Object$entries","entries","_Object$entries$_i","className","packageName","populate_list_columns","lhandle","output","colnames","nhandle","names","ndx","findAttribute","attribute","values","load_listData_names","curhandle","load","curcol","nrow","load_data_frame","rnhandle","nrhandle","rndx","row_names","NR","extract_matrix_rownames","idx","dimhandle","firsthandle","_id","WeakMap","_rowdata","_coldata","_counts_handle","_counts_loaded","_options","_counts","WeakSet","_features","_cells","_fetchPrimaryId","ExperimentHubDataset","_classCallCheck","_classPrivateFieldInitSpec","writable","_classPrivateFieldSet","_classPrivateFieldGet","defaults","clear","_createClass","_objectSpread","_i2","_Object$entries2","_Object$entries2$_i","_summary","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_ref$cache","cache","my_rd","_args","wrap","_context","prev","_features2","_cells2","cells","utils","modality_features","abrupt","stop","_previewPrimaryIds","_callee2","_ref2$cache","_args2","_context2","_fetchPrimaryId2","_load","_callee3","_ref3$cache","counts","perm_features","_args3","_context3","_counts2","matrix","consume","row_ids","features","t0","primary_ids","RNA","buffer","TextEncoder","encode","bakana","fun","previous","_downloadFun","primaryRnaFeatureIdColumn","_step","args","_iterator","dec","TextDecoder","decode","_counts3","_callee5","details","counts_deets","_context5","sent","_features3","_callee6","rowdata_deets","rowdata_load","rowdata_handle","rowdata","_i3","_Object$entries3","_Object$entries3$_i","ids","_context6","finish","_cells3","_callee7","coldata_deets","coldata_load","coldata_handle","cd_df","_context7","coldata","numberOfRows","ncol","curfeat","hasColumn","numberOfColumns","column","rowNames","_value","_callee4","url","resp","_context4","fetch","ok","Uint8Array","arrayBuffer","t1","packId","project","path","version","_wrapNativeSuper","Class","_cache","Map","Function","set","Wrapper","construct","getPrototypeOf","configurable","setPrototypeOf","HttpError","_Error","_inherits","_super","_createSuper","_this","statusCode","checkHttpResponse","_x2","_checkHttpResponse","res","msg","info","json","globalRequestHeaders","quickGet","headers","getFile","_getFile","_ref","_ref$downloadFun","downloadFun","_ref$getFun","getFun","out","encodeURIComponent","gh","_ref2","_x3","getFileMetadata","_getFileMetadata","_ref$followLink","followLink","_project","_version","CollaboratordbNavigator","_file","adb","_metadata","_unpacked","_h5_file","_h5_path","_h5_flush","_raw_features","_raw_cells","_dump_summary","_instantiate","_feature_type_mapping","_primary_mapping","TenxHdf5Dataset","h5File","afile","_dump_summary2","futils","_feature_type_mapping2","_primary_mapping2","loaded","featureTypeRnaName","featureTypeAdtName","featureTypeCrisprName","primaryAdtFeatureIdColumn","primaryCrisprFeatureIdColumn","_unserialize","setOptions","_instantiate2","content","flush","children","mhandle","fhandle","eutils","feats","$setColumn","ftype","ADT","CRISPR","_load_data_frame","navigator","contents","rownames","parsed","current","_iterator5","_step5","ghandle","chandle","dhandle","_current","_type","replacement","placeholder","new_columns","new_colnames","nest_meta","metadata","startsWith","delim","data_frame","Int32Array","Float64Array","hdf5_data_frame","group","Float32Array","attributes","readAttribute","resource","console","warn","columnOrder","dimensions","main_experiment_name","extract_all_features","_x4","_extract_all_features","_callee9","extract_features","full_meta","_iterator6","_step6","alt","alt_meta","_context9","_ref6","_callee8","se_meta","row_path","_context8","summarized_experiment","row_data","_x19","single_cell_experiment","alternative_experiments","extract_all_assay_names","_x5","_x6","_extract_all_assay_names","_callee10","extract_assay_names","assays","_iterator8","_step8","_context10","_step7","_iterator7","ass","extract_logcounts","_x7","_x8","_extract_logcounts","_callee11","ghandle2","ghandle3","sf","ahandle","mat","_context11","log","extract_assay_raw","sizeFactors","center","extract_assay","_x9","_x10","_x11","_x12","_extract_assay","_callee12","assay","forceInteger","counter","_iterator9","_step9","asspath","_context12","_x13","_x14","_x15","_extract_assay_raw","_callee13","assmeta","schema","is_dense","is_sparse","stuff","_stuff","_context13","hdf5_sparse_matrix","hdf5_dense_array","dataset","hdf5_delayed_array","extract_other_data","_x16","_x17","_extract_other_data","_callee14","other_path","othermeta","ofile","unpacked","_context14","compression","json_simple_list","extract_list_data_internal","NaN","_navigator","_metadata_cache","MetadataCacheWrapper","nav","_x18","_path","_navigator2","_reset_local_caches","AbstractArtifactdbDataset","_reset_local_caches2","t2","modality_assay_names","fmapping","rnaExperiment","adtExperiment","crisprExperiment","mapping","altmap","alts","out_ids","_args4","exp","rnaCountAssay","adtCountAssay","crisprCountAssay","_features5","_callee15","_context15","t3","_cells5","_callee16","col_path","_context16","column_data","_path2","_navigator3","_raw_features2","_raw_cells2","_raw_other","_options2","_reset_local_caches3","_other","_get_all_reddim_names","AbstractArtifactdbResult","_reset_local_caches4","_summary2","_ref4$cache","reddim_meta","_args5","_features4","_cells4","_other2","t4","reduced_dimension_names","other_metadata","reduced_dimensions","_get_all_reddim_names2","_load2","_ref5$cache","reddims","redmap","_iterator2","_step2","_iterator3","_step3","redmeta","dims","redcontents","realized","acquired","_iterator4","_step4","_i4","_Object$entries4","_Object$entries4$_i","_k","curassay","curnormalized","normed","_args6","reducedDimensionNames","array","primaryAssay","isPrimaryNormalized","allowZeros","_features6","_callee17","_context17","_cells6","_callee18","_context18","_other3","_callee19","_context19","other_data","_x20","_x21","_get_all_reddim_names3","_callee20","rd_meta","store","_iterator10","_step10","_context20","SimpleFile","_ref$name","_mode","_buffer","_name","_ref2$copy","copy","readAsArrayBuffer","_ref3$copy","_matrix_file","_feature_file","_barcode_file","_dimensions","_fetch_dimensions","TenxMatrixMarketDataset","matrixFile","featureFile","barcodeFile","is_gz","endsWith","_serialize","feat","barcode","genes","annotations","mtx","_fetch_dimensions2","rows","fname","_output","symb","types","bname","diff","conv","callback","resolve","reject","peek","extractHDF5Strings","summarizeArray","_ref$limit","limit","chosen","Set","sort","POSITIVE_INFINITY","NEGATIVE_INFINITY","guess_compression","astream","unpackText","_ref2$compression","txt","pako","merge_bytes","leftovers","decoder","combined","stream_callback","_stream_callback","Promise","gz","onData","onEnd","readLines2","_readLines","_ref4","_ref4$compression","_ref4$chunkSize","lines","last","subarray","readTable2","_readTable","_ref6$compression","_ref6$delim","_ref6$chunkSize","size_left","str","ppp","pop","promoteToNumber","as_num","opt1","opt2","create_solo_default_object","modality","reportFeatures","rawFeatures","typeField","by_type","removeColumn","renameByModality","featureTypeMapping","splitByModality","extractSplitPrimaryIds","featureTypeDefault","primary","col","extractPrimaryIdColumn","new_default","found","multiple","findUnnamedDefault","splitScranMatrixAndFeatures","current_features","out_mat","deepCopy","type_keys","skip_subset","indices","full_length","is_subset_noop","rename","extractPrimaryIds","extractRemappedPrimaryIds","createTsneWorker","createUmapWorker","step_name","_qc","_filter","_parameters","_raw_compute","AdtNormalizationState","qc","parameters","qc_module","filter_module","changed","total_buffer","sf_buffer","centered_sf_buffer","fetchFilteredMatrix","_raw_compute2","buff","block","fetchFilteredBlock","num_pcs","num_clusters","remove_bias","valid","nutils","totals","numberOfPCs","numberOfClusters","_norm","AdtPcaState","norm","norm_module","pcs","block_method","fetchNormalizedMatrix","blockMethod","_inputs","AdtQualityControlState","inputs","inputs_module","metrics","filters","metrics_buffer","discard_buffer","fetchCountMatrix","automatic","tag_id_column","igg_prefix","nmads","min_detected_drop","tag_info","fetchFeatureAnnotations","subsets","fill","lower_igg","configureFeatureParameters","val","sub_arr","fetchBlock","numberOfMADs","minDetectedDrop","discard","numberOfCells","best_key","best","rn","columnNames","latest","_combined","BatchCorrectionState","combine_module","corrected","fetchNumberOfCells","fetchNumberOfDimensions","num_neighbors","approximate","needs_correction","fetchCombined","numberOfDims","view","find_usable_upstream_states","qc_states","in_use","tmp","to_use","_qc_states","_raw_compute_matrix","_raw_compute_block","CellFilteringState","rna_qc_module","adt_qc_module","crispr_qc_module","block_buffer","_raw_compute_matrix2","_raw_compute_block2","use_rna","use_adt","use_crispr","first","fetchDiscards","disc_buffer","disc_arr","max_index","keep","available","src","sub","clone","filtered_ncols","bcache","download_fun","set_download","acquire_file","_acquire_file","suffix","full","rutils","all_loaded","flush_prepared","_Object$values","prepared","built","raw","free","process_genes","_process_genes","gene_lines","load_reference","_load_reference","gene_id_type","gene_suffix","known_genes","suffixes","stored","labels","all","flush_loaded","available_references","internal_build_reference","gene_ids","chosen_ids","build_reference","_build_reference","references","species","gene_id_column","old_parameters","annofun","guessfun","species2","gene_id_column2","gene_id_type2","auto","allowable","ref","used_refs","_feats","CellLabellingState","integrated","transplant_parameters","fetch_parameters","transform_results","assigned","nclusters","ntargets","all_scores","cscores","scoresForCell","assign_labels_internal","temp_cluster_means","temp_matrix","ngroups","numberOfGroups","ngenes","means","columnMajor","per_reference","predictedLabels","single_results","predictedReferences","_Object$values2","assign_labels","to_collect","dump","arrays","retain","aggr","average","aggrmat","sums","groups","levels","sharedFeatures","_compute","def","guessRnaFeatureTypes","_ref$group","guesses","confidence","_i5","_defineProperty","_parameters2","_cache2","_annotations","_guesses","_pre_parameters","_guessFeatureTypes","CellLabellingStandalone","_setParameters","_ready","_classPrivateFieldGet2","_this2","_guessFeatureTypes2","_ref2$group","_snn_cluster","_kmeans_cluster","ChooseClusteringState","snn","kmeans","snn_module","kmeans_module","fetchClusters","find_nonzero_upstream_states","pca_states","weights","_pca_states","CombineEmbeddingsState","rna_pca_module","adt_pca_module","crispr_pca_module","combined_buffer","num_cells","total_dims","rna_weight","adt_weight","crispr_weight","weight_arr","collected","ncells","curpcs","fetchPCs","principalComponents","createPcsView","upstream","CrisprNormalizationState","centered_buffer","sum_buffer","createGroup","CrisprPcaState","CrisprQualityControlState","FeatureSelectionState","sorted_residuals","span","residuals","_correct","_valid","KmeansClusterState","correct","correct_module","_valid2","clusters","run_me","fetchCorrected","initMethod","_free","markers","versus","_computeVersus","left","right","matrices","_ref$block","_ref$lfc_threshold","lfc_threshold","_ref$compute_auc","compute_auc","cache_info","left_index","left_small","right_index","run","new_clusters","leftfound","rightfound","_norm_states","_choice","MarkerDetectionState","norm_states","choice","rna_norm_module","adt_norm_module","crispr_norm_module","choice_module","changed_params","lfcThreshold","computeAuc","state","_ref2$block","_ref2$lfc_threshold","_ref2$compute_auc","computeVersus","_matrices","_groups","_group_levels","_block","_block_levels","MarkerDetectionStandalone","normalized","_ref3$block","new_matrices","temp","init","_ref4$copy","ret","_ref5$copy","NeighborIndexState","RnaNormalizationState","_feat","RnaPcaState","feat_module","hvg_buffer","num_hvgs","choose_hvgs","sorted_resids","fetchSortedResiduals","threshold_at","unsorted_resids","fetchResults","element","_automatic","_acquire_reference","RnaQualityControlState","mito_prefix","use_reference_mito","backcomp","gene_info","lists","lower_mito","use_mito_default","_acquire_reference2","_mito_lists","_acquire_reference3","feature_type","mito_lists","_index","_compute_neighbors","_compute_graph","_compute_clusters","SnnGraphClusterState","neighbor_module","neighbors","graph","membership","scheme","algorithm","multilevel_resolution","leiden_resolution","walktrap_steps","_compute_neighbors2","_compute_graph2","_compute_clusters2","fetchIndex","multiLevelResolution","leidenResolution","leidenModularityObjective","walktrapSteps","_reloaded","_worker_id","_run","_core","TsneState","reloaded","aworkers","_vizutils$initializeW","vizutils","worker_id","ready","_fetchResults","_ref$copy","iterations","perplexity","animate","same_neighbors","_core2","then","reneighbor","nn_out","UmapState","num_epochs","min_dist","registerCallback","sendMessage","transfer","terminateWorker","freeCache","changedParametersIllegal","xskip","yskip","ArrayBuffer","isView","changedParameters","xnull","ynull","xarr","yarr","xkeys","ykeys","_xkeys","allocateCachedArray","reallocate","candidate","owner","findValidUpstreamStates","states","checkIndices","defaultDownload","_defaultDownload","guessFeatureTypes","forceTaxonomy","subsetInvalidFactors","invalid","transformed","num_invalid","_loop","new_ids","new_levels","summaries2int","formatMarkerResults","rankEffect","ordering","ranking","increasing","cohen","summary","auc","lfc","deltaDetected","reorder","stats","thing","stat_detected","detected","stat_mean","stat_lfc","stat_delta_d","locateVersusCache","bigg","biggversus","smal","rerun","freeVersusResults","_i8","_i9","_i10","_Object$values3","_i11","_Object$keys2","computeVersusResults","new_block","modmat","subsetSums","discards","fetchMetrics","oarr","LENGTH","_bioconductor_LENGTH","SLICE","_ref$allowView","allowView","_bioconductor_SLICE","start","end","COMBINE","objects","_bioconductor_COMBINE","total_LENGTH","position","CLONE","_ref2$deepCopy","_bioconductor_CLONE","_step3$value","SPLIT","factor","misc","_bioconductor_SPLIT","NUMBER_OF_ROWS","_bioconductor_NUMBER_OF_ROWS","NUMBER_OF_COLUMNS","_bioconductor_NUMBER_OF_COLUMNS","SLICE_2D","_ref3$allowView","_bioconductor_SLICE_2D","COMBINE_ROWS","_bioconductor_COMBINE_ROWS","COMBINE_COLUMNS","_bioconductor_COMBINE_COLUMNS","Annotated","_ref$inPlace","inPlace","cutils","setMetadata","DataFrame","_ann$Annotated","_ref$numberOfRows","_ref$rowNames","_ref$columnOrder","_ref$metadata","_possibleConstructorReturn","_numberOfRows","_rowNames","_columns","il","cause","generics","entry","numberOfEntries","_ref2$inPlace","delete","_ref3$inPlace","setColumn","_ref4$inPlace","setNames","setColumnNames","_ref5$inPlace","setRowNames","_ref6$inPlace","sliceColumns","_ref7","new_numberOfRows","_ref7$allowView","new_rowNames","all_n","all_l","yi","_ref8","_ref8$deepCopy","_getPrototypeOf","ann","flexibleCombineRows","ckeys","corder","cnames","copies","dummy","_extractor","_inserter","_primarySlicer","_secondarySlicer","DenseMatrix","_ref$columnMajor","_numberOfColumns","_values","_columnMajor","_ref2$allowView","_extractor2","setValues","_inserter2","setRow","full_rows","is_row_range","new_rows","full_columns","is_column_range","new_values","_primarySlicer2","primaryFun","secondaryFun","isPrimaryMajor","secondaryName","num_primary","num_secondary","primary_major","used_primary","cur_primary","out_offset","in_offset","out_offset2","view_offset","_combiner","nprimary","nsecondary","primaryMajor","offset","primarySlice","fullPrimary","isPrimaryRange","primaryDim","secondarySlice","fullSecondary","isSecondaryRange","inSecondaryDim","outSecondaryDim","outputValues","_secondarySlicer2","pi","inPrimary","outPrimary","si","GRanges","_vec$Vector","seqnames","ranges","_ref$strand","strand","_ref$names","_ref$elementMetadata","elementMetadata","_seqnames","_ranges","_convertToInt8Array","_checkStrandedness","Int8Array","_strand","width","setSeqnames","ir","setRanges","setStrand","_ref5","_ref5$restrictToSeqna","restrictToSeqnames","_ref5$restrictToStran","restrictToStrand","by_seqname","starts","ends","_Object$keys","seqname_indices","seqname_strand","by_strand","str_indices","olap","GRangesOverlapIndex","_ref6$allowView","all_sn","all_rr","all_st","_ref7$deepCopy","vec","query","_ref8$ignoreStrand","ignoreStrand","my_results","allowed_strands","seq_index","sstr","_staged_setGroup","_flush_staged_setGroup","GroupedGRanges","_ref$rangeLengths","rangeLengths","_assertThisInitialized","gr","_rangeLengths","accumulated","_computeStarts","_rangeStarts","_flush_staged_setGroup2","nops","setGroup","GroupedGRangesOverlapIndex","buildOverlapIndex","runs","lengths","staged","last_start","more_ranges","current_start","nranges","fullLength","rangeStarts","rev_map","_reverseMapping","overlaps","overlap","_loop2","IRanges","_width","setStart","setWidth","tree","IRangesOverlapIndex","_ref4$allowView","all_s","all_w","_ref5$deepCopy","_tree","_check_entry_index","InternalList","order","expected","observed","_entries","_order","_check_entry_index2","ii","new_entries","new_order","_ref6$deepCopy","FUN","_ref7$inPlace","combiner","first_order","_check_rowRanges","RangedSummarizedExperiment","_se$SummarizedExperim","rowRanges","ggr","_check_rowRanges2","_rowRanges","setRowRanges","has_empty","has_ggr","se","widths","setElementMetadata","_ref3","_rowData","SingleCellExperiment","_rse$RangedSummarized","_options$reducedDimen","reducedDimensions","_options$reducedDimen2","reducedDimensionOrder","_options$alternativeE","alternativeExperiments","_options$alternativeE2","alternativeExperimentOrder","_options$rowRanges","ncols","_reducedDimensions","_alternativeExperiments","removeReducedDimension","setReducedDimension","setReducedDimensionNames","sliceReducedDimensions","removeAlternativeExperiment","setAlternativeExperiment","setAlternativeExperimentNames","_ref8$inPlace","sliceAlternativeExperiments","_ref9","_ref9$allowView","_ref10","rse","SummarizedExperiment","_ref$assayOrder","assayOrder","_ref$rowData","rowData","_ref$columnData","columnData","_ref$columnNames","_assays","nrows","nr","nc","df","_columnData","_columnNames","removeAssay","setAssay","setAssayNames","sliceAssays","setRowData","setColumnData","_ref9$inPlace","_ref10$allowView","all_dfs","_ref11","_ref11$deepCopy","verifyElementMetadata","numExpected","Vector","_elementMetadata","_names","all_em","setterTarget","cloneField","presplitFactor","by","buildIntervalTree","_ref2$slice","_convertPositionToRan","_ref$slice","positions","fillIndex","at","rank2position","new_starts","new_ends","pos","startRanks","endRanks","convertPositionToRank","create_node","recursive_build_tree","one_past_the_end","left_bound","right_bound","start_overlaps_sorted","end_overlaps_sorted","left_node","right_node","node","queryIntervalTree","recursive_query_tree","areArraysEqual","isArrayLike","chooseArrayConstructors","con1","con2","BigInt64Array","BigUint64Array","formatLengthError","checkStringArray","typeMessage","checkNamesArray","lengthMessage","sum","combineNames","all_names","all_lengths","total_n","all_null","createSequence","convertToInt32Array","checkNonNegative","object2map","_collections","fetchAllCollections","_fetchAllCollections","_ref$download","cres","coll_data","reference_download","decompressLines","_genes","fetchAllGenes","_fetchAllGenes","_ref$types","promises","processing","_t","resolved","gene_data","processed","gene_download","_sets","fetchAllSets","_fetchAllSets","_yield$Promise$all","_yield$Promise$all2","sres","set_data","collection","fetchGenesForAllSets","_fetchGenesForAllSets","fetchSetsForAllGenes","_fetchSetsForAllGenes","by_symbol","by_symbol_lower","mapGenesByIdentifier","_mapGenesByIdentifier","_ref$lowerCase","lowerCase","host","sfound","tfound","_step2$value","reindexGenesForAllSets","geneMapping","genesForSets","reverse_mapping","gesel_gene","Uint32Array","new_sets","subset","gene","reindexSetsForAllGenes","setsForGenes","remapped","_store","_ncols","MultiMatrix","_ref$store","old","new_matrix","to","_matrix","ScranMatrix","gc","_ref$buffer","_ref2$buffer","sparse","reorganized","_ref3$buffer","identities","wipe_identities","_ref4$columnMajor","wa","NumericMatrix","prefix","extension","tmppath","methods","handleString","_results","AggregateAcrossCellsResults","num_groups","num_genes","group_sums","all_sums","group_detected","all_detected","aggregateAcrossCells","group_data","_ref3$average","_ref3$numberOfThreads","numberOfThreads","nthreads","aggregate_across_cells","createBlock","local_buffer","barr","sofar","subsetBlock","_ref3$filter","filterBlock","_ref4$buffer","dropUnusedBlock","fac","harvest_matrices","BigInt","$$","ptr","cbindWithNames","mat_ptrs","name_ptrs","renamed","common","universe","names_arr","replacement_arr","cbind_with_rownames","internames","_renamed","computeTopThreshold","_ref$largest","largest","_filledClusters","_filledSizes","_filledCenters","_filledWcss","_filledIterations","_filledStatus","ClusterKmeansResults","filled","num_obs","set_iterations","set_status","_ref$fillable","fillable","COPY","_ref2$fillable","cluster_sizes","_this3","_ref3$fillable","wcss","_this4","_ref4$fillable","centers","clusterKmeans","_ref5$numberOfDims","_ref5$numberOfCells","_ref5$initMethod","_ref5$initSeed","initSeed","_ref5$initPCASizeAdju","initPCASizeAdjust","_ref5$numberOfThreads","pptr","RunPCAResults","byteOffset","cluster_kmeans","_graph","BuildSNNGraphResults","buildSNNGraph","my_neighbors","_ref$scheme","_ref$neighbors","_ref$numberOfThreads","FindNearestNeighborsResults","findNearestNeighbors","build_snn_graph","_id2","_filledBest","_filledModularity","_filledMembership","_chooseLevel","ClusterSNNGraphMultiLevelResults","numberOfLevels","set_best","_ref2$level","level","_chooseLevel2","modularity","set_modularity","_ref3$level","_id3","_results2","_filledModularity2","_filledModularityDetails","_filledMembership2","ClusterSNNGraphWalktrapResults","numberOfMergeSteps","which","remaining","num_merge_steps","_ref4$at","_ref5$fillable","_id4","_results3","_filledModularity3","_filledMembership3","ClusterSNNGraphLeidenResults","_ref6$copy","_ref6$fillable","clusterSNNGraph","_ref7$method","_ref7$multiLevelResol","_ref7$leidenResolutio","_ref7$leidenModularit","_ref7$walktrapSteps","cluster_snn_graph_multilevel","cluster_snn_graph_walktrap","cluster_snn_graph_leiden","factorize","failure","_ref$asWasmArray","asWasmArray","_ref$action","_ref$placeholder","warned","isFinite","existing","convertToFactor","dropUnusedLevels","uniq","uniq_arr","filterCells","filter_data","filter_cells","BuildNeighborSearchIndexResults","num_dim","buildNeighborSearchIndex","_ref$numberOfDims","_ref$numberOfCells","_ref$approximate","build_neighbor_index","run_data","ind_data","dist_data","_ref2$runs","_ref2$indices","_ref2$distances","distances","serialize","NeighborResults","find_nearest_neighbors","groupedSizeFactors","group_arr","_ref$center","_ref$priorCount","priorCount","_ref$reference","reference","wasm","grouped_size_factors","guessFeatures","_ref$forceTaxonomy","ntotal","early_threshold","ceil","payload","ensembl_human","ensembl_mouse","ensembl_6239","ensembl_10116","ensembl_9541","ensembl_7227","ensembl_7955","ensembl_9598","symbol_human","symbol_mouse","symbol_6239","symbol_7955","hsid","mmid","any_ens","highest","hypergeometricTest","markersInSet","numberOfMarkers","featureSetSize","numberOfFeatures","markersInSet_data","numberOfMarkers_data","featureSetSize_data","numberOfFeatures_data","output_data","_ref$assumeSorted","assumeSorted","ntests","check_length","hypergeometric_test","initializeSparseMatrixFromMatrixMarket","buf_data","_ref3$compressed","compressed","_ref3$layered","layered","convert_compressed","read_matrix_market_from_buffer","read_matrix_market_from_file","isReorganized","wipeIdentities","extractMatrixMarketDimensions","_ref4$compressed","read_matrix_market_header_from_buffer","read_matrix_market_header_from_file","sarr","initializeSparseMatrixFromHDF5","_ref5$forceInteger","_ref5$layered","read_hdf5_matrix","extractHDF5MatrixDetails","extract_hdf5_matrix_details","vals","integer","initializeDenseMatrixFromDenseArray","_ref6$forceInteger","initialize_dense_matrix","initializeSparseMatrixFromRds","_ref7$consume","_ref7$forceInteger","_ref7$layered","initialize_sparse_matrix_from_rds","computePerCellQcFilters","block_data","bptr","use_blocks","applyFilter","thresholds","rebuffer","optr","computePerCellQcMetrics","subset_offsets","tmp_subsets","nsubsets","offset_offset","offset_arr","_tmp_subsets","unpack_strings","repack_strings","lengths_arr","enc","buffer_arr","_reference","LoadLabelledReferenceResults","num_samples","num_features","num_labels","loadLabelledReferenceFromBuffers","ranks","matbuf","markbuf","labbuf","load_singlepp_reference","_reference2","BuildLabelledReferenceResults","shared_features","register_features","id_array","registry_contents","convert_features","used","buildLabelledReference","referenceFeatures","mat_id_buffer","ref_id_buffer","_ref$top","top","nfeat","build_singlepp_reference","expectedNumberOfFeatures","_cell_buffer","_label_buffer","LabelCellsResults","get_best","get_scores_for_sample","get_scores_for_label","get_delta","label_cells","tempmat","labelCells","_ref6$numberOfFeature","_ref6$numberOfCells","_ref6$quantile","quantile","_ref6$numberOfThreads","run_singlepp","_integrated","IntegrateLabelledReferencesResults","num_references","integrateLabelledReferences","id_arr","loaded_arr2","ref_arr2","built_arr2","_ref7$numberOfThreads","nrefs","ref_arr","la2","ra2","ba2","integrate_singlepp_references","_ref_arr","IntegrateCellLabelsResults","numberOfLabels","_ref8$copy","_ref9$copy","_ref9$buffer","_ref10$copy","_ref10$buffer","scoresForLabel","_ref11$copy","fineTuningDelta","integrateCellLabels","aptrs","_ref12","_ref12$numberOfFeatur","_ref12$numberOfCells","_ref12$quantile","_ref12$numberOfThread","numberOfReferences","assigned_arrs","aptrs_arr","fail","integrate_singlepp","_assigned_arrs","logNormCounts","sf_data","_ref$sizeFactors","_ref$allowZeros","sfptr","use_sf","log_norm_counts","centerSizeFactors","center_size_factors","mnnCorrect","x_data","_ref$k","_ref$numberOfMADs","_ref$robustIterations","robustIterations","_ref$robustTrim","robustTrim","_ref$referencePolicy","referencePolicy","mnn_correct","_filledMeans","_filledVariances","_filledFitted","_filledResiduals","_extract","ModelGeneVarResults","numberOfBlocks","_extract2","_ref4$block","num_blocks","fillcheck","fillindex","nblocks","modelGeneVar","_ref5$block","_ref5$span","model_gene_var","_filledSums","_filledDetected","_filledSubsetTotals","PerCellAdtQcMetricsResults","numberOfSubsets","subset_totals","num_subsets","perCellAdtQcMetrics","_ref4$numberOfThreads","internal","subset_offset","per_cell_adt_qc_metrics","_filledMaxProportions","_filledMaxIndex","PerCellCrisprQcMetricsResults","max_proportion","perCellCrisprQcMetrics","per_cell_crispr_qc_metrics","_filledSubsetProportions","PerCellRnaQcMetricsResults","subset_proportions","perCellRnaQcMetrics","per_cell_rna_qc_metrics","quickAdtSizeFactors","clust","_ref$numberOfClusters","_ref$numberOfPCs","_ref$totals","runPCA","RdsObject","par","parent","RdsVector","_RdsObject","mod","fill_attribute_names","anames_buf","attribute_names_buffer","anames_len","attribute_names_length","packer","find_attribute","dispatch","load_attribute_by_index","load_attribute_by_name","RdsIntegerVector","_RdsVector","_super2","numeric_vector","RdsBooleanVector","_RdsVector2","_super3","RdsDoubleVector","_RdsVector3","_super4","RdsStringVector","_RdsVector4","_super5","fill_string_vector","buf","string_vector_buffer","string_vector_length","RdsGenericVector","_RdsVector5","_super6","_this5","load_list_element","RdsS4Object","_RdsObject2","_super7","_this6","class_name","_this7","package_name","_this8","_this9","_this10","RdsNull","_RdsVector6","_super8","cons","tt","_obj","RdsDetails","format_version","writer_version","reader_version","_this11","readRds","parse_rds_from_file","parse_rds_from_buffer","_filledComponents","_filledTotalVariance","set_total_variance","variance_explained","total_variance","feat_data","_ref3$features","_ref3$numberOfPCs","_ref3$scale","scale","_ref3$blockMethod","use_feat","fptr","run_pca","run_blocked_pca","run_multibatch_pca","perplexityToNeighbors","perplexity_to_k","scaleByNeighbors","embeddings","embed_ptrs","index_ptrs","holding_ndims","holding_weights","_ref$indices","_ref$weights","nembed","embed_arr","weight_offset","use_weights","allocator","total_ndim","total_len","index_arr","scale_by_neighbors_indices","ndims_arr","scale_by_neighbors_matrices","_deletable","scoreFeatureSet","feature_data","_ref$scale","score_feature_set","scores","checkFillness2","getfun","intifySummary","_filledCohen","_filledLfc","_filledAuc","_filledDeltaDetected","_extractBlockedStat","ScoreMarkersResults","createBlockedStatsFilled","createEffectsFilled","_extractBlockedStat2","_ref3$summary","_ref4$summary","_ref5$summary","_ref6$summary","delta_detected","scoreMarkers","_ref7$block","_ref7$lfcThreshold","_ref7$computeAuc","_ref7$computeMedian","computeMedian","_ref7$computeMaximum","computeMaximum","score_markers","subsetRows","xcopy","wasm_indices","row_subset","subsetColumns","column_subset","splitRows","_ref3$singleNull","singleNull","_ref3$createMultiMatr","createMultiMatrix","tkeys","consec","_tkeys","SuggestAdtQcFiltersResults","thresholds_detected","thresholds_subset_totals","suggestAdtQcFilters","_ref4$numberOfMADs","_ref4$minDetectedDrop","suggest_adt_qc_filters","_filledMaxCount","SuggestCrisprQcFiltersResults","thresholds_max_count","suggestCrisprQcFilters","_ref3$numberOfMADs","suggest_crispr_qc_filters","SuggestRnaQcFiltersResults","thresholds_sums","thresholds_proportions","suggestRnaQcFilters","_ref5$numberOfMADs","suggest_rna_qc_filters","createUint8WasmArray","wasmArraySpace","createInt32WasmArray","createBigUint64WasmArray","createFloat64WasmArray","wasmifyArray","space","chooseNumberOfThreads","threads","maximumThreads","possibleCopy","view_class","matchOptions","choices","spawnArray","checkFillness","check","setFilledFun","initialize","_initialize","_ref$localFile","localFile","scran_custom_nthreads","locateFile","import","loadScran","register","func","get_error_message","wasmMemory","createWasmArray","arrayClass","allocate","Uint8WasmArray","Int32WasmArray","BigUint64WasmArray","Float64WasmArray","_WasmArray","WasmArray","Int8WasmArray","_WasmArray2","Uint16WasmArray","_WasmArray3","Uint16Array","Int16WasmArray","_WasmArray4","Int16Array","Uint32WasmArray","_WasmArray5","_WasmArray6","_WasmArray7","BigInt64WasmArray","_WasmArray8","Float32WasmArray","_WasmArray9","_super9","_WasmArray10","_super10","stringToClass","subsetWasmArray","_ref$filter","targetLength","targetName","checkSubsetLength","fillSubset","createWasmArrayView"],"sourceRoot":""}